{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ts = require(\"typescript\");\r\nvar transformer_util_1 = require(\"./transformer_util\");\r\n/**\r\n * @fileoverview Creates a TypeScript transformer that parses code into a new `ts.SourceFile`,\r\n * marks the nodes as synthetic and where possible maps the new nodes back to the original nodes\r\n * via sourcemap information.\r\n */\r\nfunction createTransformerFromSourceMap(operator) {\r\n    return function (context) { return function (sourceFile) {\r\n        var sourceMapper = new NodeSourceMapper();\r\n        var newFile = ts.createSourceFile(sourceFile.fileName, operator(sourceFile, sourceMapper), ts.ScriptTarget.Latest, true);\r\n        var mappedFile = visitNode(newFile);\r\n        return transformer_util_1.updateSourceFileNode(sourceFile, mappedFile.statements);\r\n        function visitNode(node) {\r\n            return transformer_util_1.visitNodeWithSynthesizedComments(context, newFile, node, visitNodeImpl);\r\n        }\r\n        function visitNodeImpl(node) {\r\n            if (node.flags & ts.NodeFlags.Synthesized) {\r\n                return node;\r\n            }\r\n            var originalNode = sourceMapper.getOriginalNode(node);\r\n            // Use the originalNode for:\r\n            // - literals: as e.g. typescript does not support synthetic regex literals\r\n            // - identifiers: as they don't have children and behave well\r\n            //    regarding comment synthesization\r\n            // - types: as they are not emited anyways\r\n            //          and it leads to errors with `extends` cases.\r\n            if (originalNode &&\r\n                (isLiteralKind(node.kind) || node.kind === ts.SyntaxKind.Identifier ||\r\n                    transformer_util_1.isTypeNodeKind(node.kind) || node.kind === ts.SyntaxKind.IndexSignature)) {\r\n                return originalNode;\r\n            }\r\n            node = transformer_util_1.visitEachChildIgnoringTypes(node, visitNode, context);\r\n            node.flags |= ts.NodeFlags.Synthesized;\r\n            node.parent = undefined;\r\n            ts.setTextRange(node, originalNode ? originalNode : { pos: -1, end: -1 });\r\n            ts.setOriginalNode(node, originalNode);\r\n            // Loop over all nested ts.NodeArrays /\r\n            // ts.Nodes that were not visited and set their\r\n            // text range to -1 to not emit their whitespace.\r\n            // Sadly, TypeScript does not have an API for this...\r\n            // tslint:disable-next-line:no-any To read all properties\r\n            var nodeAny = node;\r\n            // tslint:disable-next-line:no-any To read all properties\r\n            var originalNodeAny = originalNode;\r\n            for (var prop in nodeAny) {\r\n                if (nodeAny.hasOwnProperty(prop)) {\r\n                    // tslint:disable-next-line:no-any\r\n                    var value = nodeAny[prop];\r\n                    if (isNodeArray(value)) {\r\n                        // reset the pos/end of all NodeArrays so that we don't emit comments\r\n                        // from them.\r\n                        ts.setTextRange(value, { pos: -1, end: -1 });\r\n                    }\r\n                    else if (isToken(value) && !(value.flags & ts.NodeFlags.Synthesized) &&\r\n                        value.getSourceFile() !== sourceFile) {\r\n                        // Use the original TextRange for all non visited tokens (e.g. the\r\n                        // `BinaryExpression.operatorToken`) to preserve the formatting\r\n                        var textRange = originalNode ? originalNodeAny[prop] : { pos: -1, end: -1 };\r\n                        ts.setTextRange(value, textRange);\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n    }; };\r\n}\r\nexports.createTransformerFromSourceMap = createTransformerFromSourceMap;\r\n/**\r\n * Implementation of the `SourceMapper` that stores and retrieves mappings\r\n * to original nodes.\r\n */\r\nvar NodeSourceMapper = /** @class */ (function () {\r\n    function NodeSourceMapper() {\r\n        this.originalNodeByGeneratedRange = new Map();\r\n        this.genStartPositions = new Map();\r\n    }\r\n    NodeSourceMapper.prototype.addFullNodeRange = function (node, genStartPos) {\r\n        var _this = this;\r\n        this.originalNodeByGeneratedRange.set(this.nodeCacheKey(node.kind, genStartPos, genStartPos + (node.getEnd() - node.getStart())), node);\r\n        node.forEachChild(function (child) { return _this.addFullNodeRange(child, genStartPos + (child.getStart() - node.getStart())); });\r\n    };\r\n    NodeSourceMapper.prototype.addMapping = function (originalNode, original, generated, length) {\r\n        var _this = this;\r\n        var originalStartPos = original.position;\r\n        var genStartPos = generated.position;\r\n        if (originalStartPos >= originalNode.getFullStart() &&\r\n            originalStartPos <= originalNode.getStart()) {\r\n            // always use the node.getStart() for the index,\r\n            // as comments and whitespaces might differ between the original and transformed code.\r\n            var diffToStart = originalNode.getStart() - originalStartPos;\r\n            originalStartPos += diffToStart;\r\n            genStartPos += diffToStart;\r\n            length -= diffToStart;\r\n            this.genStartPositions.set(originalNode, genStartPos);\r\n        }\r\n        if (originalStartPos + length === originalNode.getEnd()) {\r\n            this.originalNodeByGeneratedRange.set(this.nodeCacheKey(originalNode.kind, this.genStartPositions.get(originalNode), genStartPos + length), originalNode);\r\n        }\r\n        originalNode.forEachChild(function (child) {\r\n            if (child.getStart() >= originalStartPos && child.getEnd() <= originalStartPos + length) {\r\n                _this.addFullNodeRange(child, genStartPos + (child.getStart() - originalStartPos));\r\n            }\r\n        });\r\n    };\r\n    NodeSourceMapper.prototype.getOriginalNode = function (node) {\r\n        return this.originalNodeByGeneratedRange.get(this.nodeCacheKey(node.kind, node.getStart(), node.getEnd()));\r\n    };\r\n    NodeSourceMapper.prototype.nodeCacheKey = function (kind, start, end) {\r\n        return kind + \"#\" + start + \"#\" + end;\r\n    };\r\n    return NodeSourceMapper;\r\n}());\r\n// tslint:disable-next-line:no-any\r\nfunction isNodeArray(value) {\r\n    var anyValue = value;\r\n    return Array.isArray(value) && anyValue.pos !== undefined && anyValue.end !== undefined;\r\n}\r\n// tslint:disable-next-line:no-any\r\nfunction isToken(value) {\r\n    return value != null && typeof value === 'object' && value.kind >= ts.SyntaxKind.FirstToken &&\r\n        value.kind <= ts.SyntaxKind.LastToken;\r\n}\r\n// Copied from TypeScript\r\nfunction isLiteralKind(kind) {\r\n    return ts.SyntaxKind.FirstLiteralToken <= kind && kind <= ts.SyntaxKind.LastLiteralToken;\r\n}\r\n//# sourceMappingURL=transformer_sourcemap.js.map","sourceMap":{"version":3,"file":"transformer_sourcemap.js","sourceRoot":"","sources":["node_modules/tsickle/src/transformer_sourcemap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {SourceMapper, SourcePosition} from './source_map_utils';\nimport {isTypeNodeKind, updateSourceFileNode, visitEachChildIgnoringTypes, visitNodeWithSynthesizedComments} from './transformer_util';\n\n/**\n * @fileoverview Creates a TypeScript transformer that parses code into a new `ts.SourceFile`,\n * marks the nodes as synthetic and where possible maps the new nodes back to the original nodes\n * via sourcemap information.\n */\nexport function createTransformerFromSourceMap(\n    operator: (sourceFile: ts.SourceFile, sourceMapper: SourceMapper) =>\n        string): ts.TransformerFactory<ts.SourceFile> {\n  return (context) => (sourceFile) => {\n    const sourceMapper = new NodeSourceMapper();\n    const newFile = ts.createSourceFile(\n        sourceFile.fileName, operator(sourceFile, sourceMapper), ts.ScriptTarget.Latest, true);\n    const mappedFile = visitNode(newFile);\n    return updateSourceFileNode(sourceFile, mappedFile.statements);\n\n    function visitNode<T extends ts.Node>(node: T): T {\n      return visitNodeWithSynthesizedComments(context, newFile, node, visitNodeImpl) as T;\n    }\n\n    function visitNodeImpl(node: ts.Node) {\n      if (node.flags & ts.NodeFlags.Synthesized) {\n        return node;\n      }\n      const originalNode = sourceMapper.getOriginalNode(node);\n\n      // Use the originalNode for:\n      // - literals: as e.g. typescript does not support synthetic regex literals\n      // - identifiers: as they don't have children and behave well\n      //    regarding comment synthesization\n      // - types: as they are not emited anyways\n      //          and it leads to errors with `extends` cases.\n      if (originalNode &&\n          (isLiteralKind(node.kind) || node.kind === ts.SyntaxKind.Identifier ||\n           isTypeNodeKind(node.kind) || node.kind === ts.SyntaxKind.IndexSignature)) {\n        return originalNode;\n      }\n      node = visitEachChildIgnoringTypes(node, visitNode, context);\n\n      node.flags |= ts.NodeFlags.Synthesized;\n      node.parent = undefined;\n      ts.setTextRange(node, originalNode ? originalNode : {pos: -1, end: -1});\n      ts.setOriginalNode(node, originalNode);\n\n      // Loop over all nested ts.NodeArrays /\n      // ts.Nodes that were not visited and set their\n      // text range to -1 to not emit their whitespace.\n      // Sadly, TypeScript does not have an API for this...\n      // tslint:disable-next-line:no-any To read all properties\n      const nodeAny = node as {[key: string]: any};\n      // tslint:disable-next-line:no-any To read all properties\n      const originalNodeAny = originalNode as {[key: string]: any};\n      for (const prop in nodeAny) {\n        if (nodeAny.hasOwnProperty(prop)) {\n          // tslint:disable-next-line:no-any\n          const value = nodeAny[prop];\n          if (isNodeArray(value)) {\n            // reset the pos/end of all NodeArrays so that we don't emit comments\n            // from them.\n            ts.setTextRange(value, {pos: -1, end: -1});\n          } else if (\n              isToken(value) && !(value.flags & ts.NodeFlags.Synthesized) &&\n              value.getSourceFile() !== sourceFile) {\n            // Use the original TextRange for all non visited tokens (e.g. the\n            // `BinaryExpression.operatorToken`) to preserve the formatting\n            const textRange = originalNode ? originalNodeAny[prop] : {pos: -1, end: -1};\n            ts.setTextRange(value, textRange);\n          }\n        }\n      }\n\n      return node;\n    }\n  };\n}\n\n/**\n * Implementation of the `SourceMapper` that stores and retrieves mappings\n * to original nodes.\n */\nclass NodeSourceMapper implements SourceMapper {\n  private originalNodeByGeneratedRange = new Map<string, ts.Node>();\n  private genStartPositions = new Map<ts.Node, number>();\n\n  private addFullNodeRange(node: ts.Node, genStartPos: number) {\n    this.originalNodeByGeneratedRange.set(\n        this.nodeCacheKey(node.kind, genStartPos, genStartPos + (node.getEnd() - node.getStart())),\n        node);\n    node.forEachChild(\n        child => this.addFullNodeRange(child, genStartPos + (child.getStart() - node.getStart())));\n  }\n\n  addMapping(\n      originalNode: ts.Node, original: SourcePosition, generated: SourcePosition, length: number) {\n    let originalStartPos = original.position;\n    let genStartPos = generated.position;\n    if (originalStartPos >= originalNode.getFullStart() &&\n        originalStartPos <= originalNode.getStart()) {\n      // always use the node.getStart() for the index,\n      // as comments and whitespaces might differ between the original and transformed code.\n      const diffToStart = originalNode.getStart() - originalStartPos;\n      originalStartPos += diffToStart;\n      genStartPos += diffToStart;\n      length -= diffToStart;\n      this.genStartPositions.set(originalNode, genStartPos);\n    }\n    if (originalStartPos + length === originalNode.getEnd()) {\n      this.originalNodeByGeneratedRange.set(\n          this.nodeCacheKey(\n              originalNode.kind, this.genStartPositions.get(originalNode)!, genStartPos + length),\n          originalNode);\n    }\n    originalNode.forEachChild((child) => {\n      if (child.getStart() >= originalStartPos && child.getEnd() <= originalStartPos + length) {\n        this.addFullNodeRange(child, genStartPos + (child.getStart() - originalStartPos));\n      }\n    });\n  }\n\n  getOriginalNode(node: ts.Node): ts.Node|undefined {\n    return this.originalNodeByGeneratedRange.get(\n        this.nodeCacheKey(node.kind, node.getStart(), node.getEnd()));\n  }\n\n  private nodeCacheKey(kind: ts.SyntaxKind, start: number, end: number): string {\n    return `${kind}#${start}#${end}`;\n  }\n}\n\n// tslint:disable-next-line:no-any\nfunction isNodeArray(value: any): value is ts.NodeArray<any> {\n  const anyValue = value;\n  return Array.isArray(value) && anyValue.pos !== undefined && anyValue.end !== undefined;\n}\n\n// tslint:disable-next-line:no-any\nfunction isToken(value: any): value is ts.Token<any> {\n  return value != null && typeof value === 'object' && value.kind >= ts.SyntaxKind.FirstToken &&\n      value.kind <= ts.SyntaxKind.LastToken;\n}\n\n// Copied from TypeScript\nfunction isLiteralKind(kind: ts.SyntaxKind) {\n  return ts.SyntaxKind.FirstLiteralToken <= kind && kind <= ts.SyntaxKind.LastLiteralToken;\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/source_map_utils.ts","node_modules/tsickle/src/transformer_util.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./source_map_utils","resolvedPath":"node_modules/tsickle/src/source_map_utils","external":false,"resolved":true},{"modulePath":"./transformer_util","resolvedPath":"node_modules/tsickle/src/transformer_util","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/transformer_sourcemap.ts","message":"Cannot find module 'typescript'.","line":9,"column":21},{"code":2339,"fileName":"node_modules/tsickle/src/transformer_sourcemap.ts","message":"Property 'flags' does not exist on type 'never'.","line":74,"column":41},{"code":2339,"fileName":"node_modules/tsickle/src/transformer_sourcemap.ts","message":"Property 'getSourceFile' does not exist on type 'never'.","line":75,"column":21}]},"hash":"13aff1307c33b87d775716b05276cbc5a273ced7"}