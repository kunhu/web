{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ts = require(\"typescript\");\r\nvar source_map_utils_1 = require(\"./source_map_utils\");\r\n/**\r\n * A Rewriter manages iterating through a ts.SourceFile, copying input\r\n * to output while letting the subclass potentially alter some nodes\r\n * along the way by implementing maybeProcess().\r\n */\r\nvar Rewriter = /** @class */ (function () {\r\n    function Rewriter(file, sourceMapper) {\r\n        if (sourceMapper === void 0) { sourceMapper = source_map_utils_1.NOOP_SOURCE_MAPPER; }\r\n        this.file = file;\r\n        this.sourceMapper = sourceMapper;\r\n        this.output = [];\r\n        /** Errors found while examining the code. */\r\n        this.diagnostics = [];\r\n        /** Current position in the output. */\r\n        this.position = { line: 0, column: 0, position: 0 };\r\n        /**\r\n         * The current level of recursion through TypeScript Nodes.  Used in formatting internal debug\r\n         * print statements.\r\n         */\r\n        this.indent = 0;\r\n        /**\r\n         * Skip emitting any code before the given offset. E.g. used to avoid emitting @fileoverview\r\n         * comments twice.\r\n         */\r\n        this.skipCommentsUpToOffset = -1;\r\n    }\r\n    Rewriter.prototype.getOutput = function () {\r\n        if (this.indent !== 0) {\r\n            throw new Error('visit() failed to track nesting');\r\n        }\r\n        return {\r\n            output: this.output.join(''),\r\n            diagnostics: this.diagnostics,\r\n        };\r\n    };\r\n    /**\r\n     * visit traverses a Node, recursively writing all nodes not handled by this.maybeProcess.\r\n     */\r\n    Rewriter.prototype.visit = function (node) {\r\n        // this.logWithIndent('node: ' + ts.SyntaxKind[node.kind]);\r\n        this.indent++;\r\n        try {\r\n            if (!this.maybeProcess(node)) {\r\n                this.writeNode(node);\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!e.message)\r\n                e.message = 'Unhandled error in tsickle';\r\n            e.message += \"\\n at \" + ts.SyntaxKind[node.kind] + \" in \" + this.file.fileName + \":\";\r\n            var _a = this.file.getLineAndCharacterOfPosition(node.getStart()), line = _a.line, character = _a.character;\r\n            e.message += line + 1 + \":\" + (character + 1);\r\n            throw e;\r\n        }\r\n        this.indent--;\r\n    };\r\n    /**\r\n     * maybeProcess lets subclasses optionally processes a node.\r\n     *\r\n     * @return True if the node has been handled and doesn't need to be traversed;\r\n     *    false to have the node written and its children recursively visited.\r\n     */\r\n    Rewriter.prototype.maybeProcess = function (node) {\r\n        return false;\r\n    };\r\n    /** writeNode writes a ts.Node, calling this.visit() on its children. */\r\n    Rewriter.prototype.writeNode = function (node, skipComments, newLineIfCommentsStripped) {\r\n        if (skipComments === void 0) { skipComments = false; }\r\n        if (newLineIfCommentsStripped === void 0) { newLineIfCommentsStripped = true; }\r\n        var pos = node.getFullStart();\r\n        if (skipComments) {\r\n            // To skip comments, we skip all whitespace/comments preceding\r\n            // the node.  But if there was anything skipped we should emit\r\n            // a newline in its place so that the node remains separated\r\n            // from the previous node.  TODO: don't skip anything here if\r\n            // there wasn't any comment.\r\n            if (newLineIfCommentsStripped && node.getFullStart() < node.getStart()) {\r\n                this.emit('\\n');\r\n            }\r\n            pos = node.getStart();\r\n        }\r\n        this.writeNodeFrom(node, pos);\r\n    };\r\n    Rewriter.prototype.writeNodeFrom = function (node, pos, end) {\r\n        var _this = this;\r\n        if (end === void 0) { end = node.getEnd(); }\r\n        if (end <= this.skipCommentsUpToOffset) {\r\n            return;\r\n        }\r\n        var oldSkipCommentsUpToOffset = this.skipCommentsUpToOffset;\r\n        this.skipCommentsUpToOffset = Math.max(this.skipCommentsUpToOffset, pos);\r\n        ts.forEachChild(node, function (child) {\r\n            _this.writeRange(node, pos, child.getFullStart());\r\n            _this.visit(child);\r\n            pos = child.getEnd();\r\n        });\r\n        this.writeRange(node, pos, end);\r\n        this.skipCommentsUpToOffset = oldSkipCommentsUpToOffset;\r\n    };\r\n    Rewriter.prototype.writeLeadingTrivia = function (node) {\r\n        this.writeRange(node, node.getFullStart(), node.getStart());\r\n    };\r\n    Rewriter.prototype.addSourceMapping = function (node) {\r\n        this.writeRange(node, node.getEnd(), node.getEnd());\r\n    };\r\n    /**\r\n     * Write a span of the input file as expressed by absolute offsets.\r\n     * These offsets are found in attributes like node.getFullStart() and\r\n     * node.getEnd().\r\n     */\r\n    Rewriter.prototype.writeRange = function (node, from, to) {\r\n        var fullStart = node.getFullStart();\r\n        var textStart = node.getStart();\r\n        if (from >= fullStart && from < textStart) {\r\n            from = Math.max(from, this.skipCommentsUpToOffset);\r\n        }\r\n        // Add a source mapping. writeRange(from, to) always corresponds to\r\n        // original source code, so add a mapping at the current location that\r\n        // points back to the location at `from`. The additional code generated\r\n        // by tsickle will then be considered part of the last mapped code\r\n        // section preceding it. That's arguably incorrect (e.g. for the fake\r\n        // methods defining properties), but is good enough for stack traces.\r\n        var pos = this.file.getLineAndCharacterOfPosition(from);\r\n        this.sourceMapper.addMapping(node, { line: pos.line, column: pos.character, position: from }, this.position, to - from);\r\n        // getSourceFile().getText() is wrong here because it has the text of\r\n        // the SourceFile node of the AST, which doesn't contain the comments\r\n        // preceding that node.  Semantically these ranges are just offsets\r\n        // into the original source file text, so slice from that.\r\n        var text = this.file.text.slice(from, to);\r\n        if (text) {\r\n            this.emit(text);\r\n        }\r\n    };\r\n    Rewriter.prototype.emit = function (str) {\r\n        this.output.push(str);\r\n        for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {\r\n            var c = str_1[_i];\r\n            this.position.column++;\r\n            if (c === '\\n') {\r\n                this.position.line++;\r\n                this.position.column = 0;\r\n            }\r\n        }\r\n        this.position.position += str.length;\r\n    };\r\n    /** Removes comment metacharacters from a string, to make it safe to embed in a comment. */\r\n    Rewriter.prototype.escapeForComment = function (str) {\r\n        return str.replace(/\\/\\*/g, '__').replace(/\\*\\//g, '__');\r\n    };\r\n    /* tslint:disable: no-unused-variable */\r\n    Rewriter.prototype.logWithIndent = function (message) {\r\n        /* tslint:enable: no-unused-variable */\r\n        var prefix = new Array(this.indent + 1).join('| ');\r\n        console.log(prefix + message);\r\n    };\r\n    /**\r\n     * Produces a compiler error that references the Node's kind.  This is useful for the \"else\"\r\n     * branch of code that is attempting to handle all possible input Node types, to ensure all cases\r\n     * covered.\r\n     */\r\n    Rewriter.prototype.errorUnimplementedKind = function (node, where) {\r\n        this.error(node, ts.SyntaxKind[node.kind] + \" not implemented in \" + where);\r\n    };\r\n    Rewriter.prototype.error = function (node, messageText) {\r\n        this.diagnostics.push({\r\n            file: this.file,\r\n            start: node.getStart(),\r\n            length: node.getEnd() - node.getStart(),\r\n            messageText: messageText,\r\n            category: ts.DiagnosticCategory.Error,\r\n            code: 0,\r\n        });\r\n    };\r\n    return Rewriter;\r\n}());\r\nexports.Rewriter = Rewriter;\r\n/** Returns the string contents of a ts.Identifier. */\r\nfunction getIdentifierText(identifier) {\r\n    // NOTE: the 'text' property on an Identifier may be escaped if it starts\r\n    // with '__', so just use getText().\r\n    return identifier.getText();\r\n}\r\nexports.getIdentifierText = getIdentifierText;\r\n/**\r\n * Converts an escaped TypeScript name into the original source name.\r\n * Prefer getIdentifierText() instead if possible.\r\n */\r\nfunction unescapeName(name) {\r\n    // See the private function unescapeIdentifier in TypeScript's utilities.ts.\r\n    if (name.match(/^___/))\r\n        return name.substr(1);\r\n    return name;\r\n}\r\nexports.unescapeName = unescapeName;\r\n//# sourceMappingURL=rewriter.js.map","sourceMap":{"version":3,"file":"rewriter.js","sourceRoot":"","sources":["node_modules/tsickle/src/rewriter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {NOOP_SOURCE_MAPPER, SourceMapper, SourcePosition} from './source_map_utils';\n\n/**\n * A Rewriter manages iterating through a ts.SourceFile, copying input\n * to output while letting the subclass potentially alter some nodes\n * along the way by implementing maybeProcess().\n */\nexport abstract class Rewriter {\n  private output: string[] = [];\n  /** Errors found while examining the code. */\n  protected diagnostics: ts.Diagnostic[] = [];\n  /** Current position in the output. */\n  private position: SourcePosition = {line: 0, column: 0, position: 0};\n  /**\n   * The current level of recursion through TypeScript Nodes.  Used in formatting internal debug\n   * print statements.\n   */\n  private indent = 0;\n  /**\n   * Skip emitting any code before the given offset. E.g. used to avoid emitting @fileoverview\n   * comments twice.\n   */\n  private skipCommentsUpToOffset = -1;\n\n  constructor(public file: ts.SourceFile, private sourceMapper: SourceMapper = NOOP_SOURCE_MAPPER) {\n  }\n\n  getOutput(): {output: string, diagnostics: ts.Diagnostic[]} {\n    if (this.indent !== 0) {\n      throw new Error('visit() failed to track nesting');\n    }\n    return {\n      output: this.output.join(''),\n      diagnostics: this.diagnostics,\n    };\n  }\n\n  /**\n   * visit traverses a Node, recursively writing all nodes not handled by this.maybeProcess.\n   */\n  visit(node: ts.Node) {\n    // this.logWithIndent('node: ' + ts.SyntaxKind[node.kind]);\n    this.indent++;\n    try {\n      if (!this.maybeProcess(node)) {\n        this.writeNode(node);\n      }\n    } catch (e) {\n      if (!e.message) e.message = 'Unhandled error in tsickle';\n      e.message += `\\n at ${ts.SyntaxKind[node.kind]} in ${this.file.fileName}:`;\n      const {line, character} = this.file.getLineAndCharacterOfPosition(node.getStart());\n      e.message += `${line + 1}:${character + 1}`;\n      throw e;\n    }\n    this.indent--;\n  }\n\n  /**\n   * maybeProcess lets subclasses optionally processes a node.\n   *\n   * @return True if the node has been handled and doesn't need to be traversed;\n   *    false to have the node written and its children recursively visited.\n   */\n  protected maybeProcess(node: ts.Node): boolean {\n    return false;\n  }\n\n  /** writeNode writes a ts.Node, calling this.visit() on its children. */\n  writeNode(node: ts.Node, skipComments = false, newLineIfCommentsStripped = true) {\n    let pos = node.getFullStart();\n    if (skipComments) {\n      // To skip comments, we skip all whitespace/comments preceding\n      // the node.  But if there was anything skipped we should emit\n      // a newline in its place so that the node remains separated\n      // from the previous node.  TODO: don't skip anything here if\n      // there wasn't any comment.\n      if (newLineIfCommentsStripped && node.getFullStart() < node.getStart()) {\n        this.emit('\\n');\n      }\n      pos = node.getStart();\n    }\n    this.writeNodeFrom(node, pos);\n  }\n\n  writeNodeFrom(node: ts.Node, pos: number, end = node.getEnd()) {\n    if (end <= this.skipCommentsUpToOffset) {\n      return;\n    }\n    const oldSkipCommentsUpToOffset = this.skipCommentsUpToOffset;\n    this.skipCommentsUpToOffset = Math.max(this.skipCommentsUpToOffset, pos);\n    ts.forEachChild(node, child => {\n      this.writeRange(node, pos, child.getFullStart());\n      this.visit(child);\n      pos = child.getEnd();\n    });\n    this.writeRange(node, pos, end);\n    this.skipCommentsUpToOffset = oldSkipCommentsUpToOffset;\n  }\n\n  writeLeadingTrivia(node: ts.Node) {\n    this.writeRange(node, node.getFullStart(), node.getStart());\n  }\n\n  addSourceMapping(node: ts.Node) {\n    this.writeRange(node, node.getEnd(), node.getEnd());\n  }\n\n  /**\n   * Write a span of the input file as expressed by absolute offsets.\n   * These offsets are found in attributes like node.getFullStart() and\n   * node.getEnd().\n   */\n  writeRange(node: ts.Node, from: number, to: number) {\n    const fullStart = node.getFullStart();\n    const textStart = node.getStart();\n    if (from >= fullStart && from < textStart) {\n      from = Math.max(from, this.skipCommentsUpToOffset);\n    }\n    // Add a source mapping. writeRange(from, to) always corresponds to\n    // original source code, so add a mapping at the current location that\n    // points back to the location at `from`. The additional code generated\n    // by tsickle will then be considered part of the last mapped code\n    // section preceding it. That's arguably incorrect (e.g. for the fake\n    // methods defining properties), but is good enough for stack traces.\n    const pos = this.file.getLineAndCharacterOfPosition(from);\n    this.sourceMapper.addMapping(\n        node, {line: pos.line, column: pos.character, position: from}, this.position, to - from);\n    // getSourceFile().getText() is wrong here because it has the text of\n    // the SourceFile node of the AST, which doesn't contain the comments\n    // preceding that node.  Semantically these ranges are just offsets\n    // into the original source file text, so slice from that.\n    const text = this.file.text.slice(from, to);\n    if (text) {\n      this.emit(text);\n    }\n  }\n\n  emit(str: string) {\n    this.output.push(str);\n    for (const c of str) {\n      this.position.column++;\n      if (c === '\\n') {\n        this.position.line++;\n        this.position.column = 0;\n      }\n    }\n    this.position.position += str.length;\n  }\n\n  /** Removes comment metacharacters from a string, to make it safe to embed in a comment. */\n  escapeForComment(str: string): string {\n    return str.replace(/\\/\\*/g, '__').replace(/\\*\\//g, '__');\n  }\n\n  /* tslint:disable: no-unused-variable */\n  logWithIndent(message: string) {\n    /* tslint:enable: no-unused-variable */\n    const prefix = new Array(this.indent + 1).join('| ');\n    console.log(prefix + message);\n  }\n\n  /**\n   * Produces a compiler error that references the Node's kind.  This is useful for the \"else\"\n   * branch of code that is attempting to handle all possible input Node types, to ensure all cases\n   * covered.\n   */\n  errorUnimplementedKind(node: ts.Node, where: string) {\n    this.error(node, `${ts.SyntaxKind[node.kind]} not implemented in ${where}`);\n  }\n\n  error(node: ts.Node, messageText: string) {\n    this.diagnostics.push({\n      file: this.file,\n      start: node.getStart(),\n      length: node.getEnd() - node.getStart(),\n      messageText,\n      category: ts.DiagnosticCategory.Error,\n      code: 0,\n    });\n  }\n}\n\n/** Returns the string contents of a ts.Identifier. */\nexport function getIdentifierText(identifier: ts.Identifier): string {\n  // NOTE: the 'text' property on an Identifier may be escaped if it starts\n  // with '__', so just use getText().\n  return identifier.getText();\n}\n\n/**\n * Converts an escaped TypeScript name into the original source name.\n * Prefer getIdentifierText() instead if possible.\n */\nexport function unescapeName(name: string): string {\n  // See the private function unescapeIdentifier in TypeScript's utilities.ts.\n  if (name.match(/^___/)) return name.substr(1);\n  return name;\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/source_map_utils.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./source_map_utils","resolvedPath":"node_modules/tsickle/src/source_map_utils","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/rewriter.ts","message":"Cannot find module 'typescript'.","line":9,"column":21},{"code":2354,"fileName":"node_modules/tsickle/src/rewriter.ts","message":"This syntax requires an imported helper but module 'tslib' cannot be found.","line":61,"column":14}]},"hash":"68175a2fe599c6a4dd4e59a941bd7ce67aa799af"}