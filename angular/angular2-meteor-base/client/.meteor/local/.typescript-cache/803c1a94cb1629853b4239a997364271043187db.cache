{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar source_map_1 = require(\"source-map\");\r\n/**\r\n * Return a new RegExp object every time we want one because the\r\n * RegExp object has internal state that we don't want to persist\r\n * between different logical uses.\r\n */\r\nfunction getInlineSourceMapRegex() {\r\n    return new RegExp('^//# sourceMappingURL=data:application/json;base64,(.*)$', 'mg');\r\n}\r\nfunction containsInlineSourceMap(source) {\r\n    return getInlineSourceMapCount(source) > 0;\r\n}\r\nexports.containsInlineSourceMap = containsInlineSourceMap;\r\nfunction getInlineSourceMapCount(source) {\r\n    var match = source.match(getInlineSourceMapRegex());\r\n    return match ? match.length : 0;\r\n}\r\nexports.getInlineSourceMapCount = getInlineSourceMapCount;\r\nfunction extractInlineSourceMap(source) {\r\n    var inlineSourceMapRegex = getInlineSourceMapRegex();\r\n    var previousResult = null;\r\n    var result = null;\r\n    // We want to extract the last source map in the source file\r\n    // since that's probably the most recent one added.  We keep\r\n    // matching against the source until we don't get a result,\r\n    // then we use the previous result.\r\n    do {\r\n        previousResult = result;\r\n        result = inlineSourceMapRegex.exec(source);\r\n    } while (result !== null);\r\n    var base64EncodedMap = previousResult[1];\r\n    return Buffer.from(base64EncodedMap, 'base64').toString('utf8');\r\n}\r\nexports.extractInlineSourceMap = extractInlineSourceMap;\r\nfunction removeInlineSourceMap(source) {\r\n    return source.replace(getInlineSourceMapRegex(), '');\r\n}\r\nexports.removeInlineSourceMap = removeInlineSourceMap;\r\n/**\r\n * Sets the source map inline in the file.  If there's an existing inline source\r\n * map, it clobbers it.\r\n */\r\nfunction setInlineSourceMap(source, sourceMap) {\r\n    var encodedSourceMap = Buffer.from(sourceMap, 'utf8').toString('base64');\r\n    if (containsInlineSourceMap(source)) {\r\n        return source.replace(getInlineSourceMapRegex(), \"//# sourceMappingURL=data:application/json;base64,\" + encodedSourceMap);\r\n    }\r\n    else {\r\n        return source + \"\\n//# sourceMappingURL=data:application/json;base64,\" + encodedSourceMap;\r\n    }\r\n}\r\nexports.setInlineSourceMap = setInlineSourceMap;\r\nfunction parseSourceMap(text, fileName, sourceName) {\r\n    var rawSourceMap = JSON.parse(text);\r\n    if (sourceName) {\r\n        rawSourceMap.sources = [sourceName];\r\n    }\r\n    if (fileName) {\r\n        rawSourceMap.file = fileName;\r\n    }\r\n    return rawSourceMap;\r\n}\r\nexports.parseSourceMap = parseSourceMap;\r\nfunction sourceMapConsumerToGenerator(sourceMapConsumer) {\r\n    return source_map_1.SourceMapGenerator.fromSourceMap(sourceMapConsumer);\r\n}\r\nexports.sourceMapConsumerToGenerator = sourceMapConsumerToGenerator;\r\n/**\r\n * Tsc identifies source files by their relative path to the output file.  Since\r\n * there's no easy way to identify these relative paths when tsickle generates its\r\n * own source maps, we patch them with the file name from the tsc source maps\r\n * before composing them.\r\n */\r\nfunction sourceMapGeneratorToConsumer(sourceMapGenerator, fileName, sourceName) {\r\n    var rawSourceMap = sourceMapGenerator.toJSON();\r\n    if (sourceName) {\r\n        rawSourceMap.sources = [sourceName];\r\n    }\r\n    if (fileName) {\r\n        rawSourceMap.file = fileName;\r\n    }\r\n    return new source_map_1.SourceMapConsumer(rawSourceMap);\r\n}\r\nexports.sourceMapGeneratorToConsumer = sourceMapGeneratorToConsumer;\r\nfunction sourceMapTextToConsumer(sourceMapText) {\r\n    // the SourceMapConsumer constructor returns a BasicSourceMapConsumer or an\r\n    // IndexedSourceMapConsumer depending on if you pass in a RawSourceMap or a\r\n    // RawIndexMap or the string json of either.  In this case we're passing in\r\n    // the string for a RawSourceMap, so we always get a BasicSourceMapConsumer\r\n    return new source_map_1.SourceMapConsumer(sourceMapText);\r\n}\r\nexports.sourceMapTextToConsumer = sourceMapTextToConsumer;\r\nfunction sourceMapTextToGenerator(sourceMapText) {\r\n    return source_map_1.SourceMapGenerator.fromSourceMap(sourceMapTextToConsumer(sourceMapText));\r\n}\r\nexports.sourceMapTextToGenerator = sourceMapTextToGenerator;\r\nexports.NOOP_SOURCE_MAPPER = {\r\n    // tslint:disable-next-line:no-empty\r\n    addMapping: function () { }\r\n};\r\nvar DefaultSourceMapper = /** @class */ (function () {\r\n    function DefaultSourceMapper(fileName) {\r\n        this.fileName = fileName;\r\n        /** The source map that's generated while rewriting this file. */\r\n        this.sourceMap = new source_map_1.SourceMapGenerator();\r\n        this.sourceMap.addMapping({\r\n            // tsc's source maps use 1-indexed lines, 0-indexed columns\r\n            original: { line: 1, column: 0 },\r\n            generated: { line: 1, column: 0 },\r\n            source: this.fileName,\r\n        });\r\n    }\r\n    DefaultSourceMapper.prototype.addMapping = function (node, original, generated, length) {\r\n        if (length > 0) {\r\n            this.sourceMap.addMapping({\r\n                // tsc's source maps use 1-indexed lines, 0-indexed columns\r\n                original: { line: original.line + 1, column: original.column },\r\n                generated: { line: generated.line + 1, column: generated.column },\r\n                source: this.fileName,\r\n            });\r\n        }\r\n    };\r\n    return DefaultSourceMapper;\r\n}());\r\nexports.DefaultSourceMapper = DefaultSourceMapper;\r\n//# sourceMappingURL=source_map_utils.js.map","sourceMap":{"version":3,"file":"source_map_utils.js","sourceRoot":"","sources":["node_modules/tsickle/src/source_map_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BasicSourceMapConsumer, RawSourceMap, SourceMapConsumer, SourceMapGenerator} from 'source-map';\nimport * as ts from 'typescript';\n\n/**\n * Return a new RegExp object every time we want one because the\n * RegExp object has internal state that we don't want to persist\n * between different logical uses.\n */\nfunction getInlineSourceMapRegex(): RegExp {\n  return new RegExp('^//# sourceMappingURL=data:application/json;base64,(.*)$', 'mg');\n}\n\nexport function containsInlineSourceMap(source: string): boolean {\n  return getInlineSourceMapCount(source) > 0;\n}\n\nexport function getInlineSourceMapCount(source: string): number {\n  const match = source.match(getInlineSourceMapRegex());\n  return match ? match.length : 0;\n}\n\nexport function extractInlineSourceMap(source: string): string {\n  const inlineSourceMapRegex = getInlineSourceMapRegex();\n  let previousResult: RegExpExecArray|null = null;\n  let result: RegExpExecArray|null = null;\n  // We want to extract the last source map in the source file\n  // since that's probably the most recent one added.  We keep\n  // matching against the source until we don't get a result,\n  // then we use the previous result.\n  do {\n    previousResult = result;\n    result = inlineSourceMapRegex.exec(source);\n  } while (result !== null);\n  const base64EncodedMap = previousResult![1];\n  return Buffer.from(base64EncodedMap, 'base64').toString('utf8');\n}\n\nexport function removeInlineSourceMap(source: string): string {\n  return source.replace(getInlineSourceMapRegex(), '');\n}\n\n/**\n * Sets the source map inline in the file.  If there's an existing inline source\n * map, it clobbers it.\n */\nexport function setInlineSourceMap(source: string, sourceMap: string): string {\n  const encodedSourceMap = Buffer.from(sourceMap, 'utf8').toString('base64');\n  if (containsInlineSourceMap(source)) {\n    return source.replace(\n        getInlineSourceMapRegex(),\n        `//# sourceMappingURL=data:application/json;base64,${encodedSourceMap}`);\n  } else {\n    return `${source}\\n//# sourceMappingURL=data:application/json;base64,${encodedSourceMap}`;\n  }\n}\n\nexport function parseSourceMap(text: string, fileName?: string, sourceName?: string): RawSourceMap {\n  const rawSourceMap = JSON.parse(text) as RawSourceMap;\n  if (sourceName) {\n    rawSourceMap.sources = [sourceName];\n  }\n  if (fileName) {\n    rawSourceMap.file = fileName;\n  }\n  return rawSourceMap;\n}\n\nexport function sourceMapConsumerToGenerator(sourceMapConsumer: SourceMapConsumer):\n    SourceMapGenerator {\n  return SourceMapGenerator.fromSourceMap(sourceMapConsumer);\n}\n\n/**\n * Tsc identifies source files by their relative path to the output file.  Since\n * there's no easy way to identify these relative paths when tsickle generates its\n * own source maps, we patch them with the file name from the tsc source maps\n * before composing them.\n */\nexport function sourceMapGeneratorToConsumer(\n    sourceMapGenerator: SourceMapGenerator, fileName?: string,\n    sourceName?: string): SourceMapConsumer {\n  const rawSourceMap = sourceMapGenerator.toJSON();\n  if (sourceName) {\n    rawSourceMap.sources = [sourceName];\n  }\n  if (fileName) {\n    rawSourceMap.file = fileName;\n  }\n  return new SourceMapConsumer(rawSourceMap);\n}\n\nexport function sourceMapTextToConsumer(sourceMapText: string): BasicSourceMapConsumer {\n  // the SourceMapConsumer constructor returns a BasicSourceMapConsumer or an\n  // IndexedSourceMapConsumer depending on if you pass in a RawSourceMap or a\n  // RawIndexMap or the string json of either.  In this case we're passing in\n  // the string for a RawSourceMap, so we always get a BasicSourceMapConsumer\n  return new SourceMapConsumer(sourceMapText) as BasicSourceMapConsumer;\n}\n\nexport function sourceMapTextToGenerator(sourceMapText: string): SourceMapGenerator {\n  return SourceMapGenerator.fromSourceMap(sourceMapTextToConsumer(sourceMapText));\n}\n\nexport interface SourcePosition {\n  // 0 based\n  column: number;\n  // 0 based\n  line: number;\n  // 0 based\n  position: number;\n}\n\nexport interface SourceMapper {\n  addMapping(\n      originalNode: ts.Node, original: SourcePosition, generated: SourcePosition,\n      length: number): void;\n}\n\nexport const NOOP_SOURCE_MAPPER: SourceMapper = {\n  // tslint:disable-next-line:no-empty\n  addMapping() {}\n};\n\nexport class DefaultSourceMapper implements SourceMapper {\n  /** The source map that's generated while rewriting this file. */\n  public sourceMap = new SourceMapGenerator();\n\n  constructor(private fileName: string) {\n    this.sourceMap.addMapping({\n      // tsc's source maps use 1-indexed lines, 0-indexed columns\n      original: {line: 1, column: 0},\n      generated: {line: 1, column: 0},\n      source: this.fileName,\n    });\n  }\n\n  addMapping(node: ts.Node, original: SourcePosition, generated: SourcePosition, length: number):\n      void {\n    if (length > 0) {\n      this.sourceMap.addMapping({\n        // tsc's source maps use 1-indexed lines, 0-indexed columns\n        original: {line: original.line + 1, column: original.column},\n        generated: {line: generated.line + 1, column: generated.column},\n        source: this.fileName,\n      });\n    }\n  }\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":[],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"source-map","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/source_map_utils.ts","message":"Cannot find module 'source-map'.","line":9,"column":91},{"code":2307,"fileName":"node_modules/tsickle/src/source_map_utils.ts","message":"Cannot find module 'typescript'.","line":10,"column":21},{"code":2304,"fileName":"node_modules/tsickle/src/source_map_utils.ts","message":"Cannot find name 'Buffer'.","line":43,"column":10},{"code":2304,"fileName":"node_modules/tsickle/src/source_map_utils.ts","message":"Cannot find name 'Buffer'.","line":55,"column":28}]},"hash":"803c1a94cb1629853b4239a997364271043187db"}