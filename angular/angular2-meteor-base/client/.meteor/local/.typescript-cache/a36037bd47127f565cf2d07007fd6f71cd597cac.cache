{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ts = require(\"typescript\");\r\nvar tsickle = require(\"./tsickle\");\r\n/**\r\n * Adjusts the given CustomTransformers with additional transformers\r\n * to fix bugs in TypeScript.\r\n */\r\nfunction createCustomTransformers(given) {\r\n    if (!given.after && !given.before) {\r\n        return given;\r\n    }\r\n    var before = given.before || [];\r\n    before.unshift(addFileContexts);\r\n    before.push(prepareNodesBeforeTypeScriptTransform);\r\n    var after = given.after || [];\r\n    after.unshift(emitMissingSyntheticCommentsAfterTypescriptTransform);\r\n    return { before: before, after: after };\r\n}\r\nexports.createCustomTransformers = createCustomTransformers;\r\n/**\r\n * Transform that adds the FileContext to the TransformationContext.\r\n */\r\nfunction addFileContexts(context) {\r\n    return function (sourceFile) {\r\n        context.fileContext = new FileContext(sourceFile);\r\n        return sourceFile;\r\n    };\r\n}\r\nfunction assertFileContext(context, sourceFile) {\r\n    if (!context.fileContext) {\r\n        throw new Error(\"Illegal State: FileContext not initialized. \" +\r\n            \"Did you forget to add the \\\"firstTransform\\\" as first transformer? \" +\r\n            (\"File: \" + sourceFile.fileName));\r\n    }\r\n    if (context.fileContext.file.fileName !== sourceFile.fileName) {\r\n        throw new Error(\"Illegal State: File of the FileContext does not match. File: \" + sourceFile.fileName);\r\n    }\r\n    return context.fileContext;\r\n}\r\n/**\r\n * A context that stores information per file to e.g. allow communication\r\n * between transformers.\r\n * There is one ts.TransformationContext per emit,\r\n * but files are handled sequentially by all transformers. Thefore we can\r\n * store file related information on a property on the ts.TransformationContext,\r\n * given that we reset it in the first transformer.\r\n */\r\nvar FileContext = /** @class */ (function () {\r\n    function FileContext(file) {\r\n        this.file = file;\r\n        /**\r\n         * Stores the parent node for all processed nodes.\r\n         * This is needed for nodes from the parse tree that are used\r\n         * in a synthetic node as must not modify these, even though they\r\n         * have a new parent now.\r\n         */\r\n        this.syntheticNodeParents = new Map();\r\n        this.importOrReexportDeclarations = [];\r\n        this.lastCommentEnd = -1;\r\n    }\r\n    return FileContext;\r\n}());\r\n/**\r\n * Transform that needs to be executed right before TypeScript's transform.\r\n *\r\n * This prepares the node tree to workaround some bugs in the TypeScript emitter.\r\n */\r\nfunction prepareNodesBeforeTypeScriptTransform(context) {\r\n    return function (sourceFile) {\r\n        var fileCtx = assertFileContext(context, sourceFile);\r\n        var nodePath = [];\r\n        visitNode(sourceFile);\r\n        return sourceFile;\r\n        function visitNode(node) {\r\n            var startNode = node;\r\n            var parent = nodePath[nodePath.length - 1];\r\n            if (node.flags & ts.NodeFlags.Synthesized) {\r\n                // Set `parent` for synthetic nodes as well,\r\n                // as otherwise the TS emit will crash for decorators.\r\n                // Note: don't update the `parent` of original nodes, as:\r\n                // 1) we don't want to change them at all\r\n                // 2) TS emit becomes errorneous in some cases if we add a synthetic parent.\r\n                // see https://github.com/Microsoft/TypeScript/issues/17384\r\n                node.parent = parent;\r\n            }\r\n            fileCtx.syntheticNodeParents.set(node, parent);\r\n            var originalNode = ts.getOriginalNode(node);\r\n            // Needed so that e.g. `module { ... }` prints the variable statement\r\n            // before the closure.\r\n            // See https://github.com/Microsoft/TypeScript/issues/17596\r\n            // tslint:disable-next-line:no-any as `symbol` is @internal in typescript.\r\n            node.symbol = originalNode.symbol;\r\n            if (originalNode && node.kind === ts.SyntaxKind.ExportDeclaration) {\r\n                var originalEd = originalNode;\r\n                var ed = node;\r\n                if (!!originalEd.exportClause !== !!ed.exportClause) {\r\n                    // Tsickle changes `export * ...` into named exports.\r\n                    // In this case, don't set the original node for the ExportDeclaration\r\n                    // as otherwise TypeScript does not emit the exports.\r\n                    // See https://github.com/Microsoft/TypeScript/issues/17597\r\n                    ts.setOriginalNode(node, undefined);\r\n                }\r\n            }\r\n            if (node.kind === ts.SyntaxKind.ImportDeclaration ||\r\n                node.kind === ts.SyntaxKind.ExportDeclaration) {\r\n                var ied = node;\r\n                if (ied.moduleSpecifier) {\r\n                    fileCtx.importOrReexportDeclarations.push(ied);\r\n                }\r\n            }\r\n            // recurse\r\n            nodePath.push(node);\r\n            node.forEachChild(visitNode);\r\n            nodePath.pop();\r\n        }\r\n    };\r\n}\r\n/**\r\n * Transform that needs to be executed after TypeScript's transform.\r\n *\r\n * This fixes places where the TypeScript transformer does not\r\n * emit synthetic comments.\r\n *\r\n * See https://github.com/Microsoft/TypeScript/issues/17594\r\n */\r\nfunction emitMissingSyntheticCommentsAfterTypescriptTransform(context) {\r\n    return function (sourceFile) {\r\n        var fileContext = assertFileContext(context, sourceFile);\r\n        var nodePath = [];\r\n        visitNode(sourceFile);\r\n        context.fileContext = undefined;\r\n        return sourceFile;\r\n        function visitNode(node) {\r\n            if (node.kind === ts.SyntaxKind.Identifier) {\r\n                var parent1 = fileContext.syntheticNodeParents.get(node);\r\n                var parent2 = parent1 && fileContext.syntheticNodeParents.get(parent1);\r\n                var parent3 = parent2 && fileContext.syntheticNodeParents.get(parent2);\r\n                if (parent1 && parent1.kind === ts.SyntaxKind.PropertyDeclaration) {\r\n                    // TypeScript ignores synthetic comments on (static) property declarations\r\n                    // with initializers.\r\n                    // find the parent ExpressionStatement like MyClass.foo = ...\r\n                    var expressionStmt = lastNodeWith(nodePath, function (node) { return node.kind === ts.SyntaxKind.ExpressionStatement; });\r\n                    if (expressionStmt) {\r\n                        ts.setSyntheticLeadingComments(expressionStmt, ts.getSyntheticLeadingComments(parent1) || []);\r\n                    }\r\n                }\r\n                else if (parent3 && parent3.kind === ts.SyntaxKind.VariableStatement &&\r\n                    tsickle.hasModifierFlag(parent3, ts.ModifierFlags.Export)) {\r\n                    // TypeScript ignores synthetic comments on exported variables.\r\n                    // find the parent ExpressionStatement like exports.foo = ...\r\n                    var expressionStmt = lastNodeWith(nodePath, function (node) { return node.kind === ts.SyntaxKind.ExpressionStatement; });\r\n                    if (expressionStmt) {\r\n                        ts.setSyntheticLeadingComments(expressionStmt, ts.getSyntheticLeadingComments(parent3) || []);\r\n                    }\r\n                }\r\n            }\r\n            // TypeScript ignores synthetic comments on reexport / import statements.\r\n            var moduleName = extractModuleNameFromRequireVariableStatement(node);\r\n            if (moduleName && fileContext.importOrReexportDeclarations) {\r\n                // Locate the original import/export declaration via the\r\n                // text range.\r\n                var importOrReexportDeclaration = fileContext.importOrReexportDeclarations.find(function (ied) { return ied.pos === node.pos; });\r\n                if (importOrReexportDeclaration) {\r\n                    ts.setSyntheticLeadingComments(node, ts.getSyntheticLeadingComments(importOrReexportDeclaration) || []);\r\n                }\r\n                // Need to clear the textRange for ImportDeclaration / ExportDeclaration as\r\n                // otherwise TypeScript would emit the original comments even if we set the\r\n                // ts.EmitFlag.NoComments. (see also resetNodeTextRangeToPreventDuplicateComments below)\r\n                ts.setSourceMapRange(node, { pos: node.pos, end: node.end });\r\n                ts.setTextRange(node, { pos: -1, end: -1 });\r\n            }\r\n            nodePath.push(node);\r\n            node.forEachChild(visitNode);\r\n            nodePath.pop();\r\n        }\r\n    };\r\n}\r\nfunction extractModuleNameFromRequireVariableStatement(node) {\r\n    if (node.kind !== ts.SyntaxKind.VariableStatement) {\r\n        return null;\r\n    }\r\n    var varStmt = node;\r\n    var decls = varStmt.declarationList.declarations;\r\n    var init;\r\n    if (decls.length !== 1 || !(init = decls[0].initializer) ||\r\n        init.kind !== ts.SyntaxKind.CallExpression) {\r\n        return null;\r\n    }\r\n    var callExpr = init;\r\n    if (callExpr.expression.kind !== ts.SyntaxKind.Identifier ||\r\n        callExpr.expression.text !== 'require' ||\r\n        callExpr.arguments.length !== 1) {\r\n        return null;\r\n    }\r\n    var moduleExpr = callExpr.arguments[0];\r\n    if (moduleExpr.kind !== ts.SyntaxKind.StringLiteral) {\r\n        return null;\r\n    }\r\n    return moduleExpr.text;\r\n}\r\nfunction lastNodeWith(nodes, predicate) {\r\n    for (var i = nodes.length - 1; i >= 0; i--) {\r\n        var node = nodes[i];\r\n        if (predicate(node)) {\r\n            return node;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Convert comment text ranges before and after a node\r\n * into ts.SynthesizedComments for the node and prevent the\r\n * comment text ranges to be emitted, to allow\r\n * changing these comments.\r\n *\r\n * This function takes a visitor to be able to do some\r\n * state management after the caller is done changing a node.\r\n */\r\nfunction visitNodeWithSynthesizedComments(context, sourceFile, node, visitor) {\r\n    if (node.flags & ts.NodeFlags.Synthesized) {\r\n        return visitor(node);\r\n    }\r\n    if (node.kind === ts.SyntaxKind.Block) {\r\n        var block_1 = node;\r\n        node = visitNodeStatementsWithSynthesizedComments(context, sourceFile, node, block_1.statements, function (node, stmts) { return visitor(ts.updateBlock(block_1, stmts)); });\r\n    }\r\n    else if (node.kind === ts.SyntaxKind.SourceFile) {\r\n        node = visitNodeStatementsWithSynthesizedComments(context, sourceFile, node, sourceFile.statements, function (node, stmts) { return visitor(updateSourceFileNode(sourceFile, stmts)); });\r\n    }\r\n    else {\r\n        var fileContext = assertFileContext(context, sourceFile);\r\n        var leadingLastCommentEnd = synthesizeLeadingComments(sourceFile, node, fileContext.lastCommentEnd);\r\n        var trailingLastCommentEnd = synthesizeTrailingComments(sourceFile, node);\r\n        if (leadingLastCommentEnd !== -1) {\r\n            fileContext.lastCommentEnd = leadingLastCommentEnd;\r\n        }\r\n        node = visitor(node);\r\n        if (trailingLastCommentEnd !== -1) {\r\n            fileContext.lastCommentEnd = trailingLastCommentEnd;\r\n        }\r\n    }\r\n    return resetNodeTextRangeToPreventDuplicateComments(node);\r\n}\r\nexports.visitNodeWithSynthesizedComments = visitNodeWithSynthesizedComments;\r\n/**\r\n * Reset the text range for some special nodes as otherwise TypeScript\r\n * would always emit the original comments for them.\r\n * See https://github.com/Microsoft/TypeScript/issues/17594\r\n *\r\n * @param node\r\n */\r\nfunction resetNodeTextRangeToPreventDuplicateComments(node) {\r\n    ts.setEmitFlags(node, (ts.getEmitFlags(node) || 0) | ts.EmitFlags.NoComments);\r\n    // See also addSyntheticCommentsAfterTsTransformer.\r\n    // Note: Don't reset the textRange for ts.ExportDeclaration / ts.ImportDeclaration\r\n    // until after the TypeScript transformer as we need the source location\r\n    // to map the generated `require` calls back to the original\r\n    // ts.ExportDeclaration / ts.ImportDeclaration nodes.\r\n    var allowTextRange = node.kind !== ts.SyntaxKind.ClassDeclaration &&\r\n        node.kind !== ts.SyntaxKind.VariableDeclaration &&\r\n        !(node.kind === ts.SyntaxKind.VariableStatement &&\r\n            tsickle.hasModifierFlag(node, ts.ModifierFlags.Export));\r\n    if (node.kind === ts.SyntaxKind.PropertyDeclaration) {\r\n        allowTextRange = false;\r\n        var pd = node;\r\n        // TODO(tbosch): Using pd.initializer! as the typescript typings before 2.4.0\r\n        // are incorrect. Remove this once we upgrade to TypeScript 2.4.0.\r\n        node = ts.updateProperty(pd, pd.decorators, pd.modifiers, resetTextRange(pd.name), pd.type, pd.initializer);\r\n    }\r\n    if (!allowTextRange) {\r\n        node = resetTextRange(node);\r\n    }\r\n    return node;\r\n    function resetTextRange(node) {\r\n        if (!(node.flags & ts.NodeFlags.Synthesized)) {\r\n            // need to clone as we don't want to modify source nodes,\r\n            // as the parsed SourceFiles could be cached!\r\n            node = ts.getMutableClone(node);\r\n        }\r\n        var textRange = { pos: node.pos, end: node.end };\r\n        ts.setSourceMapRange(node, textRange);\r\n        ts.setTextRange(node, { pos: -1, end: -1 });\r\n        return node;\r\n    }\r\n}\r\n/**\r\n * Reads in the leading comment text ranges of the given node,\r\n * converts them into `ts.SyntheticComment`s and stores them on the node.\r\n *\r\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\r\n *\r\n * @param lastCommentEnd The end of the last comment\r\n * @return The end of the last found comment, -1 if no comment was found.\r\n */\r\nfunction synthesizeLeadingComments(sourceFile, node, lastCommentEnd) {\r\n    var parent = node.parent;\r\n    var sharesStartWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&\r\n        parent.kind !== ts.SyntaxKind.SourceFile && parent.getFullStart() === node.getFullStart();\r\n    if (sharesStartWithParent || lastCommentEnd >= node.getStart()) {\r\n        return -1;\r\n    }\r\n    var adjustedNodeFullStart = Math.max(lastCommentEnd, node.getFullStart());\r\n    var leadingComments = getAllLeadingCommentRanges(sourceFile, adjustedNodeFullStart, node.getStart());\r\n    if (leadingComments && leadingComments.length) {\r\n        ts.setSyntheticLeadingComments(node, synthesizeCommentRanges(sourceFile, leadingComments));\r\n        return node.getStart();\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Reads in the trailing comment text ranges of the given node,\r\n * converts them into `ts.SyntheticComment`s and stores them on the node.\r\n *\r\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\r\n *\r\n * @return The end of the last found comment, -1 if no comment was found.\r\n */\r\nfunction synthesizeTrailingComments(sourceFile, node) {\r\n    var parent = node.parent;\r\n    var sharesEndWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&\r\n        parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();\r\n    if (sharesEndWithParent) {\r\n        return -1;\r\n    }\r\n    var trailingComments = ts.getTrailingCommentRanges(sourceFile.text, node.getEnd());\r\n    if (trailingComments && trailingComments.length) {\r\n        ts.setSyntheticTrailingComments(node, synthesizeCommentRanges(sourceFile, trailingComments));\r\n        return trailingComments[trailingComments.length - 1].end;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Convert leading/trailing detached comment ranges of statement arrays\r\n * (e.g. the statements of a ts.SourceFile or ts.Block) into\r\n * `ts.NonEmittedStatement`s with `ts.SynthesizedComment`s and\r\n * prepends / appends them to the given statement array.\r\n * This is needed to allow changing these comments.\r\n *\r\n * This function takes a visitor to be able to do some\r\n * state management after the caller is done changing a node.\r\n */\r\nfunction visitNodeStatementsWithSynthesizedComments(context, sourceFile, node, statements, visitor) {\r\n    var leading = synthesizeDetachedLeadingComments(sourceFile, node, statements);\r\n    var trailing = synthesizeDetachedTrailingComments(sourceFile, node, statements);\r\n    if (leading.commentStmt || trailing.commentStmt) {\r\n        statements = ts.setTextRange(ts.createNodeArray(statements), { pos: -1, end: -1 });\r\n        if (leading.commentStmt) {\r\n            statements.unshift(leading.commentStmt);\r\n        }\r\n        if (trailing.commentStmt) {\r\n            statements.push(trailing.commentStmt);\r\n        }\r\n        var fileContext = assertFileContext(context, sourceFile);\r\n        if (leading.lastCommentEnd !== -1) {\r\n            fileContext.lastCommentEnd = leading.lastCommentEnd;\r\n        }\r\n        node = visitor(node, statements);\r\n        if (trailing.lastCommentEnd !== -1) {\r\n            fileContext.lastCommentEnd = trailing.lastCommentEnd;\r\n        }\r\n        return node;\r\n    }\r\n    return visitor(node, statements);\r\n}\r\n/**\r\n * Convert leading detached comment ranges of statement arrays\r\n * (e.g. the statements of a ts.SourceFile or ts.Block) into a\r\n * `ts.NonEmittedStatement` with `ts.SynthesizedComment`s.\r\n *\r\n * A Detached leading comment is the first comment in a SourceFile / Block\r\n * that is separated with a newline from the first statement.\r\n *\r\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\r\n */\r\nfunction synthesizeDetachedLeadingComments(sourceFile, node, statements) {\r\n    var triviaEnd = statements.end;\r\n    if (statements.length) {\r\n        triviaEnd = statements[0].getStart();\r\n    }\r\n    var detachedComments = getDetachedLeadingCommentRanges(sourceFile, statements.pos, triviaEnd);\r\n    if (!detachedComments.length) {\r\n        return { commentStmt: null, lastCommentEnd: -1 };\r\n    }\r\n    var lastCommentEnd = detachedComments[detachedComments.length - 1].end;\r\n    var commentStmt = createNotEmittedStatement(sourceFile);\r\n    ts.setEmitFlags(commentStmt, ts.EmitFlags.CustomPrologue);\r\n    ts.setSyntheticTrailingComments(commentStmt, synthesizeCommentRanges(sourceFile, detachedComments));\r\n    return { commentStmt: commentStmt, lastCommentEnd: lastCommentEnd };\r\n}\r\n/**\r\n * Convert trailing detached comment ranges of statement arrays\r\n * (e.g. the statements of a ts.SourceFile or ts.Block) into a\r\n * `ts.NonEmittedStatement` with `ts.SynthesizedComment`s.\r\n *\r\n * A Detached trailing comment are all comments after the first newline\r\n * the follows the last statement in a SourceFile / Block.\r\n *\r\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\r\n */\r\nfunction synthesizeDetachedTrailingComments(sourceFile, node, statements) {\r\n    var trailingCommentStart = statements.end;\r\n    if (statements.length) {\r\n        var lastStmt = statements[statements.length - 1];\r\n        var lastStmtTrailingComments = ts.getTrailingCommentRanges(sourceFile.text, lastStmt.end);\r\n        if (lastStmtTrailingComments && lastStmtTrailingComments.length) {\r\n            trailingCommentStart = lastStmtTrailingComments[lastStmtTrailingComments.length - 1].end;\r\n        }\r\n    }\r\n    var detachedComments = getAllLeadingCommentRanges(sourceFile, trailingCommentStart, node.end);\r\n    if (!detachedComments || !detachedComments.length) {\r\n        return { commentStmt: null, lastCommentEnd: -1 };\r\n    }\r\n    var lastCommentEnd = detachedComments[detachedComments.length - 1].end;\r\n    var commentStmt = createNotEmittedStatement(sourceFile);\r\n    ts.setEmitFlags(commentStmt, ts.EmitFlags.CustomPrologue);\r\n    ts.setSyntheticLeadingComments(commentStmt, synthesizeCommentRanges(sourceFile, detachedComments));\r\n    return { commentStmt: commentStmt, lastCommentEnd: lastCommentEnd };\r\n}\r\n/**\r\n * Calculates the the detached leading comment ranges in an area of a SourceFile.\r\n * @param sourceFile The source file\r\n * @param start Where to start scanning\r\n * @param end Where to end scanning\r\n */\r\n// Note: This code is based on compiler/comments.ts in TypeScript\r\nfunction getDetachedLeadingCommentRanges(sourceFile, start, end) {\r\n    var leadingComments = getAllLeadingCommentRanges(sourceFile, start, end);\r\n    if (!leadingComments || !leadingComments.length) {\r\n        return [];\r\n    }\r\n    var detachedComments = [];\r\n    var lastComment = undefined;\r\n    for (var _i = 0, leadingComments_1 = leadingComments; _i < leadingComments_1.length; _i++) {\r\n        var comment = leadingComments_1[_i];\r\n        if (lastComment) {\r\n            var lastCommentLine = getLineOfPos(sourceFile, lastComment.end);\r\n            var commentLine = getLineOfPos(sourceFile, comment.pos);\r\n            if (commentLine >= lastCommentLine + 2) {\r\n                // There was a blank line between the last comment and this comment.  This\r\n                // comment is not part of the copyright comments.  Return what we have so\r\n                // far.\r\n                break;\r\n            }\r\n        }\r\n        detachedComments.push(comment);\r\n        lastComment = comment;\r\n    }\r\n    if (detachedComments.length) {\r\n        // All comments look like they could have been part of the copyright header.  Make\r\n        // sure there is at least one blank line between it and the node.  If not, it's not\r\n        // a copyright header.\r\n        var lastCommentLine = getLineOfPos(sourceFile, detachedComments[detachedComments.length - 1].end);\r\n        var nodeLine = getLineOfPos(sourceFile, end);\r\n        if (nodeLine >= lastCommentLine + 2) {\r\n            // Valid detachedComments\r\n            return detachedComments;\r\n        }\r\n    }\r\n    return [];\r\n}\r\nfunction getLineOfPos(sourceFile, pos) {\r\n    return ts.getLineAndCharacterOfPosition(sourceFile, pos).line;\r\n}\r\n/**\r\n * Converts `ts.CommentRange`s into `ts.SynthesizedComment`s\r\n * @param sourceFile\r\n * @param parsedComments\r\n */\r\nfunction synthesizeCommentRanges(sourceFile, parsedComments) {\r\n    var synthesizedComments = [];\r\n    parsedComments.forEach(function (_a, commentIdx) {\r\n        var kind = _a.kind, pos = _a.pos, end = _a.end, hasTrailingNewLine = _a.hasTrailingNewLine;\r\n        var commentText = sourceFile.text.substring(pos, end).trim();\r\n        if (kind === ts.SyntaxKind.MultiLineCommentTrivia) {\r\n            commentText = commentText.replace(/(^\\/\\*)|(\\*\\/$)/g, '');\r\n        }\r\n        else if (kind === ts.SyntaxKind.SingleLineCommentTrivia) {\r\n            if (commentText.startsWith('///')) {\r\n                // tripple-slash comments are typescript specific, ignore them in the output.\r\n                return;\r\n            }\r\n            commentText = commentText.replace(/(^\\/\\/)/g, '');\r\n        }\r\n        synthesizedComments.push({ kind: kind, text: commentText, hasTrailingNewLine: hasTrailingNewLine, pos: -1, end: -1 });\r\n    });\r\n    return synthesizedComments;\r\n}\r\n/**\r\n * Creates a non emitted statement that can be used to store synthesized comments.\r\n */\r\nfunction createNotEmittedStatement(sourceFile) {\r\n    var stmt = ts.createNotEmittedStatement(sourceFile);\r\n    ts.setOriginalNode(stmt, undefined);\r\n    ts.setTextRange(stmt, { pos: 0, end: 0 });\r\n    return stmt;\r\n}\r\n/**\r\n * Returns the leading comment ranges in the source file that start at the given position.\r\n * This is the same as `ts.getLeadingCommentRanges`, except that it does not skip\r\n * comments before the first newline in the range.\r\n *\r\n * @param sourceFile\r\n * @param start Where to start scanning\r\n * @param end Where to end scanning\r\n */\r\nfunction getAllLeadingCommentRanges(sourceFile, start, end) {\r\n    // exeute ts.getLeadingCommentRanges with pos = 0 so that it does not skip\r\n    // comments until the first newline.\r\n    var commentRanges = ts.getLeadingCommentRanges(sourceFile.text.substring(start, end), 0) || [];\r\n    return commentRanges.map(function (cr) { return ({\r\n        hasTrailingNewLine: cr.hasTrailingNewLine,\r\n        kind: cr.kind,\r\n        pos: cr.pos + start,\r\n        end: cr.end + start\r\n    }); });\r\n}\r\n/**\r\n * This is a version of `ts.updateSourceFileNode` that works\r\n * well with property decorators.\r\n * See https://github.com/Microsoft/TypeScript/issues/17384\r\n *\r\n * @param sf\r\n * @param statements\r\n */\r\nfunction updateSourceFileNode(sf, statements) {\r\n    if (statements === sf.statements) {\r\n        return sf;\r\n    }\r\n    // Note: Need to clone the original file (and not use `ts.updateSourceFileNode`)\r\n    // as otherwise TS fails when resolving types for decorators.\r\n    sf = ts.getMutableClone(sf);\r\n    sf.statements = statements;\r\n    return sf;\r\n}\r\nexports.updateSourceFileNode = updateSourceFileNode;\r\n/**\r\n * This is a version of `ts.visitEachChild` that does not visit children of types,\r\n * as this leads to errors in TypeScript < 2.4.0 and as types are not emitted anyways.\r\n */\r\nfunction visitEachChildIgnoringTypes(node, visitor, context) {\r\n    if (isTypeNodeKind(node.kind) || node.kind === ts.SyntaxKind.IndexSignature) {\r\n        return node;\r\n    }\r\n    return ts.visitEachChild(node, visitor, context);\r\n}\r\nexports.visitEachChildIgnoringTypes = visitEachChildIgnoringTypes;\r\n// Copied from TypeScript\r\nfunction isTypeNodeKind(kind) {\r\n    return (kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode) ||\r\n        kind === ts.SyntaxKind.AnyKeyword || kind === ts.SyntaxKind.NumberKeyword ||\r\n        kind === ts.SyntaxKind.ObjectKeyword || kind === ts.SyntaxKind.BooleanKeyword ||\r\n        kind === ts.SyntaxKind.StringKeyword || kind === ts.SyntaxKind.SymbolKeyword ||\r\n        kind === ts.SyntaxKind.ThisKeyword || kind === ts.SyntaxKind.VoidKeyword ||\r\n        kind === ts.SyntaxKind.UndefinedKeyword || kind === ts.SyntaxKind.NullKeyword ||\r\n        kind === ts.SyntaxKind.NeverKeyword || kind === ts.SyntaxKind.ExpressionWithTypeArguments;\r\n}\r\nexports.isTypeNodeKind = isTypeNodeKind;\r\n//# sourceMappingURL=transformer_util.js.map","sourceMap":{"version":3,"file":"transformer_util.js","sourceRoot":"","sources":["node_modules/tsickle/src/transformer_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport * as tsickle from './tsickle';\n\n/**\n * Adjusts the given CustomTransformers with additional transformers\n * to fix bugs in TypeScript.\n */\nexport function createCustomTransformers(given: ts.CustomTransformers): ts.CustomTransformers {\n  if (!given.after && !given.before) {\n    return given;\n  }\n  const before = given.before || [];\n  before.unshift(addFileContexts);\n  before.push(prepareNodesBeforeTypeScriptTransform);\n  const after = given.after || [];\n  after.unshift(emitMissingSyntheticCommentsAfterTypescriptTransform);\n  return {before, after};\n}\n\n/**\n * Transform that adds the FileContext to the TransformationContext.\n */\nfunction addFileContexts(context: ts.TransformationContext) {\n  return (sourceFile: ts.SourceFile) => {\n    (context as TransformationContext).fileContext = new FileContext(sourceFile);\n    return sourceFile;\n  };\n}\n\nfunction assertFileContext(context: TransformationContext, sourceFile: ts.SourceFile): FileContext {\n  if (!context.fileContext) {\n    throw new Error(\n        `Illegal State: FileContext not initialized. ` +\n        `Did you forget to add the \"firstTransform\" as first transformer? ` +\n        `File: ${sourceFile.fileName}`);\n  }\n  if (context.fileContext.file.fileName !== sourceFile.fileName) {\n    throw new Error(\n        `Illegal State: File of the FileContext does not match. File: ${sourceFile.fileName}`);\n  }\n  return context.fileContext;\n}\n\n/**\n * An extended version of the TransformationContext that stores the FileContext as well.\n */\ninterface TransformationContext extends ts.TransformationContext {\n  fileContext?: FileContext;\n}\n\n/**\n * A context that stores information per file to e.g. allow communication\n * between transformers.\n * There is one ts.TransformationContext per emit,\n * but files are handled sequentially by all transformers. Thefore we can\n * store file related information on a property on the ts.TransformationContext,\n * given that we reset it in the first transformer.\n */\nclass FileContext {\n  /**\n   * Stores the parent node for all processed nodes.\n   * This is needed for nodes from the parse tree that are used\n   * in a synthetic node as must not modify these, even though they\n   * have a new parent now.\n   */\n  syntheticNodeParents = new Map<ts.Node, ts.Node|undefined>();\n  importOrReexportDeclarations: Array<ts.ExportDeclaration|ts.ImportDeclaration> = [];\n  lastCommentEnd = -1;\n  constructor(public file: ts.SourceFile) {}\n}\n\n/**\n * Transform that needs to be executed right before TypeScript's transform.\n *\n * This prepares the node tree to workaround some bugs in the TypeScript emitter.\n */\nfunction prepareNodesBeforeTypeScriptTransform(context: ts.TransformationContext) {\n  return (sourceFile: ts.SourceFile) => {\n    const fileCtx = assertFileContext(context, sourceFile);\n\n    const nodePath: ts.Node[] = [];\n    visitNode(sourceFile);\n    return sourceFile;\n\n    function visitNode(node: ts.Node) {\n      const startNode = node;\n      const parent = nodePath[nodePath.length - 1];\n\n      if (node.flags & ts.NodeFlags.Synthesized) {\n        // Set `parent` for synthetic nodes as well,\n        // as otherwise the TS emit will crash for decorators.\n        // Note: don't update the `parent` of original nodes, as:\n        // 1) we don't want to change them at all\n        // 2) TS emit becomes errorneous in some cases if we add a synthetic parent.\n        // see https://github.com/Microsoft/TypeScript/issues/17384\n        node.parent = parent;\n      }\n      fileCtx.syntheticNodeParents.set(node, parent);\n\n      const originalNode = ts.getOriginalNode(node);\n      // Needed so that e.g. `module { ... }` prints the variable statement\n      // before the closure.\n      // See https://github.com/Microsoft/TypeScript/issues/17596\n      // tslint:disable-next-line:no-any as `symbol` is @internal in typescript.\n      (node as any).symbol = (originalNode as any).symbol;\n\n      if (originalNode && node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const originalEd = originalNode as ts.ExportDeclaration;\n        const ed = node as ts.ExportDeclaration;\n        if (!!originalEd.exportClause !== !!ed.exportClause) {\n          // Tsickle changes `export * ...` into named exports.\n          // In this case, don't set the original node for the ExportDeclaration\n          // as otherwise TypeScript does not emit the exports.\n          // See https://github.com/Microsoft/TypeScript/issues/17597\n          ts.setOriginalNode(node, undefined);\n        }\n      }\n\n      if (node.kind === ts.SyntaxKind.ImportDeclaration ||\n          node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const ied = node as ts.ImportDeclaration | ts.ExportDeclaration;\n        if (ied.moduleSpecifier) {\n          fileCtx.importOrReexportDeclarations.push(ied);\n        }\n      }\n\n      // recurse\n      nodePath.push(node);\n      node.forEachChild(visitNode);\n      nodePath.pop();\n    }\n  };\n}\n\n/**\n * Transform that needs to be executed after TypeScript's transform.\n *\n * This fixes places where the TypeScript transformer does not\n * emit synthetic comments.\n *\n * See https://github.com/Microsoft/TypeScript/issues/17594\n */\nfunction emitMissingSyntheticCommentsAfterTypescriptTransform(context: ts.TransformationContext) {\n  return (sourceFile: ts.SourceFile) => {\n    const fileContext = assertFileContext(context, sourceFile);\n    const nodePath: ts.Node[] = [];\n    visitNode(sourceFile);\n    (context as TransformationContext).fileContext = undefined;\n    return sourceFile;\n\n    function visitNode(node: ts.Node) {\n      if (node.kind === ts.SyntaxKind.Identifier) {\n        const parent1 = fileContext.syntheticNodeParents.get(node);\n        const parent2 = parent1 && fileContext.syntheticNodeParents.get(parent1);\n        const parent3 = parent2 && fileContext.syntheticNodeParents.get(parent2);\n\n        if (parent1 && parent1.kind === ts.SyntaxKind.PropertyDeclaration) {\n          // TypeScript ignores synthetic comments on (static) property declarations\n          // with initializers.\n          // find the parent ExpressionStatement like MyClass.foo = ...\n          const expressionStmt =\n              lastNodeWith(nodePath, (node) => node.kind === ts.SyntaxKind.ExpressionStatement);\n          if (expressionStmt) {\n            ts.setSyntheticLeadingComments(\n                expressionStmt, ts.getSyntheticLeadingComments(parent1) || []);\n          }\n        } else if (\n            parent3 && parent3.kind === ts.SyntaxKind.VariableStatement &&\n            tsickle.hasModifierFlag(parent3, ts.ModifierFlags.Export)) {\n          // TypeScript ignores synthetic comments on exported variables.\n          // find the parent ExpressionStatement like exports.foo = ...\n          const expressionStmt =\n              lastNodeWith(nodePath, (node) => node.kind === ts.SyntaxKind.ExpressionStatement);\n          if (expressionStmt) {\n            ts.setSyntheticLeadingComments(\n                expressionStmt, ts.getSyntheticLeadingComments(parent3) || []);\n          }\n        }\n      }\n      // TypeScript ignores synthetic comments on reexport / import statements.\n      const moduleName = extractModuleNameFromRequireVariableStatement(node);\n      if (moduleName && fileContext.importOrReexportDeclarations) {\n        // Locate the original import/export declaration via the\n        // text range.\n        const importOrReexportDeclaration =\n            fileContext.importOrReexportDeclarations.find(ied => ied.pos === node.pos);\n        if (importOrReexportDeclaration) {\n          ts.setSyntheticLeadingComments(\n              node, ts.getSyntheticLeadingComments(importOrReexportDeclaration) || []);\n        }\n        // Need to clear the textRange for ImportDeclaration / ExportDeclaration as\n        // otherwise TypeScript would emit the original comments even if we set the\n        // ts.EmitFlag.NoComments. (see also resetNodeTextRangeToPreventDuplicateComments below)\n        ts.setSourceMapRange(node, {pos: node.pos, end: node.end});\n        ts.setTextRange(node, {pos: -1, end: -1});\n      }\n      nodePath.push(node);\n      node.forEachChild(visitNode);\n      nodePath.pop();\n    }\n  };\n}\n\nfunction extractModuleNameFromRequireVariableStatement(node: ts.Node): string|null {\n  if (node.kind !== ts.SyntaxKind.VariableStatement) {\n    return null;\n  }\n  const varStmt = node as ts.VariableStatement;\n  const decls = varStmt.declarationList.declarations;\n  let init: ts.Expression|undefined;\n  if (decls.length !== 1 || !(init = decls[0].initializer) ||\n      init.kind !== ts.SyntaxKind.CallExpression) {\n    return null;\n  }\n  const callExpr = init as ts.CallExpression;\n  if (callExpr.expression.kind !== ts.SyntaxKind.Identifier ||\n      (callExpr.expression as ts.Identifier).text !== 'require' ||\n      callExpr.arguments.length !== 1) {\n    return null;\n  }\n  const moduleExpr = callExpr.arguments[0];\n  if (moduleExpr.kind !== ts.SyntaxKind.StringLiteral) {\n    return null;\n  }\n  return (moduleExpr as ts.StringLiteral).text;\n}\n\nfunction lastNodeWith(nodes: ts.Node[], predicate: (node: ts.Node) => boolean): ts.Node|null {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i];\n    if (predicate(node)) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Convert comment text ranges before and after a node\n * into ts.SynthesizedComments for the node and prevent the\n * comment text ranges to be emitted, to allow\n * changing these comments.\n *\n * This function takes a visitor to be able to do some\n * state management after the caller is done changing a node.\n */\nexport function visitNodeWithSynthesizedComments<T extends ts.Node>(\n    context: ts.TransformationContext, sourceFile: ts.SourceFile, node: T,\n    visitor: (node: T) => T): T {\n  if (node.flags & ts.NodeFlags.Synthesized) {\n    return visitor(node);\n  }\n  if (node.kind === ts.SyntaxKind.Block) {\n    const block = node as ts.Node as ts.Block;\n    node = visitNodeStatementsWithSynthesizedComments(\n        context, sourceFile, node, block.statements,\n        (node, stmts) => visitor(ts.updateBlock(block, stmts) as ts.Node as T));\n  } else if (node.kind === ts.SyntaxKind.SourceFile) {\n    node = visitNodeStatementsWithSynthesizedComments(\n        context, sourceFile, node, sourceFile.statements,\n        (node, stmts) => visitor(updateSourceFileNode(sourceFile, stmts) as ts.Node as T));\n  } else {\n    const fileContext = assertFileContext(context, sourceFile);\n    const leadingLastCommentEnd =\n        synthesizeLeadingComments(sourceFile, node, fileContext.lastCommentEnd);\n    const trailingLastCommentEnd = synthesizeTrailingComments(sourceFile, node);\n    if (leadingLastCommentEnd !== -1) {\n      fileContext.lastCommentEnd = leadingLastCommentEnd;\n    }\n    node = visitor(node);\n    if (trailingLastCommentEnd !== -1) {\n      fileContext.lastCommentEnd = trailingLastCommentEnd;\n    }\n  }\n  return resetNodeTextRangeToPreventDuplicateComments(node);\n}\n\n/**\n * Reset the text range for some special nodes as otherwise TypeScript\n * would always emit the original comments for them.\n * See https://github.com/Microsoft/TypeScript/issues/17594\n *\n * @param node\n */\nfunction resetNodeTextRangeToPreventDuplicateComments<T extends ts.Node>(node: T): T {\n  ts.setEmitFlags(node, (ts.getEmitFlags(node) || 0) | ts.EmitFlags.NoComments);\n  // See also addSyntheticCommentsAfterTsTransformer.\n  // Note: Don't reset the textRange for ts.ExportDeclaration / ts.ImportDeclaration\n  // until after the TypeScript transformer as we need the source location\n  // to map the generated `require` calls back to the original\n  // ts.ExportDeclaration / ts.ImportDeclaration nodes.\n  let allowTextRange = node.kind !== ts.SyntaxKind.ClassDeclaration &&\n      node.kind !== ts.SyntaxKind.VariableDeclaration &&\n      !(node.kind === ts.SyntaxKind.VariableStatement &&\n        tsickle.hasModifierFlag(node, ts.ModifierFlags.Export));\n  if (node.kind === ts.SyntaxKind.PropertyDeclaration) {\n    allowTextRange = false;\n    const pd = node as ts.Node as ts.PropertyDeclaration;\n    // TODO(tbosch): Using pd.initializer! as the typescript typings before 2.4.0\n    // are incorrect. Remove this once we upgrade to TypeScript 2.4.0.\n    node = ts.updateProperty(\n               pd, pd.decorators, pd.modifiers, resetTextRange(pd.name) as ts.PropertyName, pd.type,\n               pd.initializer!) as ts.Node as T;\n  }\n  if (!allowTextRange) {\n    node = resetTextRange(node);\n  }\n  return node;\n\n  function resetTextRange<T extends ts.Node>(node: T): T {\n    if (!(node.flags & ts.NodeFlags.Synthesized)) {\n      // need to clone as we don't want to modify source nodes,\n      // as the parsed SourceFiles could be cached!\n      node = ts.getMutableClone(node);\n    }\n    const textRange = {pos: node.pos, end: node.end};\n    ts.setSourceMapRange(node, textRange);\n    ts.setTextRange(node, {pos: -1, end: -1});\n    return node;\n  }\n}\n\n/**\n * Reads in the leading comment text ranges of the given node,\n * converts them into `ts.SyntheticComment`s and stores them on the node.\n *\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\n *\n * @param lastCommentEnd The end of the last comment\n * @return The end of the last found comment, -1 if no comment was found.\n */\nfunction synthesizeLeadingComments(\n    sourceFile: ts.SourceFile, node: ts.Node, lastCommentEnd: number): number {\n  const parent = node.parent;\n  const sharesStartWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&\n      parent.kind !== ts.SyntaxKind.SourceFile && parent.getFullStart() === node.getFullStart();\n  if (sharesStartWithParent || lastCommentEnd >= node.getStart()) {\n    return -1;\n  }\n  const adjustedNodeFullStart = Math.max(lastCommentEnd, node.getFullStart());\n  const leadingComments =\n      getAllLeadingCommentRanges(sourceFile, adjustedNodeFullStart, node.getStart());\n  if (leadingComments && leadingComments.length) {\n    ts.setSyntheticLeadingComments(node, synthesizeCommentRanges(sourceFile, leadingComments));\n    return node.getStart();\n  }\n  return -1;\n}\n\n/**\n * Reads in the trailing comment text ranges of the given node,\n * converts them into `ts.SyntheticComment`s and stores them on the node.\n *\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\n *\n * @return The end of the last found comment, -1 if no comment was found.\n */\nfunction synthesizeTrailingComments(sourceFile: ts.SourceFile, node: ts.Node): number {\n  const parent = node.parent;\n  const sharesEndWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&\n      parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();\n  if (sharesEndWithParent) {\n    return -1;\n  }\n  const trailingComments = ts.getTrailingCommentRanges(sourceFile.text, node.getEnd());\n  if (trailingComments && trailingComments.length) {\n    ts.setSyntheticTrailingComments(node, synthesizeCommentRanges(sourceFile, trailingComments));\n    return trailingComments[trailingComments.length - 1].end;\n  }\n  return -1;\n}\n\n/**\n * Convert leading/trailing detached comment ranges of statement arrays\n * (e.g. the statements of a ts.SourceFile or ts.Block) into\n * `ts.NonEmittedStatement`s with `ts.SynthesizedComment`s and\n * prepends / appends them to the given statement array.\n * This is needed to allow changing these comments.\n *\n * This function takes a visitor to be able to do some\n * state management after the caller is done changing a node.\n */\nfunction visitNodeStatementsWithSynthesizedComments<T extends ts.Node>(\n    context: ts.TransformationContext, sourceFile: ts.SourceFile, node: T,\n    statements: ts.NodeArray<ts.Statement>,\n    visitor: (node: T, statements: ts.NodeArray<ts.Statement>) => T): T {\n  const leading = synthesizeDetachedLeadingComments(sourceFile, node, statements);\n  const trailing = synthesizeDetachedTrailingComments(sourceFile, node, statements);\n  if (leading.commentStmt || trailing.commentStmt) {\n    statements = ts.setTextRange(ts.createNodeArray(statements), {pos: -1, end: -1});\n    if (leading.commentStmt) {\n      statements.unshift(leading.commentStmt);\n    }\n    if (trailing.commentStmt) {\n      statements.push(trailing.commentStmt);\n    }\n    const fileContext = assertFileContext(context, sourceFile);\n    if (leading.lastCommentEnd !== -1) {\n      fileContext.lastCommentEnd = leading.lastCommentEnd;\n    }\n    node = visitor(node, statements);\n    if (trailing.lastCommentEnd !== -1) {\n      fileContext.lastCommentEnd = trailing.lastCommentEnd;\n    }\n    return node;\n  }\n  return visitor(node, statements);\n}\n\n/**\n * Convert leading detached comment ranges of statement arrays\n * (e.g. the statements of a ts.SourceFile or ts.Block) into a\n * `ts.NonEmittedStatement` with `ts.SynthesizedComment`s.\n *\n * A Detached leading comment is the first comment in a SourceFile / Block\n * that is separated with a newline from the first statement.\n *\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\n */\nfunction synthesizeDetachedLeadingComments(\n    sourceFile: ts.SourceFile, node: ts.Node, statements: ts.NodeArray<ts.Statement>):\n    {commentStmt: ts.Statement|null, lastCommentEnd: number} {\n  let triviaEnd = statements.end;\n  if (statements.length) {\n    triviaEnd = statements[0].getStart();\n  }\n  const detachedComments = getDetachedLeadingCommentRanges(sourceFile, statements.pos, triviaEnd);\n  if (!detachedComments.length) {\n    return {commentStmt: null, lastCommentEnd: -1};\n  }\n  const lastCommentEnd = detachedComments[detachedComments.length - 1].end;\n  const commentStmt = createNotEmittedStatement(sourceFile);\n  ts.setEmitFlags(commentStmt, ts.EmitFlags.CustomPrologue);\n  ts.setSyntheticTrailingComments(\n      commentStmt, synthesizeCommentRanges(sourceFile, detachedComments));\n  return {commentStmt, lastCommentEnd};\n}\n\n/**\n * Convert trailing detached comment ranges of statement arrays\n * (e.g. the statements of a ts.SourceFile or ts.Block) into a\n * `ts.NonEmittedStatement` with `ts.SynthesizedComment`s.\n *\n * A Detached trailing comment are all comments after the first newline\n * the follows the last statement in a SourceFile / Block.\n *\n * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.\n */\nfunction synthesizeDetachedTrailingComments(\n    sourceFile: ts.SourceFile, node: ts.Node, statements: ts.NodeArray<ts.Statement>):\n    {commentStmt: ts.Statement|null, lastCommentEnd: number} {\n  let trailingCommentStart = statements.end;\n  if (statements.length) {\n    const lastStmt = statements[statements.length - 1];\n    const lastStmtTrailingComments = ts.getTrailingCommentRanges(sourceFile.text, lastStmt.end);\n    if (lastStmtTrailingComments && lastStmtTrailingComments.length) {\n      trailingCommentStart = lastStmtTrailingComments[lastStmtTrailingComments.length - 1].end;\n    }\n  }\n  const detachedComments = getAllLeadingCommentRanges(sourceFile, trailingCommentStart, node.end);\n  if (!detachedComments || !detachedComments.length) {\n    return {commentStmt: null, lastCommentEnd: -1};\n  }\n  const lastCommentEnd = detachedComments[detachedComments.length - 1].end;\n  const commentStmt = createNotEmittedStatement(sourceFile);\n  ts.setEmitFlags(commentStmt, ts.EmitFlags.CustomPrologue);\n  ts.setSyntheticLeadingComments(\n      commentStmt, synthesizeCommentRanges(sourceFile, detachedComments));\n  return {commentStmt, lastCommentEnd};\n}\n\n/**\n * Calculates the the detached leading comment ranges in an area of a SourceFile.\n * @param sourceFile The source file\n * @param start Where to start scanning\n * @param end Where to end scanning\n */\n// Note: This code is based on compiler/comments.ts in TypeScript\nfunction getDetachedLeadingCommentRanges(\n    sourceFile: ts.SourceFile, start: number, end: number): ts.CommentRange[] {\n  const leadingComments = getAllLeadingCommentRanges(sourceFile, start, end);\n  if (!leadingComments || !leadingComments.length) {\n    return [];\n  }\n  const detachedComments: ts.CommentRange[] = [];\n  let lastComment: ts.CommentRange|undefined = undefined;\n\n  for (const comment of leadingComments) {\n    if (lastComment) {\n      const lastCommentLine = getLineOfPos(sourceFile, lastComment.end);\n      const commentLine = getLineOfPos(sourceFile, comment.pos);\n\n      if (commentLine >= lastCommentLine + 2) {\n        // There was a blank line between the last comment and this comment.  This\n        // comment is not part of the copyright comments.  Return what we have so\n        // far.\n        break;\n      }\n    }\n\n    detachedComments.push(comment);\n    lastComment = comment;\n  }\n\n  if (detachedComments.length) {\n    // All comments look like they could have been part of the copyright header.  Make\n    // sure there is at least one blank line between it and the node.  If not, it's not\n    // a copyright header.\n    const lastCommentLine =\n        getLineOfPos(sourceFile, detachedComments[detachedComments.length - 1].end);\n    const nodeLine = getLineOfPos(sourceFile, end);\n    if (nodeLine >= lastCommentLine + 2) {\n      // Valid detachedComments\n      return detachedComments;\n    }\n  }\n  return [];\n}\n\nfunction getLineOfPos(sourceFile: ts.SourceFile, pos: number): number {\n  return ts.getLineAndCharacterOfPosition(sourceFile, pos).line;\n}\n\n/**\n * Converts `ts.CommentRange`s into `ts.SynthesizedComment`s\n * @param sourceFile\n * @param parsedComments\n */\nfunction synthesizeCommentRanges(\n    sourceFile: ts.SourceFile, parsedComments: ts.CommentRange[]): ts.SynthesizedComment[] {\n  const synthesizedComments: ts.SynthesizedComment[] = [];\n  parsedComments.forEach(({kind, pos, end, hasTrailingNewLine}, commentIdx) => {\n    let commentText = sourceFile.text.substring(pos, end).trim();\n    if (kind === ts.SyntaxKind.MultiLineCommentTrivia) {\n      commentText = commentText.replace(/(^\\/\\*)|(\\*\\/$)/g, '');\n    } else if (kind === ts.SyntaxKind.SingleLineCommentTrivia) {\n      if (commentText.startsWith('///')) {\n        // tripple-slash comments are typescript specific, ignore them in the output.\n        return;\n      }\n      commentText = commentText.replace(/(^\\/\\/)/g, '');\n    }\n    synthesizedComments.push({kind, text: commentText, hasTrailingNewLine, pos: -1, end: -1});\n  });\n  return synthesizedComments;\n}\n\n/**\n * Creates a non emitted statement that can be used to store synthesized comments.\n */\nfunction createNotEmittedStatement(sourceFile: ts.SourceFile) {\n  const stmt = ts.createNotEmittedStatement(sourceFile);\n  ts.setOriginalNode(stmt, undefined);\n  ts.setTextRange(stmt, {pos: 0, end: 0});\n  return stmt;\n}\n\n/**\n * Returns the leading comment ranges in the source file that start at the given position.\n * This is the same as `ts.getLeadingCommentRanges`, except that it does not skip\n * comments before the first newline in the range.\n *\n * @param sourceFile\n * @param start Where to start scanning\n * @param end Where to end scanning\n */\nfunction getAllLeadingCommentRanges(\n    sourceFile: ts.SourceFile, start: number, end: number): ts.CommentRange[] {\n  // exeute ts.getLeadingCommentRanges with pos = 0 so that it does not skip\n  // comments until the first newline.\n  const commentRanges = ts.getLeadingCommentRanges(sourceFile.text.substring(start, end), 0) || [];\n  return commentRanges.map(cr => ({\n                             hasTrailingNewLine: cr.hasTrailingNewLine,\n                             kind: cr.kind as number,\n                             pos: cr.pos + start,\n                             end: cr.end + start\n                           }));\n}\n\n/**\n * This is a version of `ts.updateSourceFileNode` that works\n * well with property decorators.\n * See https://github.com/Microsoft/TypeScript/issues/17384\n *\n * @param sf\n * @param statements\n */\nexport function updateSourceFileNode(\n    sf: ts.SourceFile, statements: ts.NodeArray<ts.Statement>): ts.SourceFile {\n  if (statements === sf.statements) {\n    return sf;\n  }\n  // Note: Need to clone the original file (and not use `ts.updateSourceFileNode`)\n  // as otherwise TS fails when resolving types for decorators.\n  sf = ts.getMutableClone(sf);\n  sf.statements = statements;\n  return sf;\n}\n\n/**\n * This is a version of `ts.visitEachChild` that does not visit children of types,\n * as this leads to errors in TypeScript < 2.4.0 and as types are not emitted anyways.\n */\nexport function visitEachChildIgnoringTypes<T extends ts.Node>(\n    node: T, visitor: ts.Visitor, context: ts.TransformationContext): T {\n  if (isTypeNodeKind(node.kind) || node.kind === ts.SyntaxKind.IndexSignature) {\n    return node;\n  }\n  return ts.visitEachChild(node, visitor, context);\n}\n\n// Copied from TypeScript\nexport function isTypeNodeKind(kind: ts.SyntaxKind) {\n  return (kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode) ||\n      kind === ts.SyntaxKind.AnyKeyword || kind === ts.SyntaxKind.NumberKeyword ||\n      kind === ts.SyntaxKind.ObjectKeyword || kind === ts.SyntaxKind.BooleanKeyword ||\n      kind === ts.SyntaxKind.StringKeyword || kind === ts.SyntaxKind.SymbolKeyword ||\n      kind === ts.SyntaxKind.ThisKeyword || kind === ts.SyntaxKind.VoidKeyword ||\n      kind === ts.SyntaxKind.UndefinedKeyword || kind === ts.SyntaxKind.NullKeyword ||\n      kind === ts.SyntaxKind.NeverKeyword || kind === ts.SyntaxKind.ExpressionWithTypeArguments;\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/tsickle.ts","node_modules/tsickle/src/decorator-annotator.ts","node_modules/tsickle/src/modules_manifest.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./tsickle","resolvedPath":"node_modules/tsickle/src/tsickle","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/transformer_util.ts","message":"Cannot find module 'typescript'.","line":9,"column":21},{"code":2354,"fileName":"node_modules/tsickle/src/transformer_util.ts","message":"This syntax requires an imported helper but module 'tslib' cannot be found.","line":540,"column":28}]},"hash":"a36037bd47127f565cf2d07007fd6f71cd597cac"}