{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\n/**\r\n * A list of all JSDoc tags allowed by the Closure compiler.\r\n * The public Closure docs don't list all the tags it allows; this list comes\r\n * from the compiler source itself.\r\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/Annotation.java\r\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/ParserConfig.properties\r\n */\r\nvar JSDOC_TAGS_WHITELIST = new Set([\r\n    'abstract', 'argument',\r\n    'author', 'consistentIdGenerator',\r\n    'const', 'constant',\r\n    'constructor', 'copyright',\r\n    'define', 'deprecated',\r\n    'desc', 'dict',\r\n    'disposes', 'enhance',\r\n    'enhanceable', 'enum',\r\n    'export', 'expose',\r\n    'extends', 'externs',\r\n    'fileoverview', 'final',\r\n    'hassoydelcall', 'hassoydeltemplate',\r\n    'hidden', 'id',\r\n    'idGenerator', 'ignore',\r\n    'implements', 'implicitCast',\r\n    'inheritDoc', 'interface',\r\n    'jaggerInject', 'jaggerModule',\r\n    'jaggerProvide', 'jaggerProvidePromise',\r\n    'lends', 'license',\r\n    'link', 'meaning',\r\n    'modifies', 'modName',\r\n    'mods', 'ngInject',\r\n    'noalias', 'nocollapse',\r\n    'nocompile', 'nosideeffects',\r\n    'override', 'owner',\r\n    'package', 'param',\r\n    'pintomodule', 'polymerBehavior',\r\n    'preserve', 'preserveTry',\r\n    'private', 'protected',\r\n    'public', 'record',\r\n    'requirecss', 'requires',\r\n    'return', 'returns',\r\n    'see', 'stableIdGenerator',\r\n    'struct', 'suppress',\r\n    'template', 'this',\r\n    'throws', 'type',\r\n    'typedef', 'unrestricted',\r\n    'version', 'wizaction',\r\n    'wizmodule',\r\n]);\r\n/**\r\n * A list of JSDoc @tags that are never allowed in TypeScript source. These are Closure tags that\r\n * can be expressed in the TypeScript surface syntax. As tsickle's emit will mangle type names,\r\n * these will cause Closure Compiler issues and should not be used.\r\n */\r\nvar JSDOC_TAGS_BLACKLIST = new Set([\r\n    'augments', 'class', 'constructs', 'constructor', 'enum', 'extends', 'field',\r\n    'function', 'implements', 'interface', 'lends', 'namespace', 'private', 'public',\r\n    'record', 'static', 'template', 'this', 'type', 'typedef',\r\n]);\r\n/**\r\n * A list of JSDoc @tags that might include a {type} after them. Only banned when a type is passed.\r\n * Note that this does not include tags that carry a non-type system type, e.g. \\@suppress.\r\n */\r\nvar JSDOC_TAGS_WITH_TYPES = new Set([\r\n    'const',\r\n    'export',\r\n    'param',\r\n    'return',\r\n]);\r\n/**\r\n * parse parses JSDoc out of a comment string.\r\n * Returns null if comment is not JSDoc.\r\n */\r\n// TODO(martinprobst): representing JSDoc as a list of tags is too simplistic. We need functionality\r\n// such as merging (below), de-duplicating certain tags (@deprecated), and special treatment for\r\n// others (e.g. @suppress). We should introduce a proper model class with a more suitable data\r\n// strucure (e.g. a Map<TagName, Values[]>).\r\nfunction parse(comment) {\r\n    // Make sure we have proper line endings before parsing on Windows.\r\n    comment = util_1.normalizeLineEndings(comment);\r\n    // TODO(evanm): this is a pile of hacky regexes for now, because we\r\n    // would rather use the better TypeScript implementation of JSDoc\r\n    // parsing.  https://github.com/Microsoft/TypeScript/issues/7393\r\n    var match = comment.match(/^\\/\\*\\*([\\s\\S]*?)\\*\\/$/);\r\n    if (!match)\r\n        return null;\r\n    comment = match[1].trim();\r\n    // Strip all the \" * \" bits from the front of each line.\r\n    comment = comment.replace(/^\\s*\\*? ?/gm, '');\r\n    var lines = comment.split('\\n');\r\n    var tags = [];\r\n    var warnings = [];\r\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\r\n        var line = lines_1[_i];\r\n        match = line.match(/^@(\\S+) *(.*)/);\r\n        if (match) {\r\n            var _ = match[0], tagName = match[1], text = match[2];\r\n            if (tagName === 'returns') {\r\n                // A synonym for 'return'.\r\n                tagName = 'return';\r\n            }\r\n            var type = void 0;\r\n            if (JSDOC_TAGS_BLACKLIST.has(tagName)) {\r\n                warnings.push(\"@\" + tagName + \" annotations are redundant with TypeScript equivalents\");\r\n                continue; // Drop the tag so Closure won't process it.\r\n            }\r\n            else if (JSDOC_TAGS_WITH_TYPES.has(tagName) && text[0] === '{') {\r\n                warnings.push(\"the type annotation on @\" + tagName + \" is redundant with its TypeScript type, \" +\r\n                    \"remove the {...} part\");\r\n                continue;\r\n            }\r\n            else if (tagName === 'suppress') {\r\n                var suppressMatch = text.match(/^\\{(.*)\\}(.*)$/);\r\n                if (!suppressMatch) {\r\n                    warnings.push(\"malformed @suppress tag: \\\"\" + text + \"\\\"\");\r\n                }\r\n                else {\r\n                    type = suppressMatch[1], text = suppressMatch[2];\r\n                }\r\n            }\r\n            else if (tagName === 'dict') {\r\n                warnings.push('use index signatures (`[k: string]: type`) instead of @dict');\r\n                continue;\r\n            }\r\n            // Grab the parameter name from @param tags.\r\n            var parameterName = void 0;\r\n            if (tagName === 'param') {\r\n                match = text.match(/^(\\S+) ?(.*)/);\r\n                if (match)\r\n                    _ = match[0], parameterName = match[1], text = match[2];\r\n            }\r\n            var tag = { tagName: tagName };\r\n            if (parameterName)\r\n                tag.parameterName = parameterName;\r\n            if (text)\r\n                tag.text = text;\r\n            if (type)\r\n                tag.type = type;\r\n            tags.push(tag);\r\n        }\r\n        else {\r\n            // Text without a preceding @tag on it is either the plain text\r\n            // documentation or a continuation of a previous tag.\r\n            if (tags.length === 0) {\r\n                tags.push({ tagName: '', text: line });\r\n            }\r\n            else {\r\n                var lastTag = tags[tags.length - 1];\r\n                lastTag.text = (lastTag.text || '') + '\\n' + line;\r\n            }\r\n        }\r\n    }\r\n    if (warnings.length > 0) {\r\n        return { tags: tags, warnings: warnings };\r\n    }\r\n    return { tags: tags };\r\n}\r\nexports.parse = parse;\r\n/**\r\n * Serializes a Tag into a string usable in a comment.\r\n * Returns a string like \" @foo {bar} baz\" (note the whitespace).\r\n */\r\nfunction tagToString(tag, escapeExtraTags) {\r\n    if (escapeExtraTags === void 0) { escapeExtraTags = new Set(); }\r\n    var out = '';\r\n    if (tag.tagName) {\r\n        if (!JSDOC_TAGS_WHITELIST.has(tag.tagName) || escapeExtraTags.has(tag.tagName)) {\r\n            // Escape tags we don't understand.  This is a subtle\r\n            // compromise between multiple issues.\r\n            // 1) If we pass through these non-Closure tags, the user will\r\n            //    get a warning from Closure, and the point of tsickle is\r\n            //    to insulate the user from Closure.\r\n            // 2) The output of tsickle is for Closure but also may be read\r\n            //    by humans, for example non-TypeScript users of Angular.\r\n            // 3) Finally, we don't want to warn because users should be\r\n            //    free to add whichever JSDoc they feel like.  If the user\r\n            //    wants help ensuring they didn't typo a tag, that is the\r\n            //    responsibility of a linter.\r\n            out += \" \\\\@\" + tag.tagName;\r\n        }\r\n        else {\r\n            out += \" @\" + tag.tagName;\r\n        }\r\n    }\r\n    if (tag.type) {\r\n        out += ' {';\r\n        if (tag.restParam) {\r\n            out += '...';\r\n        }\r\n        out += tag.type;\r\n        if (tag.optional) {\r\n            out += '=';\r\n        }\r\n        out += '}';\r\n    }\r\n    if (tag.parameterName) {\r\n        out += ' ' + tag.parameterName;\r\n    }\r\n    if (tag.text) {\r\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\r\n    }\r\n    return out;\r\n}\r\n/** Tags that must only occur onces in a comment (filtered below). */\r\nvar SINGLETON_TAGS = new Set(['deprecated']);\r\n/** Serializes a Comment out to a string usable in source code. */\r\nfunction toString(tags, escapeExtraTags) {\r\n    if (escapeExtraTags === void 0) { escapeExtraTags = new Set(); }\r\n    if (tags.length === 0)\r\n        return '';\r\n    if (tags.length === 1) {\r\n        var tag = tags[0];\r\n        if ((tag.tagName === 'type' || tag.tagName === 'nocollapse') &&\r\n            (!tag.text || !tag.text.match('\\n'))) {\r\n            // Special-case one-liner \"type\" and \"nocollapse\" tags to fit on one line, e.g.\r\n            //   /** @type {foo} */\r\n            return '/**' + tagToString(tag, escapeExtraTags) + ' */\\n';\r\n        }\r\n        // Otherwise, fall through to the multi-line output.\r\n    }\r\n    var out = '';\r\n    out += '/**\\n';\r\n    var emitted = new Set();\r\n    for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {\r\n        var tag = tags_1[_i];\r\n        if (emitted.has(tag.tagName) && SINGLETON_TAGS.has(tag.tagName)) {\r\n            continue;\r\n        }\r\n        emitted.add(tag.tagName);\r\n        out += ' *';\r\n        // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\r\n        out += tagToString(tag, escapeExtraTags).split('\\n').join('\\n * ');\r\n        out += '\\n';\r\n    }\r\n    out += ' */\\n';\r\n    return out;\r\n}\r\nexports.toString = toString;\r\n/** Merges multiple tags (of the same tagName type) into a single unified tag. */\r\nfunction merge(tags) {\r\n    var tagNames = new Set();\r\n    var parameterNames = new Set();\r\n    var types = new Set();\r\n    var texts = new Set();\r\n    // If any of the tags are optional/rest, then the merged output is optional/rest.\r\n    var optional = false;\r\n    var restParam = false;\r\n    for (var _i = 0, tags_2 = tags; _i < tags_2.length; _i++) {\r\n        var tag_1 = tags_2[_i];\r\n        if (tag_1.tagName)\r\n            tagNames.add(tag_1.tagName);\r\n        if (tag_1.parameterName)\r\n            parameterNames.add(tag_1.parameterName);\r\n        if (tag_1.type)\r\n            types.add(tag_1.type);\r\n        if (tag_1.text)\r\n            texts.add(tag_1.text);\r\n        if (tag_1.optional)\r\n            optional = true;\r\n        if (tag_1.restParam)\r\n            restParam = true;\r\n    }\r\n    if (tagNames.size !== 1) {\r\n        throw new Error(\"cannot merge differing tags: \" + JSON.stringify(tags));\r\n    }\r\n    var tagName = tagNames.values().next().value;\r\n    var parameterName = parameterNames.size > 0 ? Array.from(parameterNames).join('_or_') : undefined;\r\n    var type = types.size > 0 ? Array.from(types).join('|') : undefined;\r\n    var text = texts.size > 0 ? Array.from(texts).join(' / ') : undefined;\r\n    var tag = { tagName: tagName, parameterName: parameterName, type: type, text: text };\r\n    if (optional)\r\n        tag.optional = true;\r\n    if (restParam)\r\n        tag.restParam = true;\r\n    return tag;\r\n}\r\nexports.merge = merge;\r\n//# sourceMappingURL=jsdoc.js.map","sourceMap":{"version":3,"file":"jsdoc.js","sourceRoot":"","sources":["node_modules/tsickle/src/jsdoc.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {normalizeLineEndings} from './util';\n\n/**\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier.  See e.g. ts.JSDocTag and ts.JSDocComment.\n */\nexport interface Tag {\n  /**\n   * tagName is e.g. \"param\" in an @param declaration.  It is the empty string\n   * for the plain text documentation that occurs before any @foo lines.\n   */\n  tagName: string;\n  /**\n   * parameterName is the the name of the function parameter, e.g. \"foo\"\n   * in `\\@param foo The foo param`\n   */\n  parameterName?: string;\n  /**\n   * The type of a JSDoc \\@param, \\@type etc tag, rendered in curly braces.\n   * Can also hold the type of an \\@suppress.\n   */\n  type?: string;\n  /** optional is true for optional function parameters. */\n  optional?: boolean;\n  /** restParam is true for \"...x: foo[]\" function parameters. */\n  restParam?: boolean;\n  /**\n   * destructuring is true for destructuring bind parameters, which require\n   * non-null arguments on the Closure side.  Can likely remove this\n   * once TypeScript nullable types are available.\n   */\n  destructuring?: boolean;\n  /** Any remaining text on the tag, e.g. the description. */\n  text?: string;\n}\n\n/**\n * A list of all JSDoc tags allowed by the Closure compiler.\n * The public Closure docs don't list all the tags it allows; this list comes\n * from the compiler source itself.\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/Annotation.java\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/ParserConfig.properties\n */\nconst JSDOC_TAGS_WHITELIST = new Set([\n  'abstract',      'argument',\n  'author',        'consistentIdGenerator',\n  'const',         'constant',\n  'constructor',   'copyright',\n  'define',        'deprecated',\n  'desc',          'dict',\n  'disposes',      'enhance',\n  'enhanceable',   'enum',\n  'export',        'expose',\n  'extends',       'externs',\n  'fileoverview',  'final',\n  'hassoydelcall', 'hassoydeltemplate',\n  'hidden',        'id',\n  'idGenerator',   'ignore',\n  'implements',    'implicitCast',\n  'inheritDoc',    'interface',\n  'jaggerInject',  'jaggerModule',\n  'jaggerProvide', 'jaggerProvidePromise',\n  'lends',         'license',\n  'link',          'meaning',\n  'modifies',      'modName',\n  'mods',          'ngInject',\n  'noalias',       'nocollapse',\n  'nocompile',     'nosideeffects',\n  'override',      'owner',\n  'package',       'param',\n  'pintomodule',   'polymerBehavior',\n  'preserve',      'preserveTry',\n  'private',       'protected',\n  'public',        'record',\n  'requirecss',    'requires',\n  'return',        'returns',\n  'see',           'stableIdGenerator',\n  'struct',        'suppress',\n  'template',      'this',\n  'throws',        'type',\n  'typedef',       'unrestricted',\n  'version',       'wizaction',\n  'wizmodule',\n]);\n\n/**\n * A list of JSDoc @tags that are never allowed in TypeScript source. These are Closure tags that\n * can be expressed in the TypeScript surface syntax. As tsickle's emit will mangle type names,\n * these will cause Closure Compiler issues and should not be used.\n */\nconst JSDOC_TAGS_BLACKLIST = new Set([\n  'augments', 'class',      'constructs', 'constructor', 'enum',      'extends', 'field',\n  'function', 'implements', 'interface',  'lends',       'namespace', 'private', 'public',\n  'record',   'static',     'template',   'this',        'type',      'typedef',\n]);\n\n/**\n * A list of JSDoc @tags that might include a {type} after them. Only banned when a type is passed.\n * Note that this does not include tags that carry a non-type system type, e.g. \\@suppress.\n */\nconst JSDOC_TAGS_WITH_TYPES = new Set([\n  'const',\n  'export',\n  'param',\n  'return',\n]);\n\n/**\n * Result of parsing a JSDoc comment. Such comments essentially are built of a list of tags.\n * In addition to the tags, this might also contain warnings to indicate non-fatal problems\n * while finding the tags.\n */\nexport interface ParsedJSDocComment {\n  tags: Tag[];\n  warnings?: string[];\n}\n\n/**\n * parse parses JSDoc out of a comment string.\n * Returns null if comment is not JSDoc.\n */\n// TODO(martinprobst): representing JSDoc as a list of tags is too simplistic. We need functionality\n// such as merging (below), de-duplicating certain tags (@deprecated), and special treatment for\n// others (e.g. @suppress). We should introduce a proper model class with a more suitable data\n// strucure (e.g. a Map<TagName, Values[]>).\nexport function parse(comment: string): ParsedJSDocComment|null {\n  // Make sure we have proper line endings before parsing on Windows.\n  comment = normalizeLineEndings(comment);\n  // TODO(evanm): this is a pile of hacky regexes for now, because we\n  // would rather use the better TypeScript implementation of JSDoc\n  // parsing.  https://github.com/Microsoft/TypeScript/issues/7393\n  let match = comment.match(/^\\/\\*\\*([\\s\\S]*?)\\*\\/$/);\n  if (!match) return null;\n  comment = match[1].trim();\n  // Strip all the \" * \" bits from the front of each line.\n  comment = comment.replace(/^\\s*\\*? ?/gm, '');\n  const lines = comment.split('\\n');\n  const tags: Tag[] = [];\n  const warnings: string[] = [];\n  for (const line of lines) {\n    match = line.match(/^@(\\S+) *(.*)/);\n    if (match) {\n      let [_, tagName, text] = match;\n      if (tagName === 'returns') {\n        // A synonym for 'return'.\n        tagName = 'return';\n      }\n      let type: string|undefined;\n      if (JSDOC_TAGS_BLACKLIST.has(tagName)) {\n        warnings.push(`@${tagName} annotations are redundant with TypeScript equivalents`);\n        continue;  // Drop the tag so Closure won't process it.\n      } else if (JSDOC_TAGS_WITH_TYPES.has(tagName) && text[0] === '{') {\n        warnings.push(\n            `the type annotation on @${tagName} is redundant with its TypeScript type, ` +\n            `remove the {...} part`);\n        continue;\n      } else if (tagName === 'suppress') {\n        const suppressMatch = text.match(/^\\{(.*)\\}(.*)$/);\n        if (!suppressMatch) {\n          warnings.push(`malformed @suppress tag: \"${text}\"`);\n        } else {\n          [, type, text] = suppressMatch;\n        }\n      } else if (tagName === 'dict') {\n        warnings.push('use index signatures (`[k: string]: type`) instead of @dict');\n        continue;\n      }\n\n      // Grab the parameter name from @param tags.\n      let parameterName: string|undefined;\n      if (tagName === 'param') {\n        match = text.match(/^(\\S+) ?(.*)/);\n        if (match) [_, parameterName, text] = match;\n      }\n\n      const tag: Tag = {tagName};\n      if (parameterName) tag.parameterName = parameterName;\n      if (text) tag.text = text;\n      if (type) tag.type = type;\n      tags.push(tag);\n    } else {\n      // Text without a preceding @tag on it is either the plain text\n      // documentation or a continuation of a previous tag.\n      if (tags.length === 0) {\n        tags.push({tagName: '', text: line});\n      } else {\n        const lastTag = tags[tags.length - 1];\n        lastTag.text = (lastTag.text || '') + '\\n' + line;\n      }\n    }\n  }\n  if (warnings.length > 0) {\n    return {tags, warnings};\n  }\n  return {tags};\n}\n\n/**\n * Serializes a Tag into a string usable in a comment.\n * Returns a string like \" @foo {bar} baz\" (note the whitespace).\n */\nfunction tagToString(tag: Tag, escapeExtraTags = new Set<string>()): string {\n  let out = '';\n  if (tag.tagName) {\n    if (!JSDOC_TAGS_WHITELIST.has(tag.tagName) || escapeExtraTags.has(tag.tagName)) {\n      // Escape tags we don't understand.  This is a subtle\n      // compromise between multiple issues.\n      // 1) If we pass through these non-Closure tags, the user will\n      //    get a warning from Closure, and the point of tsickle is\n      //    to insulate the user from Closure.\n      // 2) The output of tsickle is for Closure but also may be read\n      //    by humans, for example non-TypeScript users of Angular.\n      // 3) Finally, we don't want to warn because users should be\n      //    free to add whichever JSDoc they feel like.  If the user\n      //    wants help ensuring they didn't typo a tag, that is the\n      //    responsibility of a linter.\n      out += ` \\\\@${tag.tagName}`;\n    } else {\n      out += ` @${tag.tagName}`;\n    }\n  }\n  if (tag.type) {\n    out += ' {';\n    if (tag.restParam) {\n      out += '...';\n    }\n    out += tag.type;\n    if (tag.optional) {\n      out += '=';\n    }\n    out += '}';\n  }\n  if (tag.parameterName) {\n    out += ' ' + tag.parameterName;\n  }\n  if (tag.text) {\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\n/** Tags that must only occur onces in a comment (filtered below). */\nconst SINGLETON_TAGS = new Set(['deprecated']);\n\n/** Serializes a Comment out to a string usable in source code. */\nexport function toString(tags: Tag[], escapeExtraTags = new Set<string>()): string {\n  if (tags.length === 0) return '';\n  if (tags.length === 1) {\n    const tag = tags[0];\n    if ((tag.tagName === 'type' || tag.tagName === 'nocollapse') &&\n        (!tag.text || !tag.text.match('\\n'))) {\n      // Special-case one-liner \"type\" and \"nocollapse\" tags to fit on one line, e.g.\n      //   /** @type {foo} */\n      return '/**' + tagToString(tag, escapeExtraTags) + ' */\\n';\n    }\n    // Otherwise, fall through to the multi-line output.\n  }\n\n  let out = '';\n  out += '/**\\n';\n  const emitted = new Set<string>();\n  for (const tag of tags) {\n    if (emitted.has(tag.tagName) && SINGLETON_TAGS.has(tag.tagName)) {\n      continue;\n    }\n    emitted.add(tag.tagName);\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\n    out += tagToString(tag, escapeExtraTags).split('\\n').join('\\n * ');\n    out += '\\n';\n  }\n  out += ' */\\n';\n  return out;\n}\n\n/** Merges multiple tags (of the same tagName type) into a single unified tag. */\nexport function merge(tags: Tag[]): Tag {\n  const tagNames = new Set<string>();\n  const parameterNames = new Set<string>();\n  const types = new Set<string>();\n  const texts = new Set<string>();\n  // If any of the tags are optional/rest, then the merged output is optional/rest.\n  let optional = false;\n  let restParam = false;\n  for (const tag of tags) {\n    if (tag.tagName) tagNames.add(tag.tagName);\n    if (tag.parameterName) parameterNames.add(tag.parameterName);\n    if (tag.type) types.add(tag.type);\n    if (tag.text) texts.add(tag.text);\n    if (tag.optional) optional = true;\n    if (tag.restParam) restParam = true;\n  }\n\n  if (tagNames.size !== 1) {\n    throw new Error(`cannot merge differing tags: ${JSON.stringify(tags)}`);\n  }\n  const tagName = tagNames.values().next().value;\n  const parameterName =\n      parameterNames.size > 0 ? Array.from(parameterNames).join('_or_') : undefined;\n  const type = types.size > 0 ? Array.from(types).join('|') : undefined;\n  const text = texts.size > 0 ? Array.from(texts).join(' / ') : undefined;\n  const tag: Tag = {tagName, parameterName, type, text};\n  if (optional) tag.optional = true;\n  if (restParam) tag.restParam = true;\n  return tag;\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/util.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./util","resolvedPath":"node_modules/tsickle/src/util","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[]},"hash":"5fb9178de2641e094d1e1a1253939d17ed9f7c7e"}