{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar ts = require(\"typescript\");\r\nvar decorators_1 = require(\"./decorators\");\r\nvar rewriter_1 = require(\"./rewriter\");\r\nvar type_translator_1 = require(\"./type-translator\");\r\nvar util_1 = require(\"./util\");\r\n// DecoratorClassVisitor rewrites a single \"class Foo {...}\" declaration.\r\n// It's its own object because we collect decorators on the class and the ctor\r\n// separately for each class we encounter.\r\nvar DecoratorClassVisitor = /** @class */ (function () {\r\n    function DecoratorClassVisitor(typeChecker, rewriter, classDecl, importedNames) {\r\n        this.typeChecker = typeChecker;\r\n        this.rewriter = rewriter;\r\n        this.classDecl = classDecl;\r\n        this.importedNames = importedNames;\r\n        if (classDecl.decorators) {\r\n            var toLower = this.decoratorsToLower(classDecl);\r\n            if (toLower.length > 0)\r\n                this.decorators = toLower;\r\n        }\r\n    }\r\n    /**\r\n     * Determines whether the given decorator should be re-written as an annotation.\r\n     */\r\n    DecoratorClassVisitor.prototype.shouldLower = function (decorator) {\r\n        for (var _i = 0, _a = decorators_1.getDecoratorDeclarations(decorator, this.typeChecker); _i < _a.length; _i++) {\r\n            var d = _a[_i];\r\n            // Switch to the TS JSDoc parser in the future to avoid false positives here.\r\n            // For example using '@Annotation' in a true comment.\r\n            // However, a new TS API would be needed, track at\r\n            // https://github.com/Microsoft/TypeScript/issues/7393.\r\n            var commentNode = d;\r\n            // Not handling PropertyAccess expressions here, because they are\r\n            // filtered earlier.\r\n            if (commentNode.kind === ts.SyntaxKind.VariableDeclaration) {\r\n                if (!commentNode.parent)\r\n                    continue;\r\n                commentNode = commentNode.parent;\r\n            }\r\n            // Go up one more level to VariableDeclarationStatement, where usually\r\n            // the comment lives. If the declaration has an 'export', the\r\n            // VDList.getFullText will not contain the comment.\r\n            if (commentNode.kind === ts.SyntaxKind.VariableDeclarationList) {\r\n                if (!commentNode.parent)\r\n                    continue;\r\n                commentNode = commentNode.parent;\r\n            }\r\n            var range = ts.getLeadingCommentRanges(commentNode.getFullText(), 0);\r\n            if (!range)\r\n                continue;\r\n            for (var _b = 0, range_1 = range; _b < range_1.length; _b++) {\r\n                var _c = range_1[_b], pos = _c.pos, end = _c.end;\r\n                var jsDocText = commentNode.getFullText().substring(pos, end);\r\n                if (jsDocText.includes('@Annotation'))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    DecoratorClassVisitor.prototype.decoratorsToLower = function (n) {\r\n        var _this = this;\r\n        if (n.decorators) {\r\n            return n.decorators.filter(function (d) { return _this.shouldLower(d); });\r\n        }\r\n        return [];\r\n    };\r\n    /**\r\n     * gatherConstructor grabs the parameter list and decorators off the class\r\n     * constructor, and emits nothing.\r\n     */\r\n    DecoratorClassVisitor.prototype.gatherConstructor = function (ctor) {\r\n        var ctorParameters = [];\r\n        var hasDecoratedParam = false;\r\n        for (var _i = 0, _a = ctor.parameters; _i < _a.length; _i++) {\r\n            var param = _a[_i];\r\n            var ctorParam = { type: null, decorators: null };\r\n            if (param.decorators) {\r\n                ctorParam.decorators = this.decoratorsToLower(param);\r\n                hasDecoratedParam = hasDecoratedParam || ctorParam.decorators.length > 0;\r\n            }\r\n            if (param.type) {\r\n                // param has a type provided, e.g. \"foo: Bar\".\r\n                // Verify that \"Bar\" is a value (e.g. a constructor) and not just a type.\r\n                var sym = this.typeChecker.getTypeAtLocation(param.type).getSymbol();\r\n                if (sym && (sym.flags & ts.SymbolFlags.Value)) {\r\n                    ctorParam.type = param.type;\r\n                }\r\n            }\r\n            ctorParameters.push(ctorParam);\r\n        }\r\n        // Use the ctor parameter metadata only if the class or the ctor was decorated.\r\n        if (this.decorators || hasDecoratedParam) {\r\n            this.ctorParameters = ctorParameters;\r\n        }\r\n    };\r\n    /**\r\n     * gatherMethod grabs the decorators off a class method and emits nothing.\r\n     */\r\n    DecoratorClassVisitor.prototype.gatherMethodOrProperty = function (method) {\r\n        if (!method.decorators)\r\n            return;\r\n        if (!method.name || method.name.kind !== ts.SyntaxKind.Identifier) {\r\n            // Method has a weird name, e.g.\r\n            //   [Symbol.foo]() {...}\r\n            this.rewriter.error(method, 'cannot process decorators on strangely named method');\r\n            return;\r\n        }\r\n        var name = method.name.text;\r\n        var decorators = this.decoratorsToLower(method);\r\n        if (decorators.length === 0)\r\n            return;\r\n        if (!this.propDecorators)\r\n            this.propDecorators = new Map();\r\n        this.propDecorators.set(name, decorators);\r\n    };\r\n    /**\r\n     * For lowering decorators, we need to refer to constructor types.\r\n     * So we start with the identifiers that represent these types.\r\n     * However, TypeScript does not allow us to emit them in a value position\r\n     * as it associated different symbol information with it.\r\n     *\r\n     * This method looks for the place where the value that is associated to\r\n     * the type is defined and returns that identifier instead.\r\n     *\r\n     * This might be simplified when https://github.com/Microsoft/TypeScript/issues/17516 is solved.\r\n     */\r\n    DecoratorClassVisitor.prototype.getValueIdentifierForType = function (typeSymbol, typeNode) {\r\n        var valueDeclaration = typeSymbol.valueDeclaration;\r\n        if (!valueDeclaration)\r\n            return null;\r\n        var valueName = valueDeclaration.name;\r\n        if (!valueName || valueName.kind !== ts.SyntaxKind.Identifier) {\r\n            return null;\r\n        }\r\n        if (valueName.getSourceFile() === this.rewriter.file) {\r\n            return valueName;\r\n        }\r\n        // Need to look at the first identifier only\r\n        // to ignore generics.\r\n        var firstIdentifierInType = firstIdentifierInSubtree(typeNode);\r\n        if (firstIdentifierInType) {\r\n            for (var _i = 0, _a = this.importedNames; _i < _a.length; _i++) {\r\n                var _b = _a[_i], name_1 = _b.name, declarationNames = _b.declarationNames;\r\n                if (firstIdentifierInType.text === name_1.text &&\r\n                    declarationNames.some(function (d) { return d === valueName; })) {\r\n                    return name_1;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    DecoratorClassVisitor.prototype.beforeProcessNode = function (node) {\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.Constructor:\r\n                this.gatherConstructor(node);\r\n                break;\r\n            case ts.SyntaxKind.PropertyDeclaration:\r\n            case ts.SyntaxKind.SetAccessor:\r\n            case ts.SyntaxKind.GetAccessor:\r\n            case ts.SyntaxKind.MethodDeclaration:\r\n                this.gatherMethodOrProperty(node);\r\n                break;\r\n            default:\r\n        }\r\n    };\r\n    DecoratorClassVisitor.prototype.maybeProcessDecorator = function (node, start) {\r\n        if (this.shouldLower(node)) {\r\n            // Return true to signal that this node should not be emitted,\r\n            // but still emit the whitespace *before* the node.\r\n            if (!start) {\r\n                start = node.getFullStart();\r\n            }\r\n            this.rewriter.writeRange(node, start, node.getStart());\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    DecoratorClassVisitor.prototype.foundDecorators = function () {\r\n        return !!(this.decorators || this.ctorParameters || this.propDecorators);\r\n    };\r\n    /**\r\n     * emits the types for the various gathered metadata to be used\r\n     * in the tsickle type annotations helper.\r\n     */\r\n    DecoratorClassVisitor.prototype.emitMetadataTypeAnnotationsHelpers = function () {\r\n        if (!this.classDecl.name)\r\n            return;\r\n        var className = rewriter_1.getIdentifierText(this.classDecl.name);\r\n        if (this.decorators) {\r\n            this.rewriter.emit(\"/** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */\\n\");\r\n            this.rewriter.emit(className + \".decorators;\\n\");\r\n        }\r\n        if (this.decorators || this.ctorParameters) {\r\n            this.rewriter.emit(\"/**\\n\");\r\n            this.rewriter.emit(\" * @nocollapse\\n\");\r\n            this.rewriter.emit(\" * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}\\n\");\r\n            this.rewriter.emit(\" */\\n\");\r\n            this.rewriter.emit(className + \".ctorParameters;\\n\");\r\n        }\r\n        if (this.propDecorators) {\r\n            this.rewriter.emit(\"/** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */\\n\");\r\n            this.rewriter.emit(className + \".propDecorators;\\n\");\r\n        }\r\n    };\r\n    /**\r\n     * emitMetadata emits the various gathered metadata, as static fields.\r\n     */\r\n    DecoratorClassVisitor.prototype.emitMetadataAsStaticProperties = function () {\r\n        var decoratorInvocations = '{type: Function, args?: any[]}[]';\r\n        if (this.decorators) {\r\n            this.rewriter.emit(\"static decorators: \" + decoratorInvocations + \" = [\\n\");\r\n            for (var _i = 0, _a = this.decorators; _i < _a.length; _i++) {\r\n                var annotation = _a[_i];\r\n                this.emitDecorator(annotation);\r\n                this.rewriter.emit(',\\n');\r\n            }\r\n            this.rewriter.emit('];\\n');\r\n        }\r\n        if (this.decorators || this.ctorParameters) {\r\n            this.rewriter.emit(\"/** @nocollapse */\\n\");\r\n            // ctorParameters may contain forward references in the type: field, so wrap in a function\r\n            // closure\r\n            this.rewriter.emit(\"static ctorParameters: () => ({type: any, decorators?: \" + decoratorInvocations +\r\n                \"}|null)[] = () => [\\n\");\r\n            for (var _b = 0, _c = this.ctorParameters || []; _b < _c.length; _b++) {\r\n                var param = _c[_b];\r\n                if (!param.type && !param.decorators) {\r\n                    this.rewriter.emit('null,\\n');\r\n                    continue;\r\n                }\r\n                this.rewriter.emit(\"{type: \");\r\n                if (!param.type) {\r\n                    this.rewriter.emit(\"undefined\");\r\n                }\r\n                else {\r\n                    // For transformer mode, tsickle must emit not only the string referring to the type,\r\n                    // but also create a source mapping, so that TypeScript can later recognize that the\r\n                    // symbol is used in a value position, so that TypeScript emits an import for the\r\n                    // symbol.\r\n                    // The code below and in getValueIdentifierForType finds the value node corresponding to\r\n                    // the type and emits that symbol if possible. This causes a source mapping to the value,\r\n                    // which then allows later transformers in the pipeline to do the correct module\r\n                    // rewriting. Note that we cannot use param.type as the emit node directly (not even just\r\n                    // for mapping), because that is marked as a type use of the node, not a value use, so it\r\n                    // doesn't get updated as an export.\r\n                    var sym = this.typeChecker.getTypeAtLocation(param.type).getSymbol();\r\n                    var emitNode = this.getValueIdentifierForType(sym, param.type);\r\n                    if (emitNode) {\r\n                        this.rewriter.writeRange(emitNode, emitNode.getStart(), emitNode.getEnd());\r\n                    }\r\n                    else {\r\n                        var typeStr = new type_translator_1.TypeTranslator(this.typeChecker, param.type)\r\n                            .symbolToString(sym, /* useFqn */ true);\r\n                        this.rewriter.emit(typeStr);\r\n                    }\r\n                }\r\n                this.rewriter.emit(\", \");\r\n                if (param.decorators) {\r\n                    this.rewriter.emit('decorators: [');\r\n                    for (var _d = 0, _e = param.decorators; _d < _e.length; _d++) {\r\n                        var decorator = _e[_d];\r\n                        this.emitDecorator(decorator);\r\n                        this.rewriter.emit(', ');\r\n                    }\r\n                    this.rewriter.emit(']');\r\n                }\r\n                this.rewriter.emit('},\\n');\r\n            }\r\n            this.rewriter.emit(\"];\\n\");\r\n        }\r\n        if (this.propDecorators) {\r\n            this.rewriter.emit(\"static propDecorators: {[key: string]: \" + decoratorInvocations + \"} = {\\n\");\r\n            for (var _f = 0, _g = util_1.toArray(this.propDecorators.keys()); _f < _g.length; _f++) {\r\n                var name_2 = _g[_f];\r\n                this.rewriter.emit(\"\\\"\" + name_2 + \"\\\": [\");\r\n                for (var _h = 0, _j = this.propDecorators.get(name_2); _h < _j.length; _h++) {\r\n                    var decorator = _j[_h];\r\n                    this.emitDecorator(decorator);\r\n                    this.rewriter.emit(',');\r\n                }\r\n                this.rewriter.emit('],\\n');\r\n            }\r\n            this.rewriter.emit('};\\n');\r\n        }\r\n    };\r\n    DecoratorClassVisitor.prototype.emitDecorator = function (decorator) {\r\n        this.rewriter.emit('{ type: ');\r\n        var expr = decorator.expression;\r\n        switch (expr.kind) {\r\n            case ts.SyntaxKind.Identifier:\r\n                // The decorator was a plain @Foo.\r\n                this.rewriter.visit(expr);\r\n                break;\r\n            case ts.SyntaxKind.CallExpression:\r\n                // The decorator was a call, like @Foo(bar).\r\n                var call = expr;\r\n                this.rewriter.visit(call.expression);\r\n                if (call.arguments.length) {\r\n                    this.rewriter.emit(', args: [');\r\n                    for (var _i = 0, _a = call.arguments; _i < _a.length; _i++) {\r\n                        var arg = _a[_i];\r\n                        this.rewriter.writeNodeFrom(arg, arg.getStart());\r\n                        this.rewriter.emit(', ');\r\n                    }\r\n                    this.rewriter.emit(']');\r\n                }\r\n                break;\r\n            default:\r\n                this.rewriter.errorUnimplementedKind(expr, 'gathering metadata');\r\n                this.rewriter.emit('undefined');\r\n        }\r\n        this.rewriter.emit(' }');\r\n    };\r\n    return DecoratorClassVisitor;\r\n}());\r\nexports.DecoratorClassVisitor = DecoratorClassVisitor;\r\nvar DecoratorRewriter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DecoratorRewriter, _super);\r\n    function DecoratorRewriter(typeChecker, sourceFile, sourceMapper) {\r\n        var _this = _super.call(this, sourceFile, sourceMapper) || this;\r\n        _this.typeChecker = typeChecker;\r\n        _this.importedNames = [];\r\n        return _this;\r\n    }\r\n    DecoratorRewriter.prototype.process = function () {\r\n        this.visit(this.file);\r\n        return this.getOutput();\r\n    };\r\n    DecoratorRewriter.prototype.maybeProcess = function (node) {\r\n        if (this.currentDecoratorConverter) {\r\n            this.currentDecoratorConverter.beforeProcessNode(node);\r\n        }\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.ImportDeclaration:\r\n                (_a = this.importedNames).push.apply(_a, collectImportedNames(this.typeChecker, node));\r\n                return false;\r\n            case ts.SyntaxKind.Decorator:\r\n                return this.currentDecoratorConverter &&\r\n                    this.currentDecoratorConverter.maybeProcessDecorator(node);\r\n            case ts.SyntaxKind.ClassDeclaration:\r\n                var oldDecoratorConverter = this.currentDecoratorConverter;\r\n                this.currentDecoratorConverter = new DecoratorClassVisitor(this.typeChecker, this, node, this.importedNames);\r\n                this.writeLeadingTrivia(node);\r\n                visitClassContentIncludingDecorators(node, this, this.currentDecoratorConverter);\r\n                this.currentDecoratorConverter = oldDecoratorConverter;\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n        var _a;\r\n    };\r\n    return DecoratorRewriter;\r\n}(rewriter_1.Rewriter));\r\n/**\r\n * Returns the first identifier in the node tree starting at node\r\n * in a depth first order.\r\n *\r\n * @param node The node to start with\r\n * @return The first identifier if one was found.\r\n */\r\nfunction firstIdentifierInSubtree(node) {\r\n    if (node.kind === ts.SyntaxKind.Identifier) {\r\n        return node;\r\n    }\r\n    return ts.forEachChild(node, firstIdentifierInSubtree);\r\n}\r\n/**\r\n * Collect the Identifiers used as named bindings in the given import declaration\r\n * with their Symbol.\r\n * This is needed later on to find an identifier that represents the value\r\n * of an imported type identifier.\r\n */\r\nfunction collectImportedNames(typeChecker, decl) {\r\n    var importedNames = [];\r\n    var importClause = decl.importClause;\r\n    if (!importClause) {\r\n        return importedNames;\r\n    }\r\n    var names = [];\r\n    if (importClause.name) {\r\n        names.push(importClause.name);\r\n    }\r\n    if (importClause.namedBindings &&\r\n        importClause.namedBindings.kind === ts.SyntaxKind.NamedImports) {\r\n        var namedImports = importClause.namedBindings;\r\n        names.push.apply(names, namedImports.elements.map(function (e) { return e.name; }));\r\n    }\r\n    for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {\r\n        var name_3 = names_1[_i];\r\n        var symbol = typeChecker.getSymbolAtLocation(name_3);\r\n        if (symbol.flags & ts.SymbolFlags.Alias) {\r\n            symbol = typeChecker.getAliasedSymbol(symbol);\r\n        }\r\n        var declarationNames = [];\r\n        if (symbol.declarations) {\r\n            for (var _a = 0, _b = symbol.declarations; _a < _b.length; _a++) {\r\n                var d = _b[_a];\r\n                var decl_1 = d;\r\n                if (decl_1.name && decl_1.name.kind === ts.SyntaxKind.Identifier) {\r\n                    declarationNames.push(decl_1.name);\r\n                }\r\n            }\r\n        }\r\n        if (symbol.declarations) {\r\n            importedNames.push({ name: name_3, declarationNames: declarationNames });\r\n        }\r\n    }\r\n    return importedNames;\r\n}\r\nexports.collectImportedNames = collectImportedNames;\r\nfunction visitClassContentIncludingDecorators(classDecl, rewriter, decoratorVisitor) {\r\n    if (rewriter.file.text[classDecl.getEnd() - 1] !== '}') {\r\n        rewriter.error(classDecl, 'unexpected class terminator');\r\n        return;\r\n    }\r\n    rewriter.writeNodeFrom(classDecl, classDecl.getStart(), classDecl.getEnd() - 1);\r\n    // At this point, we've emitted up through the final child of the class, so all that\r\n    // remains is the trailing whitespace and closing curly brace.\r\n    // The final character owned by the class node should always be a '}',\r\n    // or we somehow got the AST wrong and should report an error.\r\n    // (Any whitespace or semicolon following the '}' will be part of the next Node.)\r\n    if (decoratorVisitor) {\r\n        decoratorVisitor.emitMetadataAsStaticProperties();\r\n    }\r\n    rewriter.writeRange(classDecl, classDecl.getEnd() - 1, classDecl.getEnd());\r\n}\r\nexports.visitClassContentIncludingDecorators = visitClassContentIncludingDecorators;\r\nfunction convertDecorators(typeChecker, sourceFile, sourceMapper) {\r\n    return new DecoratorRewriter(typeChecker, sourceFile, sourceMapper).process();\r\n}\r\nexports.convertDecorators = convertDecorators;\r\n//# sourceMappingURL=decorator-annotator.js.map","sourceMap":{"version":3,"file":"decorator-annotator.js","sourceRoot":"","sources":["node_modules/tsickle/src/decorator-annotator.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;AAGH,+BAAiC;AAEjC,2CAAsD;AACtD,uCAAuD;AAEvD,qDAAiD;AACjD,+BAA+B;AAgB/B,yEAAyE;AACzE,8EAA8E;AAC9E,0CAA0C;AAC1C;IAQE,+BACY,WAA2B,EAAU,QAAkB,EACvD,SAA8B,EAC9B,aAA8E;QAF9E,gBAAW,GAAX,WAAW,CAAgB;QAAU,aAAQ,GAAR,QAAQ,CAAU;QACvD,cAAS,GAAT,SAAS,CAAqB;QAC9B,kBAAa,GAAb,aAAa,CAAiE;QACxF,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;YACzB,IAAM,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;YAClD,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;gBAAC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;QACpD,CAAC;IACH,CAAC;IAED;;OAEG;IACK,2CAAW,GAAnB,UAAoB,SAAuB;QACzC,GAAG,CAAC,CAAY,UAAqD,EAArD,KAAA,qCAAwB,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,EAArD,cAAqD,EAArD,IAAqD;YAAhE,IAAM,CAAC,SAAA;YACV,6EAA6E;YAC7E,qDAAqD;YACrD,kDAAkD;YAClD,uDAAuD;YACvD,IAAI,WAAW,GAAY,CAAC,CAAC;YAC7B,iEAAiE;YACjE,oBAAoB;YACpB,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,CAAC;gBAC3D,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC;oBAAC,QAAQ,CAAC;gBAClC,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC;YACnC,CAAC;YACD,sEAAsE;YACtE,6DAA6D;YAC7D,mDAAmD;YACnD,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,uBAAuB,CAAC,CAAC,CAAC;gBAC/D,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC;oBAAC,QAAQ,CAAC;gBAClC,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC;YACnC,CAAC;YACD,IAAM,KAAK,GAAG,EAAE,CAAC,uBAAuB,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC;YACvE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;gBAAC,QAAQ,CAAC;YACrB,GAAG,CAAC,CAAqB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;gBAAnB,IAAA,gBAAU,EAAT,YAAG,EAAE,YAAG;gBAClB,IAAM,SAAS,GAAG,WAAW,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;gBAChE,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;oBAAC,MAAM,CAAC,IAAI,CAAC;aACpD;SACF;QACD,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAEO,iDAAiB,GAAzB,UAA0B,CAAU;QAApC,iBAKC;QAJC,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACjB,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,KAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAAC,CAAC;QACzD,CAAC;QACD,MAAM,CAAC,EAAE,CAAC;IACZ,CAAC;IAED;;;OAGG;IACK,iDAAiB,GAAzB,UAA0B,IAA+B;QACvD,IAAM,cAAc,GAA2B,EAAE,CAAC;QAClD,IAAI,iBAAiB,GAAG,KAAK,CAAC;QAC9B,GAAG,CAAC,CAAgB,UAAe,EAAf,KAAA,IAAI,CAAC,UAAU,EAAf,cAAe,EAAf,IAAe;YAA9B,IAAM,KAAK,SAAA;YACd,IAAM,SAAS,GAAyB,EAAC,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAC,CAAC;YACvE,EAAE,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;gBACrB,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;gBACrD,iBAAiB,GAAG,iBAAiB,IAAI,SAAS,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;YAC3E,CAAC;YACD,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACf,8CAA8C;gBAC9C,yEAAyE;gBACzE,IAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,CAAC;gBACvE,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC9C,SAAS,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;gBAC9B,CAAC;YACH,CAAC;YACD,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SAChC;QAED,+EAA+E;QAC/E,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,iBAAiB,CAAC,CAAC,CAAC;YACzC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACvC,CAAC;IACH,CAAC;IAED;;OAEG;IACK,sDAAsB,GAA9B,UAA+B,MAA2B;QACxD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC;YAAC,MAAM,CAAC;QAC/B,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;YAClE,gCAAgC;YAChC,yBAAyB;YACzB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,qDAAqD,CAAC,CAAC;YACnF,MAAM,CAAC;QACT,CAAC;QAED,IAAM,IAAI,GAAI,MAAM,CAAC,IAAsB,CAAC,IAAI,CAAC;QACjD,IAAM,UAAU,GAAmB,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;QAClE,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC;QACpC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;YAAC,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,EAA0B,CAAC;QAClF,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IAC5C,CAAC;IAED;;;;;;;;;;OAUG;IACK,yDAAyB,GAAjC,UAAkC,UAAqB,EAAE,QAAqB;QAE5E,IAAM,gBAAgB,GAAG,UAAU,CAAC,gBAAuC,CAAC;QAC5E,EAAE,CAAC,CAAC,CAAC,gBAAgB,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QACnC,IAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC;QACxC,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;YAC9D,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QACD,EAAE,CAAC,CAAC,SAAS,CAAC,aAAa,EAAE,KAAK,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YACrD,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QACD,4CAA4C;QAC5C,sBAAsB;QACtB,IAAM,qBAAqB,GAAG,wBAAwB,CAAC,QAAQ,CAAC,CAAC;QACjE,EAAE,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC;YAC1B,GAAG,CAAC,CAAmC,UAAkB,EAAlB,KAAA,IAAI,CAAC,aAAa,EAAlB,cAAkB,EAAlB,IAAkB;gBAA9C,IAAA,WAAwB,EAAvB,gBAAI,EAAE,sCAAgB;gBAChC,EAAE,CAAC,CAAC,qBAAqB,CAAC,IAAI,KAAK,MAAI,CAAC,IAAI;oBACxC,gBAAgB,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAK,SAAS,EAAf,CAAe,CAAC,CAAC,CAAC,CAAC;oBAChD,MAAM,CAAC,MAAI,CAAC;gBACd,CAAC;aACF;QACH,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAED,iDAAiB,GAAjB,UAAkB,IAAa;QAC7B,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW;gBAC5B,IAAI,CAAC,iBAAiB,CAAC,IAAiC,CAAC,CAAC;gBAC1D,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC;YACvC,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;YAC/B,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;YAC/B,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;gBAClC,IAAI,CAAC,sBAAsB,CAAC,IAAsB,CAAC,CAAC;gBACpD,KAAK,CAAC;YACR,QAAQ;QACV,CAAC;IACH,CAAC;IAED,qDAAqB,GAArB,UAAsB,IAAkB,EAAE,KAAc;QACtD,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,8DAA8D;YAC9D,mDAAmD;YACnD,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACX,KAAK,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YAC9B,CAAC;YACD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;YACvD,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAED,+CAAe,GAAf;QACE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC;IAC3E,CAAC;IAED;;;OAGG;IACH,kEAAkC,GAAlC;QACE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;YAAC,MAAM,CAAC;QACjC,IAAM,SAAS,GAAG,4BAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACzD,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,yEAAyE,CAAC,CAAC;YAC9F,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAI,SAAS,mBAAgB,CAAC,CAAC;QACnD,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YAC3C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC5B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACvC,IAAI,CAAC,QAAQ,CAAC,IAAI,CACd,mIAAmI,CAAC,CAAC;YACzI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC5B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAI,SAAS,uBAAoB,CAAC,CAAC;QACvD,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,QAAQ,CAAC,IAAI,CACd,yFAAyF,CAAC,CAAC;YAC/F,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAI,SAAS,uBAAoB,CAAC,CAAC;QACvD,CAAC;IACH,CAAC;IAED;;OAEG;IACH,8DAA8B,GAA9B;QACE,IAAM,oBAAoB,GAAG,kCAAkC,CAAC;QAChE,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,wBAAsB,oBAAoB,WAAQ,CAAC,CAAC;YACvE,GAAG,CAAC,CAAqB,UAAe,EAAf,KAAA,IAAI,CAAC,UAAU,EAAf,cAAe,EAAf,IAAe;gBAAnC,IAAM,UAAU,SAAA;gBACnB,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC/B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC3B;YACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC7B,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YAC3C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;YAC3C,0FAA0F;YAC1F,UAAU;YACV,IAAI,CAAC,QAAQ,CAAC,IAAI,CACd,yDAAyD,GAAG,oBAAoB;gBAChF,uBAAuB,CAAC,CAAC;YAC7B,GAAG,CAAC,CAAgB,UAAyB,EAAzB,KAAA,IAAI,CAAC,cAAc,IAAI,EAAE,EAAzB,cAAyB,EAAzB,IAAyB;gBAAxC,IAAM,KAAK,SAAA;gBACd,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;oBACrC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBAC9B,QAAQ,CAAC;gBACX,CAAC;gBACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC9B,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;oBAChB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAClC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,qFAAqF;oBACrF,oFAAoF;oBACpF,iFAAiF;oBACjF,UAAU;oBACV,wFAAwF;oBACxF,yFAAyF;oBACzF,gFAAgF;oBAChF,yFAAyF;oBACzF,yFAAyF;oBACzF,oCAAoC;oBACpC,IAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,SAAS,EAAG,CAAC;oBACxE,IAAM,QAAQ,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;oBACjE,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACb,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;oBAC7E,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,IAAM,OAAO,GAAG,IAAI,gCAAc,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,IAAI,CAAC;6BAC3C,cAAc,CAAC,GAAG,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC;wBAC5D,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBAC9B,CAAC;gBACH,CAAC;gBACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACzB,EAAE,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;oBACrB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;oBACpC,GAAG,CAAC,CAAoB,UAAgB,EAAhB,KAAA,KAAK,CAAC,UAAU,EAAhB,cAAgB,EAAhB,IAAgB;wBAAnC,IAAM,SAAS,SAAA;wBAClB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;wBAC9B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBAC1B;oBACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC1B,CAAC;gBACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aAC5B;YACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC7B,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,QAAQ,CAAC,IAAI,CACd,yCAAyC,GAAG,oBAAoB,GAAG,SAAS,CAAC,CAAC;YAClF,GAAG,CAAC,CAAe,UAAmC,EAAnC,KAAA,cAAO,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,EAAnC,cAAmC,EAAnC,IAAmC;gBAAjD,IAAM,MAAI,SAAA;gBACb,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAI,MAAI,UAAM,CAAC,CAAC;gBAEnC,GAAG,CAAC,CAAoB,UAA8B,EAA9B,KAAA,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,MAAI,CAAE,EAA9B,cAA8B,EAA9B,IAA8B;oBAAjD,IAAM,SAAS,SAAA;oBAClB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;oBAC9B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACzB;gBACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aAC5B;YACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC7B,CAAC;IACH,CAAC;IAEO,6CAAa,GAArB,UAAsB,SAAuB;QAC3C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC/B,IAAM,IAAI,GAAG,SAAS,CAAC,UAAU,CAAC;QAClC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU;gBAC3B,kCAAkC;gBAClC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAC1B,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc;gBAC/B,4CAA4C;gBAC5C,IAAM,IAAI,GAAG,IAAyB,CAAC;gBACvC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACrC,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;oBAC1B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBAChC,GAAG,CAAC,CAAc,UAAc,EAAd,KAAA,IAAI,CAAC,SAAS,EAAd,cAAc,EAAd,IAAc;wBAA3B,IAAM,GAAG,SAAA;wBACZ,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC;wBACjD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBAC1B;oBACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC1B,CAAC;gBACD,KAAK,CAAC;YACR;gBACE,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,IAAI,EAAE,oBAAoB,CAAC,CAAC;gBACjE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACpC,CAAC;QACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IACH,4BAAC;AAAD,CAAC,AApTD,IAoTC;AApTY,sDAAqB;AAsTlC;IAAgC,6CAAQ;IAItC,2BACY,WAA2B,EAAE,UAAyB,EAAE,YAA2B;QAD/F,YAEE,kBAAM,UAAU,EAAE,YAAY,CAAC,SAChC;QAFW,iBAAW,GAAX,WAAW,CAAgB;QAH/B,mBAAa,GAAoE,EAAE,CAAC;;IAK5F,CAAC;IAED,mCAAO,GAAP;QACE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;IAC1B,CAAC;IAES,wCAAY,GAAtB,UAAuB,IAAa;QAClC,EAAE,CAAC,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC,CAAC;YACnC,IAAI,CAAC,yBAAyB,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACzD,CAAC;QACD,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;gBAClC,CAAA,KAAA,IAAI,CAAC,aAAa,CAAA,CAAC,IAAI,WAChB,oBAAoB,CAAC,IAAI,CAAC,WAAW,EAAE,IAA4B,CAAC,EAAE;gBAC7E,MAAM,CAAC,KAAK,CAAC;YACf,KAAK,EAAE,CAAC,UAAU,CAAC,SAAS;gBAC1B,MAAM,CAAC,IAAI,CAAC,yBAAyB;oBACjC,IAAI,CAAC,yBAAyB,CAAC,qBAAqB,CAAC,IAAoB,CAAC,CAAC;YACjF,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB;gBACjC,IAAM,qBAAqB,GAAG,IAAI,CAAC,yBAAyB,CAAC;gBAC7D,IAAI,CAAC,yBAAyB,GAAG,IAAI,qBAAqB,CACtD,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,IAA2B,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;gBAC7E,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC9B,oCAAoC,CAChC,IAA2B,EAAE,IAAI,EAAE,IAAI,CAAC,yBAAyB,CAAC,CAAC;gBACvE,IAAI,CAAC,yBAAyB,GAAG,qBAAqB,CAAC;gBACvD,MAAM,CAAC,IAAI,CAAC;YACd;gBACE,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;;IACH,CAAC;IACH,wBAAC;AAAD,CAAC,AAvCD,CAAgC,mBAAQ,GAuCvC;AAED;;;;;;GAMG;AACH,kCAAkC,IAAa;IAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;QAC3C,MAAM,CAAC,IAAqB,CAAC;IAC/B,CAAC;IACD,MAAM,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AACzD,CAAC;AAED;;;;;GAKG;AACH,8BAAqC,WAA2B,EAAE,IAA0B;IAE1F,IAAM,aAAa,GAAoE,EAAE,CAAC;IAC1F,IAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;IACvC,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QAClB,MAAM,CAAC,aAAa,CAAC;IACvB,CAAC;IACD,IAAM,KAAK,GAAoB,EAAE,CAAC;IAClC,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QACtB,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IACD,EAAE,CAAC,CAAC,YAAY,CAAC,aAAa;QAC1B,YAAY,CAAC,aAAa,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC;QACnE,IAAM,YAAY,GAAG,YAAY,CAAC,aAAgC,CAAC;QACnE,KAAK,CAAC,IAAI,OAAV,KAAK,EAAS,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,EAAE;IACxD,CAAC;IACD,GAAG,CAAC,CAAe,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK;QAAnB,IAAM,MAAI,cAAA;QACb,IAAI,MAAM,GAAG,WAAW,CAAC,mBAAmB,CAAC,MAAI,CAAE,CAAC;QACpD,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;YACxC,MAAM,GAAG,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAChD,CAAC;QACD,IAAM,gBAAgB,GAAoB,EAAE,CAAC;QAC7C,EAAE,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;YACxB,GAAG,CAAC,CAAY,UAAmB,EAAnB,KAAA,MAAM,CAAC,YAAY,EAAnB,cAAmB,EAAnB,IAAmB;gBAA9B,IAAM,CAAC,SAAA;gBACV,IAAM,MAAI,GAAG,CAAwB,CAAC;gBACtC,EAAE,CAAC,CAAC,MAAI,CAAC,IAAI,IAAI,MAAI,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC7D,gBAAgB,CAAC,IAAI,CAAC,MAAI,CAAC,IAAqB,CAAC,CAAC;gBACpD,CAAC;aACF;QACH,CAAC;QACD,EAAE,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;YACxB,aAAa,CAAC,IAAI,CAAC,EAAC,IAAI,QAAA,EAAE,gBAAgB,kBAAA,EAAC,CAAC,CAAC;QAC/C,CAAC;KACF;IACD,MAAM,CAAC,aAAa,CAAC;AACvB,CAAC;AAnCD,oDAmCC;AAGD,8CACI,SAA8B,EAAE,QAAkB,EAAE,gBAAwC;IAC9F,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QACvD,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,6BAA6B,CAAC,CAAC;QACzD,MAAM,CAAC;IACT,CAAC;IACD,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,SAAS,CAAC,QAAQ,EAAE,EAAE,SAAS,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;IAChF,oFAAoF;IACpF,8DAA8D;IAC9D,sEAAsE;IACtE,8DAA8D;IAC9D,iFAAiF;IACjF,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;QACrB,gBAAgB,CAAC,8BAA8B,EAAE,CAAC;IACpD,CAAC;IACD,QAAQ,CAAC,UAAU,CAAC,SAAS,EAAE,SAAS,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;AAC7E,CAAC;AAhBD,oFAgBC;AAGD,2BACI,WAA2B,EAAE,UAAyB,EACtD,YAA2B;IAC7B,MAAM,CAAC,IAAI,iBAAiB,CAAC,WAAW,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC,OAAO,EAAE,CAAC;AAChF,CAAC;AAJD,8CAIC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SourceMapGenerator} from 'source-map';\nimport * as ts from 'typescript';\n\nimport {getDecoratorDeclarations} from './decorators';\nimport {getIdentifierText, Rewriter} from './rewriter';\nimport {SourceMapper} from './source_map_utils';\nimport {TypeTranslator} from './type-translator';\nimport {toArray} from './util';\n\n/**\n * ConstructorParameters are gathered from constructors, so that their type information and\n * decorators can later be emitted as an annotation.\n */\ninterface ConstructorParameter {\n  /**\n   * The type declaration for the parameter. Only set if the type is a value (e.g. a class, not an\n   * interface).\n   */\n  type: ts.TypeNode|null;\n  /** The list of decorators found on the parameter, null if none. */\n  decorators: ts.Decorator[]|null;\n}\n\n// DecoratorClassVisitor rewrites a single \"class Foo {...}\" declaration.\n// It's its own object because we collect decorators on the class and the ctor\n// separately for each class we encounter.\nexport class DecoratorClassVisitor {\n  /** Decorators on the class itself. */\n  decorators: ts.Decorator[];\n  /** The constructor parameter list and decorators on each param. */\n  private ctorParameters: ConstructorParameter[];\n  /** Per-method decorators. */\n  propDecorators: Map<string, ts.Decorator[]>;\n\n  constructor(\n      private typeChecker: ts.TypeChecker, private rewriter: Rewriter,\n      private classDecl: ts.ClassDeclaration,\n      private importedNames: Array<{name: ts.Identifier, declarationNames: ts.Identifier[]}>) {\n    if (classDecl.decorators) {\n      const toLower = this.decoratorsToLower(classDecl);\n      if (toLower.length > 0) this.decorators = toLower;\n    }\n  }\n\n  /**\n   * Determines whether the given decorator should be re-written as an annotation.\n   */\n  private shouldLower(decorator: ts.Decorator) {\n    for (const d of getDecoratorDeclarations(decorator, this.typeChecker)) {\n      // Switch to the TS JSDoc parser in the future to avoid false positives here.\n      // For example using '@Annotation' in a true comment.\n      // However, a new TS API would be needed, track at\n      // https://github.com/Microsoft/TypeScript/issues/7393.\n      let commentNode: ts.Node = d;\n      // Not handling PropertyAccess expressions here, because they are\n      // filtered earlier.\n      if (commentNode.kind === ts.SyntaxKind.VariableDeclaration) {\n        if (!commentNode.parent) continue;\n        commentNode = commentNode.parent;\n      }\n      // Go up one more level to VariableDeclarationStatement, where usually\n      // the comment lives. If the declaration has an 'export', the\n      // VDList.getFullText will not contain the comment.\n      if (commentNode.kind === ts.SyntaxKind.VariableDeclarationList) {\n        if (!commentNode.parent) continue;\n        commentNode = commentNode.parent;\n      }\n      const range = ts.getLeadingCommentRanges(commentNode.getFullText(), 0);\n      if (!range) continue;\n      for (const {pos, end} of range) {\n        const jsDocText = commentNode.getFullText().substring(pos, end);\n        if (jsDocText.includes('@Annotation')) return true;\n      }\n    }\n    return false;\n  }\n\n  private decoratorsToLower(n: ts.Node): ts.Decorator[] {\n    if (n.decorators) {\n      return n.decorators.filter((d) => this.shouldLower(d));\n    }\n    return [];\n  }\n\n  /**\n   * gatherConstructor grabs the parameter list and decorators off the class\n   * constructor, and emits nothing.\n   */\n  private gatherConstructor(ctor: ts.ConstructorDeclaration) {\n    const ctorParameters: ConstructorParameter[] = [];\n    let hasDecoratedParam = false;\n    for (const param of ctor.parameters) {\n      const ctorParam: ConstructorParameter = {type: null, decorators: null};\n      if (param.decorators) {\n        ctorParam.decorators = this.decoratorsToLower(param);\n        hasDecoratedParam = hasDecoratedParam || ctorParam.decorators.length > 0;\n      }\n      if (param.type) {\n        // param has a type provided, e.g. \"foo: Bar\".\n        // Verify that \"Bar\" is a value (e.g. a constructor) and not just a type.\n        const sym = this.typeChecker.getTypeAtLocation(param.type).getSymbol();\n        if (sym && (sym.flags & ts.SymbolFlags.Value)) {\n          ctorParam.type = param.type;\n        }\n      }\n      ctorParameters.push(ctorParam);\n    }\n\n    // Use the ctor parameter metadata only if the class or the ctor was decorated.\n    if (this.decorators || hasDecoratedParam) {\n      this.ctorParameters = ctorParameters;\n    }\n  }\n\n  /**\n   * gatherMethod grabs the decorators off a class method and emits nothing.\n   */\n  private gatherMethodOrProperty(method: ts.NamedDeclaration) {\n    if (!method.decorators) return;\n    if (!method.name || method.name.kind !== ts.SyntaxKind.Identifier) {\n      // Method has a weird name, e.g.\n      //   [Symbol.foo]() {...}\n      this.rewriter.error(method, 'cannot process decorators on strangely named method');\n      return;\n    }\n\n    const name = (method.name as ts.Identifier).text;\n    const decorators: ts.Decorator[] = this.decoratorsToLower(method);\n    if (decorators.length === 0) return;\n    if (!this.propDecorators) this.propDecorators = new Map<string, ts.Decorator[]>();\n    this.propDecorators.set(name, decorators);\n  }\n\n  /**\n   * For lowering decorators, we need to refer to constructor types.\n   * So we start with the identifiers that represent these types.\n   * However, TypeScript does not allow us to emit them in a value position\n   * as it associated different symbol information with it.\n   *\n   * This method looks for the place where the value that is associated to\n   * the type is defined and returns that identifier instead.\n   *\n   * This might be simplified when https://github.com/Microsoft/TypeScript/issues/17516 is solved.\n   */\n  private getValueIdentifierForType(typeSymbol: ts.Symbol, typeNode: ts.TypeNode): ts.Identifier\n      |null {\n    const valueDeclaration = typeSymbol.valueDeclaration as ts.NamedDeclaration;\n    if (!valueDeclaration) return null;\n    const valueName = valueDeclaration.name;\n    if (!valueName || valueName.kind !== ts.SyntaxKind.Identifier) {\n      return null;\n    }\n    if (valueName.getSourceFile() === this.rewriter.file) {\n      return valueName;\n    }\n    // Need to look at the first identifier only\n    // to ignore generics.\n    const firstIdentifierInType = firstIdentifierInSubtree(typeNode);\n    if (firstIdentifierInType) {\n      for (const {name, declarationNames} of this.importedNames) {\n        if (firstIdentifierInType.text === name.text &&\n            declarationNames.some(d => d === valueName)) {\n          return name;\n        }\n      }\n    }\n    return null;\n  }\n\n  beforeProcessNode(node: ts.Node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.Constructor:\n        this.gatherConstructor(node as ts.ConstructorDeclaration);\n        break;\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.MethodDeclaration:\n        this.gatherMethodOrProperty(node as ts.Declaration);\n        break;\n      default:\n    }\n  }\n\n  maybeProcessDecorator(node: ts.Decorator, start?: number): boolean {\n    if (this.shouldLower(node)) {\n      // Return true to signal that this node should not be emitted,\n      // but still emit the whitespace *before* the node.\n      if (!start) {\n        start = node.getFullStart();\n      }\n      this.rewriter.writeRange(node, start, node.getStart());\n      return true;\n    }\n    return false;\n  }\n\n  foundDecorators(): boolean {\n    return !!(this.decorators || this.ctorParameters || this.propDecorators);\n  }\n\n  /**\n   * emits the types for the various gathered metadata to be used\n   * in the tsickle type annotations helper.\n   */\n  emitMetadataTypeAnnotationsHelpers() {\n    if (!this.classDecl.name) return;\n    const className = getIdentifierText(this.classDecl.name);\n    if (this.decorators) {\n      this.rewriter.emit(`/** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */\\n`);\n      this.rewriter.emit(`${className}.decorators;\\n`);\n    }\n    if (this.decorators || this.ctorParameters) {\n      this.rewriter.emit(`/**\\n`);\n      this.rewriter.emit(` * @nocollapse\\n`);\n      this.rewriter.emit(\n          ` * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}\\n`);\n      this.rewriter.emit(` */\\n`);\n      this.rewriter.emit(`${className}.ctorParameters;\\n`);\n    }\n    if (this.propDecorators) {\n      this.rewriter.emit(\n          `/** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */\\n`);\n      this.rewriter.emit(`${className}.propDecorators;\\n`);\n    }\n  }\n\n  /**\n   * emitMetadata emits the various gathered metadata, as static fields.\n   */\n  emitMetadataAsStaticProperties() {\n    const decoratorInvocations = '{type: Function, args?: any[]}[]';\n    if (this.decorators) {\n      this.rewriter.emit(`static decorators: ${decoratorInvocations} = [\\n`);\n      for (const annotation of this.decorators) {\n        this.emitDecorator(annotation);\n        this.rewriter.emit(',\\n');\n      }\n      this.rewriter.emit('];\\n');\n    }\n\n    if (this.decorators || this.ctorParameters) {\n      this.rewriter.emit(`/** @nocollapse */\\n`);\n      // ctorParameters may contain forward references in the type: field, so wrap in a function\n      // closure\n      this.rewriter.emit(\n          `static ctorParameters: () => ({type: any, decorators?: ` + decoratorInvocations +\n          `}|null)[] = () => [\\n`);\n      for (const param of this.ctorParameters || []) {\n        if (!param.type && !param.decorators) {\n          this.rewriter.emit('null,\\n');\n          continue;\n        }\n        this.rewriter.emit(`{type: `);\n        if (!param.type) {\n          this.rewriter.emit(`undefined`);\n        } else {\n          // For transformer mode, tsickle must emit not only the string referring to the type,\n          // but also create a source mapping, so that TypeScript can later recognize that the\n          // symbol is used in a value position, so that TypeScript emits an import for the\n          // symbol.\n          // The code below and in getValueIdentifierForType finds the value node corresponding to\n          // the type and emits that symbol if possible. This causes a source mapping to the value,\n          // which then allows later transformers in the pipeline to do the correct module\n          // rewriting. Note that we cannot use param.type as the emit node directly (not even just\n          // for mapping), because that is marked as a type use of the node, not a value use, so it\n          // doesn't get updated as an export.\n          const sym = this.typeChecker.getTypeAtLocation(param.type).getSymbol()!;\n          const emitNode = this.getValueIdentifierForType(sym, param.type);\n          if (emitNode) {\n            this.rewriter.writeRange(emitNode, emitNode.getStart(), emitNode.getEnd());\n          } else {\n            const typeStr = new TypeTranslator(this.typeChecker, param.type)\n                                .symbolToString(sym, /* useFqn */ true);\n            this.rewriter.emit(typeStr);\n          }\n        }\n        this.rewriter.emit(`, `);\n        if (param.decorators) {\n          this.rewriter.emit('decorators: [');\n          for (const decorator of param.decorators) {\n            this.emitDecorator(decorator);\n            this.rewriter.emit(', ');\n          }\n          this.rewriter.emit(']');\n        }\n        this.rewriter.emit('},\\n');\n      }\n      this.rewriter.emit(`];\\n`);\n    }\n\n    if (this.propDecorators) {\n      this.rewriter.emit(\n          `static propDecorators: {[key: string]: ` + decoratorInvocations + `} = {\\n`);\n      for (const name of toArray(this.propDecorators.keys())) {\n        this.rewriter.emit(`\"${name}\": [`);\n\n        for (const decorator of this.propDecorators.get(name)!) {\n          this.emitDecorator(decorator);\n          this.rewriter.emit(',');\n        }\n        this.rewriter.emit('],\\n');\n      }\n      this.rewriter.emit('};\\n');\n    }\n  }\n\n  private emitDecorator(decorator: ts.Decorator) {\n    this.rewriter.emit('{ type: ');\n    const expr = decorator.expression;\n    switch (expr.kind) {\n      case ts.SyntaxKind.Identifier:\n        // The decorator was a plain @Foo.\n        this.rewriter.visit(expr);\n        break;\n      case ts.SyntaxKind.CallExpression:\n        // The decorator was a call, like @Foo(bar).\n        const call = expr as ts.CallExpression;\n        this.rewriter.visit(call.expression);\n        if (call.arguments.length) {\n          this.rewriter.emit(', args: [');\n          for (const arg of call.arguments) {\n            this.rewriter.writeNodeFrom(arg, arg.getStart());\n            this.rewriter.emit(', ');\n          }\n          this.rewriter.emit(']');\n        }\n        break;\n      default:\n        this.rewriter.errorUnimplementedKind(expr, 'gathering metadata');\n        this.rewriter.emit('undefined');\n    }\n    this.rewriter.emit(' }');\n  }\n}\n\nclass DecoratorRewriter extends Rewriter {\n  private currentDecoratorConverter: DecoratorClassVisitor;\n  private importedNames: Array<{name: ts.Identifier, declarationNames: ts.Identifier[]}> = [];\n\n  constructor(\n      private typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile, sourceMapper?: SourceMapper) {\n    super(sourceFile, sourceMapper);\n  }\n\n  process(): {output: string, diagnostics: ts.Diagnostic[]} {\n    this.visit(this.file);\n    return this.getOutput();\n  }\n\n  protected maybeProcess(node: ts.Node): boolean {\n    if (this.currentDecoratorConverter) {\n      this.currentDecoratorConverter.beforeProcessNode(node);\n    }\n    switch (node.kind) {\n      case ts.SyntaxKind.ImportDeclaration:\n        this.importedNames.push(\n            ...collectImportedNames(this.typeChecker, node as ts.ImportDeclaration));\n        return false;\n      case ts.SyntaxKind.Decorator:\n        return this.currentDecoratorConverter &&\n            this.currentDecoratorConverter.maybeProcessDecorator(node as ts.Decorator);\n      case ts.SyntaxKind.ClassDeclaration:\n        const oldDecoratorConverter = this.currentDecoratorConverter;\n        this.currentDecoratorConverter = new DecoratorClassVisitor(\n            this.typeChecker, this, node as ts.ClassDeclaration, this.importedNames);\n        this.writeLeadingTrivia(node);\n        visitClassContentIncludingDecorators(\n            node as ts.ClassDeclaration, this, this.currentDecoratorConverter);\n        this.currentDecoratorConverter = oldDecoratorConverter;\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\n/**\n * Returns the first identifier in the node tree starting at node\n * in a depth first order.\n *\n * @param node The node to start with\n * @return The first identifier if one was found.\n */\nfunction firstIdentifierInSubtree(node: ts.Node): ts.Identifier|undefined {\n  if (node.kind === ts.SyntaxKind.Identifier) {\n    return node as ts.Identifier;\n  }\n  return ts.forEachChild(node, firstIdentifierInSubtree);\n}\n\n/**\n * Collect the Identifiers used as named bindings in the given import declaration\n * with their Symbol.\n * This is needed later on to find an identifier that represents the value\n * of an imported type identifier.\n */\nexport function collectImportedNames(typeChecker: ts.TypeChecker, decl: ts.ImportDeclaration):\n    Array<{name: ts.Identifier, declarationNames: ts.Identifier[]}> {\n  const importedNames: Array<{name: ts.Identifier, declarationNames: ts.Identifier[]}> = [];\n  const importClause = decl.importClause;\n  if (!importClause) {\n    return importedNames;\n  }\n  const names: ts.Identifier[] = [];\n  if (importClause.name) {\n    names.push(importClause.name);\n  }\n  if (importClause.namedBindings &&\n      importClause.namedBindings.kind === ts.SyntaxKind.NamedImports) {\n    const namedImports = importClause.namedBindings as ts.NamedImports;\n    names.push(...namedImports.elements.map(e => e.name));\n  }\n  for (const name of names) {\n    let symbol = typeChecker.getSymbolAtLocation(name)!;\n    if (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = typeChecker.getAliasedSymbol(symbol);\n    }\n    const declarationNames: ts.Identifier[] = [];\n    if (symbol.declarations) {\n      for (const d of symbol.declarations) {\n        const decl = d as ts.NamedDeclaration;\n        if (decl.name && decl.name.kind === ts.SyntaxKind.Identifier) {\n          declarationNames.push(decl.name as ts.Identifier);\n        }\n      }\n    }\n    if (symbol.declarations) {\n      importedNames.push({name, declarationNames});\n    }\n  }\n  return importedNames;\n}\n\n\nexport function visitClassContentIncludingDecorators(\n    classDecl: ts.ClassDeclaration, rewriter: Rewriter, decoratorVisitor?: DecoratorClassVisitor) {\n  if (rewriter.file.text[classDecl.getEnd() - 1] !== '}') {\n    rewriter.error(classDecl, 'unexpected class terminator');\n    return;\n  }\n  rewriter.writeNodeFrom(classDecl, classDecl.getStart(), classDecl.getEnd() - 1);\n  // At this point, we've emitted up through the final child of the class, so all that\n  // remains is the trailing whitespace and closing curly brace.\n  // The final character owned by the class node should always be a '}',\n  // or we somehow got the AST wrong and should report an error.\n  // (Any whitespace or semicolon following the '}' will be part of the next Node.)\n  if (decoratorVisitor) {\n    decoratorVisitor.emitMetadataAsStaticProperties();\n  }\n  rewriter.writeRange(classDecl, classDecl.getEnd() - 1, classDecl.getEnd());\n}\n\n\nexport function convertDecorators(\n    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile,\n    sourceMapper?: SourceMapper): {output: string, diagnostics: ts.Diagnostic[]} {\n  return new DecoratorRewriter(typeChecker, sourceFile, sourceMapper).process();\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/decorators.ts","node_modules/tsickle/src/rewriter.ts","node_modules/tsickle/src/source_map_utils.ts","node_modules/tsickle/src/type-translator.ts","node_modules/tsickle/src/util.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"source-map","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./decorators","resolvedPath":"node_modules/tsickle/src/decorators","external":false,"resolved":true},{"modulePath":"./rewriter","resolvedPath":"node_modules/tsickle/src/rewriter","external":false,"resolved":true},{"modulePath":"./source_map_utils","resolvedPath":"node_modules/tsickle/src/source_map_utils","external":false,"resolved":true},{"modulePath":"./type-translator","resolvedPath":"node_modules/tsickle/src/type-translator","external":false,"resolved":true},{"modulePath":"./util","resolvedPath":"node_modules/tsickle/src/util","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/decorator-annotator.ts","message":"Cannot find module 'source-map'.","line":9,"column":34},{"code":2307,"fileName":"node_modules/tsickle/src/decorator-annotator.ts","message":"Cannot find module 'typescript'.","line":10,"column":21},{"code":2354,"fileName":"node_modules/tsickle/src/decorator-annotator.ts","message":"This syntax requires an imported helper but module 'tslib' cannot be found.","line":78,"column":19}]},"hash":"c1d4cbfd3b18f2b84dd9f79a374865068cd47548"}