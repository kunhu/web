{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar path = require(\"path\");\r\nvar source_map_1 = require(\"source-map\");\r\nvar ts = require(\"typescript\");\r\nvar decorator = require(\"/node_modules/tsickle/src/decorator-annotator\");\r\nvar decorators_1 = require(\"/node_modules/tsickle/src/decorators\");\r\nvar es5processor = require(\"/node_modules/tsickle/src/es5processor\");\r\nvar jsdoc = require(\"/node_modules/tsickle/src/jsdoc\");\r\nvar modules_manifest_1 = require(\"/node_modules/tsickle/src/modules_manifest\");\r\nvar rewriter_1 = require(\"/node_modules/tsickle/src/rewriter\");\r\nvar source_map_utils_1 = require(\"/node_modules/tsickle/src/source_map_utils\");\r\nvar transformer_sourcemap_1 = require(\"/node_modules/tsickle/src/transformer_sourcemap\");\r\nvar transformer_util_1 = require(\"/node_modules/tsickle/src/transformer_util\");\r\nvar typeTranslator = require(\"./type-translator\");\r\nvar util_1 = require(\"./util\");\r\nvar decorator_annotator_1 = require(\"/node_modules/tsickle/src/decorator-annotator\");\r\nexports.convertDecorators = decorator_annotator_1.convertDecorators;\r\nvar modules_manifest_2 = require(\"/node_modules/tsickle/src/modules_manifest\");\r\nexports.ModulesManifest = modules_manifest_2.ModulesManifest;\r\n/**\r\n * The header to be used in generated externs.  This is not included in the\r\n * output of annotate() because annotate() works one file at a time, and\r\n * typically you create one externs file from the entire compilation unit.\r\n */\r\nexports.EXTERNS_HEADER = \"/**\\n * @externs\\n * @suppress {duplicate,checkTypes}\\n */\\n// NOTE: generated by tsickle, do not edit.\\n\";\r\n/**\r\n * Symbols that are already declared as externs in Closure, that should\r\n * be avoided by tsickle's \"declare ...\" => externs.js conversion.\r\n */\r\nexports.closureExternsBlacklist = [\r\n    'exports',\r\n    'global',\r\n    'module',\r\n    // ErrorConstructor is the interface of the Error object itself.\r\n    // tsickle detects that this is part of the TypeScript standard library\r\n    // and assumes it's part of the Closure standard library, but this\r\n    // assumption is wrong for ErrorConstructor.  To properly handle this\r\n    // we'd somehow need to map methods defined on the ErrorConstructor\r\n    // interface into properties on Closure's Error object, but for now it's\r\n    // simpler to just blacklist it.\r\n    'ErrorConstructor',\r\n    'Symbol',\r\n    'WorkerGlobalScope',\r\n];\r\nfunction formatDiagnostics(diags) {\r\n    return diags\r\n        .map(function (d) {\r\n        var res = ts.DiagnosticCategory[d.category];\r\n        if (d.file) {\r\n            res += ' at ' + d.file.fileName + ':';\r\n            if (d.start) {\r\n                var _a = d.file.getLineAndCharacterOfPosition(d.start), line = _a.line, character = _a.character;\r\n                res += (line + 1) + ':' + (character + 1) + ':';\r\n            }\r\n        }\r\n        res += ' ' + ts.flattenDiagnosticMessageText(d.messageText, '\\n');\r\n        return res;\r\n    })\r\n        .join('\\n');\r\n}\r\nexports.formatDiagnostics = formatDiagnostics;\r\n/** @return true if node has the specified modifier flag set. */\r\nfunction hasModifierFlag(node, flag) {\r\n    return (ts.getCombinedModifierFlags(node) & flag) !== 0;\r\n}\r\nexports.hasModifierFlag = hasModifierFlag;\r\n/** @return true if node has the specified modifier flag set. */\r\nfunction isAmbient(node) {\r\n    var current = node;\r\n    while (current) {\r\n        if (hasModifierFlag(current, ts.ModifierFlags.Ambient))\r\n            return true;\r\n        current = current.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * TypeScript allows you to write identifiers quoted, like:\r\n *   interface Foo {\r\n *     'bar': string;\r\n *     'complex name': string;\r\n *   }\r\n *   Foo.bar;  // ok\r\n *   Foo['bar']  // ok\r\n *   Foo['complex name']  // ok\r\n *\r\n * In Closure-land, we want identify that the legal name 'bar' can become an\r\n * ordinary field, but we need to skip strings like 'complex name'.\r\n */\r\nfunction isValidClosurePropertyName(name) {\r\n    // In local experimentation, it appears that reserved words like 'var' and\r\n    // 'if' are legal JS and still accepted by Closure.\r\n    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);\r\n}\r\nfunction isDtsFileName(fileName) {\r\n    return /\\.d\\.ts$/.test(fileName);\r\n}\r\nexports.isDtsFileName = isDtsFileName;\r\n/** Returns the Closure name of a function parameter, special-casing destructuring. */\r\nfunction getParameterName(param, index) {\r\n    switch (param.name.kind) {\r\n        case ts.SyntaxKind.Identifier:\r\n            var name_1 = rewriter_1.getIdentifierText(param.name);\r\n            // TypeScript allows parameters named \"arguments\", but Closure\r\n            // disallows this, even in externs.\r\n            if (name_1 === 'arguments')\r\n                name_1 = 'tsickle_arguments';\r\n            return name_1;\r\n        case ts.SyntaxKind.ArrayBindingPattern:\r\n        case ts.SyntaxKind.ObjectBindingPattern:\r\n            // Closure crashes if you put a binding pattern in the externs.\r\n            // Avoid this by just generating an unused name; the name is\r\n            // ignored anyway.\r\n            return \"__\" + index;\r\n        default:\r\n            // The above list of kinds is exhaustive.  param.name is 'never' at this point.\r\n            var paramName = param.name;\r\n            throw new Error(\"unhandled function parameter kind: \" + ts.SyntaxKind[paramName.kind]);\r\n    }\r\n}\r\n/** Flags that declare a field of the same name if set on a ctor parameter. */\r\nvar FIELD_DECLARATION_MODIFIERS = ts.ModifierFlags.Private |\r\n    ts.ModifierFlags.Protected | ts.ModifierFlags.Public | ts.ModifierFlags.Readonly;\r\n/**\r\n * A Rewriter subclass that adds Tsickle-specific (Closure translation) functionality.\r\n *\r\n * One Rewriter subclass manages .ts => .ts+Closure translation.\r\n * Another Rewriter subclass manages .ts => externs translation.\r\n */\r\nvar ClosureRewriter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ClosureRewriter, _super);\r\n    function ClosureRewriter(typeChecker, file, host, sourceMapper) {\r\n        var _this = _super.call(this, file, sourceMapper) || this;\r\n        _this.typeChecker = typeChecker;\r\n        _this.host = host;\r\n        /**\r\n         * A mapping of aliases for symbols in the current file, used when emitting types.\r\n         * TypeScript emits imported symbols with unpredictable prefixes. To generate correct type\r\n         * annotations, tsickle creates its own aliases for types, and registers them in this map (see\r\n         * `emitImportDeclaration` and `forwardDeclare()` below). The aliases are then used when emitting\r\n         * types.\r\n         */\r\n        _this.symbolsToAliasedNames = new Map();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Get the ts.Symbol at a location or throw.\r\n     * The TypeScript API can return undefined when fetching a symbol, but\r\n     * in many contexts we know it won't (e.g. our input is already type-checked).\r\n     */\r\n    ClosureRewriter.prototype.mustGetSymbolAtLocation = function (node) {\r\n        var sym = this.typeChecker.getSymbolAtLocation(node);\r\n        if (!sym)\r\n            throw new Error('no symbol');\r\n        return sym;\r\n    };\r\n    /**\r\n     * Handles emittng the jsdoc for methods, including overloads.\r\n     * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.\r\n     * - Total number of parameters will be the maximum count found across all variants.\r\n     * - Different names at the same parameter index will be joined with \"_or_\"\r\n     * - Variable args (...type[] in TypeScript) will be output as \"...type\",\r\n     *    except if found at the same index as another argument.\r\n     * @param  fnDecls Pass > 1 declaration for overloads of same name\r\n     * @return The list of parameter names that should be used to emit the actual\r\n     *    function statement; for overloads, name will have been merged.\r\n     */\r\n    ClosureRewriter.prototype.emitFunctionType = function (fnDecls, extraTags) {\r\n        if (extraTags === void 0) { extraTags = []; }\r\n        var typeChecker = this.typeChecker;\r\n        var newDoc = extraTags;\r\n        var lens = fnDecls.map(function (fnDecl) { return fnDecl.parameters.length; });\r\n        var minArgsCount = Math.min.apply(Math, lens);\r\n        var maxArgsCount = Math.max.apply(Math, lens);\r\n        var isConstructor = fnDecls.find(function (d) { return d.kind === ts.SyntaxKind.Constructor; }) !== undefined;\r\n        // For each parameter index i, paramTags[i] is an array of parameters\r\n        // that can be found at index i.  E.g.\r\n        //    function foo(x: string)\r\n        //    function foo(y: number, z: string)\r\n        // then paramTags[0] = [info about x, info about y].\r\n        var paramTags = [];\r\n        var returnTags = [];\r\n        var typeParameterNames = new Set();\r\n        for (var _i = 0, fnDecls_1 = fnDecls; _i < fnDecls_1.length; _i++) {\r\n            var fnDecl = fnDecls_1[_i];\r\n            // Construct the JSDoc comment by reading the existing JSDoc, if\r\n            // any, and merging it with the known types of the function\r\n            // parameters and return type.\r\n            var docTags = this.getJSDoc(fnDecl) || [];\r\n            // Copy all the tags other than @param/@return into the new\r\n            // JSDoc without any change; @param/@return are handled specially.\r\n            // TODO: there may be problems if an annotation doesn't apply to all overloads;\r\n            // is it worth checking for this and erroring?\r\n            for (var _a = 0, docTags_1 = docTags; _a < docTags_1.length; _a++) {\r\n                var tag = docTags_1[_a];\r\n                if (tag.tagName === 'param' || tag.tagName === 'return')\r\n                    continue;\r\n                newDoc.push(tag);\r\n            }\r\n            // Add @abstract on \"abstract\" declarations.\r\n            if (hasModifierFlag(fnDecl, ts.ModifierFlags.Abstract)) {\r\n                newDoc.push({ tagName: 'abstract' });\r\n            }\r\n            // Add any @template tags.\r\n            // Multiple declarations with the same template variable names should work:\r\n            // the declarations get turned into union types, and Closure Compiler will need\r\n            // to find a union where all type arguments are satisfied.\r\n            if (fnDecl.typeParameters) {\r\n                for (var _b = 0, _c = fnDecl.typeParameters; _b < _c.length; _b++) {\r\n                    var tp = _c[_b];\r\n                    typeParameterNames.add(rewriter_1.getIdentifierText(tp.name));\r\n                }\r\n            }\r\n            // Merge the parameters into a single list of merged names and list of types\r\n            var sig = typeChecker.getSignatureFromDeclaration(fnDecl);\r\n            if (!sig)\r\n                throw new Error(\"invalid signature \" + fnDecl.name);\r\n            for (var i = 0; i < sig.declaration.parameters.length; i++) {\r\n                var paramNode = sig.declaration.parameters[i];\r\n                var name_2 = getParameterName(paramNode, i);\r\n                var isThisParam = name_2 === 'this';\r\n                var newTag = {\r\n                    tagName: isThisParam ? 'this' : 'param',\r\n                    optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,\r\n                    parameterName: isThisParam ? undefined : name_2,\r\n                };\r\n                var type = typeChecker.getTypeAtLocation(paramNode);\r\n                if (paramNode.dotDotDotToken !== undefined) {\r\n                    newTag.restParam = true;\r\n                    // In TypeScript you write \"...x: number[]\", but in Closure\r\n                    // you don't write the array: \"@param {...number} x\".  Unwrap\r\n                    // the Array<> wrapper.\r\n                    var typeRef = type;\r\n                    if (!typeRef.typeArguments)\r\n                        throw new Error('invalid rest param');\r\n                    type = typeRef.typeArguments[0];\r\n                }\r\n                newTag.type = this.typeToClosure(fnDecl, type);\r\n                for (var _d = 0, docTags_2 = docTags; _d < docTags_2.length; _d++) {\r\n                    var _e = docTags_2[_d], tagName = _e.tagName, parameterName = _e.parameterName, text = _e.text;\r\n                    if (tagName === 'param' && parameterName === newTag.parameterName) {\r\n                        newTag.text = text;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!paramTags[i])\r\n                    paramTags.push([]);\r\n                paramTags[i].push(newTag);\r\n            }\r\n            // Return type.\r\n            if (!isConstructor) {\r\n                var retType = typeChecker.getReturnTypeOfSignature(sig);\r\n                var retTypeString = this.typeToClosure(fnDecl, retType);\r\n                var returnDoc = void 0;\r\n                for (var _f = 0, docTags_3 = docTags; _f < docTags_3.length; _f++) {\r\n                    var _g = docTags_3[_f], tagName = _g.tagName, text = _g.text;\r\n                    if (tagName === 'return') {\r\n                        returnDoc = text;\r\n                        break;\r\n                    }\r\n                }\r\n                returnTags.push({\r\n                    tagName: 'return',\r\n                    type: retTypeString,\r\n                    text: returnDoc,\r\n                });\r\n            }\r\n        }\r\n        if (typeParameterNames.size > 0) {\r\n            newDoc.push({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });\r\n        }\r\n        // Merge the JSDoc tags for each overloaded parameter.\r\n        // Ensure each parameter has a unique name; the merging process can otherwise\r\n        // accidentally generate the same parameter name twice.\r\n        var paramNames = new Set();\r\n        var foundOptional = false;\r\n        for (var i = 0; i < maxArgsCount; i++) {\r\n            var paramTag = jsdoc.merge(paramTags[i]);\r\n            if (paramNames.has(paramTag.parameterName)) {\r\n                paramTag.parameterName += i.toString();\r\n            }\r\n            paramNames.add(paramTag.parameterName);\r\n            // If the tag is optional, mark parameters following optional as optional,\r\n            // even if they are not, since Closure restricts this, see\r\n            // https://github.com/google/closure-compiler/issues/2314\r\n            if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {\r\n                foundOptional = true;\r\n                paramTag.optional = true;\r\n            }\r\n            newDoc.push(paramTag);\r\n            if (paramTag.restParam) {\r\n                // Cannot have any parameters after a rest param.\r\n                // Just dump the remaining parameters.\r\n                break;\r\n            }\r\n        }\r\n        // Merge the JSDoc tags for each overloaded return.\r\n        if (!isConstructor) {\r\n            newDoc.push(jsdoc.merge(returnTags));\r\n        }\r\n        this.emit('\\n' + jsdoc.toString(newDoc));\r\n        return newDoc.filter(function (t) { return t.tagName === 'param'; }).map(function (t) { return t.parameterName; });\r\n    };\r\n    /**\r\n     * Returns null if there is no existing comment.\r\n     */\r\n    ClosureRewriter.prototype.getJSDoc = function (node) {\r\n        var text = node.getFullText();\r\n        var comments = ts.getLeadingCommentRanges(text, 0);\r\n        if (!comments || comments.length === 0)\r\n            return null;\r\n        // We need to search backwards for the first JSDoc comment to avoid ignoring such when another\r\n        // code-level comment is between that comment and the function declaration (see\r\n        // testfiles/doc_params for an example).\r\n        var docRelativePos = 0;\r\n        var parsed = null;\r\n        for (var i = comments.length - 1; i >= 0; i--) {\r\n            var _a = comments[i], pos = _a.pos, end = _a.end;\r\n            // end is relative within node.getFullText(), add getFullStart to obtain coordinates that are\r\n            // comparable to node positions.\r\n            var docRelativeEnd = end + node.getFullStart();\r\n            if (docRelativeEnd <= this.file.getStart() &&\r\n                this.file.text.substring(docRelativeEnd).startsWith('\\n\\n')) {\r\n                // This comment is at the very beginning of the file and there's an empty line between the\r\n                // comment and this node. That means we should treat it as a file-level comment, not\r\n                // attached to this code node.\r\n                return null;\r\n            }\r\n            var comment = text.substring(pos, end);\r\n            parsed = jsdoc.parse(comment);\r\n            if (parsed) {\r\n                docRelativePos = node.getFullStart() + pos;\r\n                break;\r\n            }\r\n        }\r\n        if (!parsed)\r\n            return null;\r\n        if (parsed.warnings) {\r\n            var start = docRelativePos;\r\n            this.diagnostics.push({\r\n                file: this.file,\r\n                start: start,\r\n                length: node.getStart() - start,\r\n                messageText: parsed.warnings.join('\\n'),\r\n                category: ts.DiagnosticCategory.Warning,\r\n                code: 0,\r\n            });\r\n        }\r\n        return parsed.tags;\r\n    };\r\n    ClosureRewriter.prototype.maybeAddTemplateClause = function (docTags, decl) {\r\n        var _this = this;\r\n        if (!decl.typeParameters)\r\n            return;\r\n        // Closure does not support template constraints (T extends X).\r\n        docTags.push({\r\n            tagName: 'template',\r\n            text: decl.typeParameters\r\n                .map(function (tp) {\r\n                if (tp.constraint) {\r\n                    _this.emit('\\n// unsupported: template constraints.');\r\n                }\r\n                return rewriter_1.getIdentifierText(tp.name);\r\n            })\r\n                .join(', ')\r\n        });\r\n    };\r\n    ClosureRewriter.prototype.maybeAddHeritageClauses = function (docTags, decl) {\r\n        if (!decl.heritageClauses)\r\n            return;\r\n        for (var _i = 0, _a = decl.heritageClauses; _i < _a.length; _i++) {\r\n            var heritage = _a[_i];\r\n            if (!heritage.types)\r\n                continue;\r\n            var isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;\r\n            if (isClass && heritage.token !== ts.SyntaxKind.ImplementsKeyword && !isAmbient(decl)) {\r\n                // If a class has \"extends Foo\", that is preserved in the ES6 output\r\n                // and we don't need to do anything.  But if it has \"implements Foo\",\r\n                // that is a TS-specific thing and we need to translate it to the\r\n                // the Closure \"@implements {Foo}\".\r\n                // However for ambient declarations, we only emit externs, and in those we do need to\r\n                // add \"@extends {Foo}\" as they use ES5 syntax.\r\n                continue;\r\n            }\r\n            for (var _b = 0, _c = heritage.types; _b < _c.length; _b++) {\r\n                var impl = _c[_b];\r\n                var tagName = decl.kind === ts.SyntaxKind.InterfaceDeclaration ? 'extends' : 'implements';\r\n                // We can only @implements an interface, not a class.\r\n                // But it's fine to translate TS \"implements Class\" into Closure\r\n                // \"@extends {Class}\" because this is just a type hint.\r\n                var typeChecker = this.typeChecker;\r\n                var sym = this.mustGetSymbolAtLocation(impl.expression);\r\n                var alias = sym;\r\n                if (sym.flags & ts.SymbolFlags.TypeAlias) {\r\n                    // It's implementing a type alias.  Follow the type alias back\r\n                    // to the original symbol to check whether it's a type or a value.\r\n                    var type = this.typeChecker.getDeclaredTypeOfSymbol(sym);\r\n                    if (!type.symbol) {\r\n                        // It's not clear when this can happen, but if it does all we\r\n                        // do is fail to emit the @implements, which isn't so harmful.\r\n                        continue;\r\n                    }\r\n                    alias = type.symbol;\r\n                }\r\n                if (alias.flags & ts.SymbolFlags.Alias) {\r\n                    alias = typeChecker.getAliasedSymbol(alias);\r\n                }\r\n                var typeTranslator_1 = this.newTypeTranslator(impl.expression);\r\n                if (typeTranslator_1.isBlackListed(alias)) {\r\n                    continue;\r\n                }\r\n                if (alias.flags & ts.SymbolFlags.Class) {\r\n                    if (!isClass) {\r\n                        // Only classes can extend classes in TS. Ignoring the heritage clause should be safe,\r\n                        // as interfaces are @record anyway, so should prevent property disambiguation.\r\n                        // Problem: validate that methods are there?\r\n                        continue;\r\n                    }\r\n                    tagName = 'extends';\r\n                }\r\n                else if (alias.flags & ts.SymbolFlags.Value) {\r\n                    // If the symbol was already in the value namespace, then it will\r\n                    // not be a type in the Closure output (because Closure collapses\r\n                    // the type and value namespaces).  Just ignore the implements.\r\n                    continue;\r\n                }\r\n                // typeToClosure includes nullability modifiers, so call symbolToString directly here.\r\n                docTags.push({ tagName: tagName, type: typeTranslator_1.symbolToString(sym, true) });\r\n            }\r\n        }\r\n    };\r\n    /** Emits a type annotation in JSDoc, or {?} if the type is unavailable. */\r\n    ClosureRewriter.prototype.emitJSDocType = function (node, additionalDocTag, type) {\r\n        this.emit(' /**');\r\n        if (additionalDocTag) {\r\n            this.emit(' ' + additionalDocTag);\r\n        }\r\n        this.emit(\" @type {\" + this.typeToClosure(node, type) + \"} */\");\r\n    };\r\n    /**\r\n     * Convert a TypeScript ts.Type into the equivalent Closure type.\r\n     *\r\n     * @param context The ts.Node containing the type reference; used for resolving symbols\r\n     *     in context.\r\n     * @param type The type to translate; if not provided, the Node's type will be used.\r\n     */\r\n    ClosureRewriter.prototype.typeToClosure = function (context, type) {\r\n        if (this.host.untyped) {\r\n            return '?';\r\n        }\r\n        var typeChecker = this.typeChecker;\r\n        if (!type) {\r\n            type = typeChecker.getTypeAtLocation(context);\r\n        }\r\n        return this.newTypeTranslator(context).translate(type);\r\n    };\r\n    ClosureRewriter.prototype.newTypeTranslator = function (context) {\r\n        var _this = this;\r\n        var translator = new typeTranslator.TypeTranslator(this.typeChecker, context, this.host.typeBlackListPaths, this.symbolsToAliasedNames);\r\n        translator.warn = function (msg) { return _this.debugWarn(context, msg); };\r\n        return translator;\r\n    };\r\n    /**\r\n     * debug logs a debug warning.  These should only be used for cases\r\n     * where tsickle is making a questionable judgement about what to do.\r\n     * By default, tsickle does not report any warnings to the caller,\r\n     * and warnings are hidden behind a debug flag, as warnings are only\r\n     * for tsickle to debug itself.\r\n     */\r\n    ClosureRewriter.prototype.debugWarn = function (node, messageText) {\r\n        if (!this.host.logWarning)\r\n            return;\r\n        // Use a ts.Diagnosic so that the warning includes context and file offets.\r\n        var diagnostic = {\r\n            file: this.file,\r\n            start: node.getStart(),\r\n            length: node.getEnd() - node.getStart(),\r\n            messageText: messageText,\r\n            category: ts.DiagnosticCategory.Warning,\r\n            code: 0,\r\n        };\r\n        this.host.logWarning(diagnostic);\r\n    };\r\n    return ClosureRewriter;\r\n}(rewriter_1.Rewriter));\r\n// Matches common extensions of TypeScript input filenames\r\nvar extension = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\r\nvar FILEOVERVIEW_COMMENTS = new Set(['fileoverview', 'externs', 'modName', 'mods', 'pintomodule']);\r\n/** Annotator translates a .ts to a .ts with Closure annotations. */\r\nvar Annotator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Annotator, _super);\r\n    function Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {\r\n        var _this = _super.call(this, typeChecker, file, host, sourceMapper) || this;\r\n        _this.tsHost = tsHost;\r\n        _this.tsOpts = tsOpts;\r\n        /** Exported symbol names that have been generated by expanding an \"export * from ...\". */\r\n        _this.generatedExports = new Set();\r\n        /** Collection of Identifiers used in an `import {foo}` declaration with their Symbol */\r\n        _this.importedNames = [];\r\n        _this.templateSpanStackCount = 0;\r\n        _this.polymerBehaviorStackCount = 0;\r\n        _this.forwardDeclareCounter = 0;\r\n        return _this;\r\n    }\r\n    Annotator.prototype.annotate = function () {\r\n        this.visit(this.file);\r\n        return this.getOutput();\r\n    };\r\n    Annotator.prototype.getExportDeclarationNames = function (node) {\r\n        var _this = this;\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.VariableStatement:\r\n                var varDecl = node;\r\n                return varDecl.declarationList.declarations.map(function (d) { return _this.getExportDeclarationNames(d)[0]; });\r\n            case ts.SyntaxKind.VariableDeclaration:\r\n            case ts.SyntaxKind.FunctionDeclaration:\r\n            case ts.SyntaxKind.InterfaceDeclaration:\r\n            case ts.SyntaxKind.ClassDeclaration:\r\n            case ts.SyntaxKind.ModuleDeclaration:\r\n                var decl = node;\r\n                if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {\r\n                    break;\r\n                }\r\n                return [decl.name];\r\n            case ts.SyntaxKind.TypeAliasDeclaration:\r\n                var typeAlias = node;\r\n                return [typeAlias.name];\r\n            default:\r\n                break;\r\n        }\r\n        this.error(node, \"unsupported export declaration \" + ts.SyntaxKind[node.kind] + \": \" + node.getText());\r\n        return [];\r\n    };\r\n    /**\r\n     * Emits an ES6 export for the ambient declaration behind node, if it is indeed exported.\r\n     */\r\n    Annotator.prototype.maybeEmitAmbientDeclarationExport = function (node) {\r\n        // In TypeScript, `export declare` simply generates no code in the exporting module, but does\r\n        // generate a regular import in the importing module.\r\n        // For Closure Compiler, such declarations must still be exported, so that importing code in\r\n        // other modules can reference them. Because tsickle generates global symbols for such types,\r\n        // the appropriate semantics are referencing the global name.\r\n        if (this.host.untyped || !hasModifierFlag(node, ts.ModifierFlags.Export)) {\r\n            return;\r\n        }\r\n        var declNames = this.getExportDeclarationNames(node);\r\n        for (var _i = 0, declNames_1 = declNames; _i < declNames_1.length; _i++) {\r\n            var decl = declNames_1[_i];\r\n            var sym = this.mustGetSymbolAtLocation(decl);\r\n            var isValue = sym.flags & ts.SymbolFlags.Value;\r\n            var declName = rewriter_1.getIdentifierText(decl);\r\n            if (node.kind === ts.SyntaxKind.VariableStatement) {\r\n                // For variables, TypeScript rewrites every reference to the variable name as an\r\n                // \"exports.\" access, to maintain mutable ES6 exports semantics. Indirecting through the\r\n                // window object means we reference the correct global symbol. Closure Compiler does\r\n                // understand that \"var foo\" in externs corresponds to \"window.foo\".\r\n                this.emit(\"\\nexports.\" + declName + \" = window.\" + declName + \";\\n\");\r\n            }\r\n            else if (!isValue) {\r\n                // Do not emit re-exports for ModuleDeclarations.\r\n                // Ambient ModuleDeclarations are always referenced as global symbols, so they don't need to\r\n                // be exported.\r\n                if (node.kind === ts.SyntaxKind.ModuleDeclaration)\r\n                    continue;\r\n                // Non-value objects do not exist at runtime, so we cannot access the symbol (it only\r\n                // exists in externs). Export them as a typedef, which forwards to the type in externs.\r\n                this.emit(\"\\n/** @typedef {\" + declName + \"} */\\nexports.\" + declName + \";\\n\");\r\n            }\r\n            else {\r\n                this.emit(\"\\nexports.\" + declName + \" = \" + declName + \";\\n\");\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Examines a ts.Node and decides whether to do special processing of it for output.\r\n     *\r\n     * @return True if the ts.Node has been handled, false if we should\r\n     *     emit it as is and visit its children.\r\n     */\r\n    Annotator.prototype.maybeProcess = function (node) {\r\n        var _this = this;\r\n        if (hasModifierFlag(node, ts.ModifierFlags.Ambient) || isDtsFileName(this.file.fileName)) {\r\n            // An ambient declaration declares types for TypeScript's benefit, so we want to skip Tsickle\r\n            // conversion of its contents.\r\n            this.writeRange(node, node.getFullStart(), node.getEnd());\r\n            // ... but it might need to be exported for downstream importing code.\r\n            this.maybeEmitAmbientDeclarationExport(node);\r\n            return true;\r\n        }\r\n        if (this.currentDecoratorConverter) {\r\n            this.currentDecoratorConverter.beforeProcessNode(node);\r\n        }\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.SourceFile:\r\n                this.handleSourceFile(node);\r\n                return true;\r\n            case ts.SyntaxKind.ImportDeclaration:\r\n                (_a = this.importedNames).push.apply(_a, decorator.collectImportedNames(this.typeChecker, node));\r\n                return this.emitImportDeclaration(node);\r\n            case ts.SyntaxKind.ExportDeclaration:\r\n                var exportDecl = node;\r\n                this.writeLeadingTrivia(node);\r\n                this.emit('export');\r\n                var exportedSymbols = [];\r\n                if (!exportDecl.exportClause && exportDecl.moduleSpecifier) {\r\n                    // It's an \"export * from ...\" statement.\r\n                    // Rewrite it to re-export each exported symbol directly.\r\n                    exportedSymbols = this.expandSymbolsFromExportStar(exportDecl);\r\n                    var exportSymbolsToEmit = exportedSymbols.filter(function (s) { return _this.shouldEmitExportSymbol(s.sym); });\r\n                    this.emit(\" {\" + exportSymbolsToEmit.map(function (e) { return rewriter_1.unescapeName(e.name); }).join(',') + \"}\");\r\n                }\r\n                else {\r\n                    if (exportDecl.exportClause) {\r\n                        exportedSymbols = this.getNamedSymbols(exportDecl.exportClause.elements);\r\n                        this.visit(exportDecl.exportClause);\r\n                    }\r\n                }\r\n                if (exportDecl.moduleSpecifier) {\r\n                    this.emit(\" from '\" + this.resolveModuleSpecifier(exportDecl.moduleSpecifier) + \"';\");\r\n                }\r\n                else {\r\n                    // export {...};\r\n                    this.emit(';');\r\n                }\r\n                this.addSourceMapping(node);\r\n                if (exportDecl.moduleSpecifier) {\r\n                    this.forwardDeclare(exportDecl.moduleSpecifier, exportedSymbols);\r\n                }\r\n                if (exportedSymbols.length) {\r\n                    this.emitTypeDefExports(exportedSymbols);\r\n                }\r\n                return true;\r\n            case ts.SyntaxKind.InterfaceDeclaration:\r\n                this.emitInterface(node);\r\n                // Emit the TS interface verbatim, with no tsickle processing of properties.\r\n                this.writeRange(node, node.getFullStart(), node.getEnd());\r\n                return true;\r\n            case ts.SyntaxKind.VariableDeclaration:\r\n                var varDecl = node;\r\n                // Only emit a type annotation when it's a plain variable and\r\n                // not a binding pattern, as Closure doesn't(?) have a syntax\r\n                // for annotating binding patterns.  See issue #128.\r\n                // Don't emit type annotation when the variable statement is a @polymerBehavior,\r\n                // as otherwise the polymer closure checker will fail.\r\n                // See b/64389806\r\n                if (this.polymerBehaviorStackCount === 0 &&\r\n                    varDecl.name.kind === ts.SyntaxKind.Identifier) {\r\n                    this.emitJSDocType(varDecl);\r\n                }\r\n                return false;\r\n            case ts.SyntaxKind.ClassDeclaration:\r\n                var classNode = node;\r\n                this.visitClassDeclaration(classNode);\r\n                return true;\r\n            case ts.SyntaxKind.PublicKeyword:\r\n            case ts.SyntaxKind.PrivateKeyword:\r\n                // The \"public\"/\"private\" keywords are encountered in two places:\r\n                // 1) In class fields (which don't appear in the transformed output).\r\n                // 2) In \"parameter properties\", e.g.\r\n                //      constructor(/** @export */ public foo: string).\r\n                // In case 2 it's important to not emit that JSDoc in the generated\r\n                // constructor, as this is illegal for Closure.  It's safe to just\r\n                // always skip comments preceding the 'public' keyword.\r\n                // See test_files/parameter_properties.ts.\r\n                this.writeNode(node, /* skipComments */ true);\r\n                return true;\r\n            case ts.SyntaxKind.Constructor:\r\n                var ctor = node;\r\n                this.emitFunctionType([ctor]);\r\n                // Write the \"constructor(...) {\" bit, but iterate through any\r\n                // parameters if given so that we can examine them more closely.\r\n                this.writeNodeFrom(ctor, ctor.getStart());\r\n                return true;\r\n            case ts.SyntaxKind.ArrowFunction:\r\n                // It's difficult to annotate arrow functions due to a bug in\r\n                // TypeScript (see tsickle issue 57).  For now, just pass them\r\n                // through unannotated.\r\n                return false;\r\n            case ts.SyntaxKind.FunctionDeclaration:\r\n            case ts.SyntaxKind.MethodDeclaration:\r\n            case ts.SyntaxKind.GetAccessor:\r\n            case ts.SyntaxKind.SetAccessor:\r\n                var fnDecl = node;\r\n                var tags = decorators_1.hasExportingDecorator(node, this.typeChecker) ? [{ tagName: 'export' }] : [];\r\n                if (!fnDecl.body) {\r\n                    // Two cases: abstract methods and overloaded methods/functions.\r\n                    // Abstract methods are handled in emitTypeAnnotationsHandler.\r\n                    // Overloads are union-ized into the shared type in emitFunctionType.\r\n                    return false;\r\n                }\r\n                this.emitFunctionType([fnDecl], tags);\r\n                this.writeNodeFrom(fnDecl, fnDecl.getStart());\r\n                return true;\r\n            case ts.SyntaxKind.TypeAliasDeclaration:\r\n                this.writeNode(node);\r\n                this.visitTypeAlias(node);\r\n                return true;\r\n            case ts.SyntaxKind.EnumDeclaration:\r\n                this.processEnum(node);\r\n                return true;\r\n            case ts.SyntaxKind.TemplateSpan:\r\n                this.templateSpanStackCount++;\r\n                this.writeNode(node);\r\n                this.templateSpanStackCount--;\r\n                return true;\r\n            case ts.SyntaxKind.TypeAssertionExpression:\r\n            case ts.SyntaxKind.AsExpression:\r\n                // Both of these cases are AssertionExpressions.\r\n                var typeAssertion = node;\r\n                if (this.polymerBehaviorStackCount > 0) {\r\n                    // Don't emit type casts for Polymer behaviors that are declared\r\n                    // by calling the Polymer function\r\n                    // as the Polymer closure plugin does not work when emitting them.\r\n                    // See b/64389806.\r\n                    // Note: This only matters in the transformer version of tsickle,\r\n                    // as the non transformer version never emitted type casts due to\r\n                    // https://github.com/Microsoft/TypeScript/issues/9873 (see below).\r\n                    return false;\r\n                }\r\n                // When using a type casts in template expressions,\r\n                // closure requires another pair of parens, otherwise it will\r\n                // complain with \"Misplaced type annotation. Type annotations are not allowed here.\"\r\n                if (this.templateSpanStackCount > 0) {\r\n                    this.emit('(');\r\n                }\r\n                this.emitJSDocType(typeAssertion);\r\n                // When TypeScript emits JS, it removes one layer of \"redundant\"\r\n                // parens, but we need them for the Closure type assertion.  Work\r\n                // around this by using two parens.  See test_files/coerce.*.\r\n                // This is needed in both, the transformer and non transformer version.\r\n                // TODO: in the non transformer version, the comment is currently dropped\r\n                //  alltegether from pure assignments due to\r\n                //  https://github.com/Microsoft/TypeScript/issues/9873.\r\n                this.emit('((');\r\n                this.writeNode(node);\r\n                this.emit('))');\r\n                if (this.templateSpanStackCount > 0) {\r\n                    this.emit(')');\r\n                }\r\n                return true;\r\n            case ts.SyntaxKind.NonNullExpression:\r\n                var nnexpr = node;\r\n                var type = this.typeChecker.getTypeAtLocation(nnexpr.expression);\r\n                if (type.flags & ts.TypeFlags.Union) {\r\n                    var nonNullUnion = type\r\n                        .types.filter(function (t) { return (t.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) === 0; });\r\n                    var typeCopy = Object.assign({}, type);\r\n                    typeCopy.types = nonNullUnion;\r\n                    type = typeCopy;\r\n                }\r\n                // See comment above.\r\n                if (this.templateSpanStackCount > 0) {\r\n                    this.emit('(');\r\n                }\r\n                this.emitJSDocType(nnexpr, undefined, type);\r\n                // See comment above.\r\n                this.emit('((');\r\n                this.writeNode(nnexpr.expression);\r\n                this.emit('))');\r\n                if (this.templateSpanStackCount > 0) {\r\n                    this.emit(')');\r\n                }\r\n                return true;\r\n            case ts.SyntaxKind.PropertyDeclaration:\r\n            case ts.SyntaxKind.VariableStatement:\r\n                var docTags = this.getJSDoc(node) || [];\r\n                if (decorators_1.hasExportingDecorator(node, this.typeChecker)) {\r\n                    docTags.push({ tagName: 'export' });\r\n                }\r\n                if (docTags.length > 0 && node.getFirstToken()) {\r\n                    this.emit('\\n');\r\n                    this.emit(jsdoc.toString(docTags));\r\n                    var isPolymerBehavior = docTags.some(function (t) { return t.tagName === 'polymerBehavior'; });\r\n                    if (isPolymerBehavior) {\r\n                        this.polymerBehaviorStackCount++;\r\n                    }\r\n                    this.writeNodeFrom(node, node.getStart());\r\n                    if (isPolymerBehavior) {\r\n                        this.polymerBehaviorStackCount--;\r\n                    }\r\n                    return true;\r\n                }\r\n                break;\r\n            case ts.SyntaxKind.PropertyAssignment:\r\n                var pa = node;\r\n                if (isPolymerBehaviorPropertyInCallExpression(pa)) {\r\n                    this.polymerBehaviorStackCount++;\r\n                    this.writeNodeFrom(node, node.getStart());\r\n                    this.polymerBehaviorStackCount--;\r\n                    return true;\r\n                }\r\n                return false;\r\n            case ts.SyntaxKind.ElementAccessExpression:\r\n                // Warn for quoted accesses to properties that have a symbol declared.\r\n                // Mixing quoted and non-quoted access to a symbol (x['foo'] and x.foo) risks breaking\r\n                // Closure Compiler renaming. Quoted access is more cumbersome to write than dotted access\r\n                // though, so chances are users did intend to avoid renaming. The better fix is to use\r\n                // `declare interface` though.\r\n                var eae = node;\r\n                if (!eae.argumentExpression ||\r\n                    eae.argumentExpression.kind !== ts.SyntaxKind.StringLiteral) {\r\n                    return false;\r\n                }\r\n                var quotedPropSym = this.typeChecker.getSymbolAtLocation(eae.argumentExpression);\r\n                // If it has a symbol, it's actually a regular declared property.\r\n                if (!quotedPropSym)\r\n                    return false;\r\n                var declarationHasQuotes = !quotedPropSym.declarations || quotedPropSym.declarations.some(function (d) {\r\n                    var decl = d;\r\n                    if (!decl.name)\r\n                        return false;\r\n                    return decl.name.kind === ts.SyntaxKind.StringLiteral;\r\n                });\r\n                // If the property is declared with quotes, it should also be accessed with them.\r\n                if (declarationHasQuotes)\r\n                    return false;\r\n                var propName = eae.argumentExpression.text;\r\n                // Properties containing non-JS identifier names can only be accessed with quotes.\r\n                if (!isValidClosurePropertyName(propName))\r\n                    return false;\r\n                var symName = this.typeChecker.symbolToString(quotedPropSym);\r\n                this.debugWarn(eae, \"Declared property \" + symName + \" accessed with quotes. \" +\r\n                    \"This can lead to renaming bugs. A better fix is to use 'declare interface' \" +\r\n                    \"on the declaration.\");\r\n                // Previously, the code below changed the quoted into a non-quoted access.\r\n                // this.writeNode(eae.expression);\r\n                // this.emit(`.${propName}`);\r\n                return false;\r\n            case ts.SyntaxKind.PropertyAccessExpression:\r\n                // Convert dotted accesses to types that have an index type declared to quoted accesses, to\r\n                // avoid Closure renaming one access but not the other.\r\n                // This can happen because TS allows dotted access to string index types.\r\n                var pae = node;\r\n                var t = this.typeChecker.getTypeAtLocation(pae.expression);\r\n                if (!t.getStringIndexType())\r\n                    return false;\r\n                // Types can have string index signatures and declared properties (of the matching type).\r\n                // These properties have a symbol, as opposed to pure string index types.\r\n                var propSym = this.typeChecker.getSymbolAtLocation(pae.name);\r\n                // The decision to return below is a judgement call. Presumably, in most situations, dotted\r\n                // access to a property is correct, and should not be turned into quoted access even if\r\n                // there is a string index on the type. However it is possible to construct programs where\r\n                // this is incorrect, e.g. where user code assigns into a property through the index access\r\n                // in another location.\r\n                if (propSym)\r\n                    return false;\r\n                this.debugWarn(pae, this.typeChecker.typeToString(t) +\r\n                    \" has a string index type but is accessed using dotted access. \" +\r\n                    \"Quoting the access.\");\r\n                this.writeNode(pae.expression);\r\n                this.emit('[\"');\r\n                this.writeNode(pae.name);\r\n                this.emit('\"]');\r\n                return true;\r\n            case ts.SyntaxKind.Decorator:\r\n                if (this.currentDecoratorConverter) {\r\n                    return this.currentDecoratorConverter.maybeProcessDecorator(node);\r\n                }\r\n                return false;\r\n            default:\r\n                break;\r\n        }\r\n        return false;\r\n        var _a;\r\n    };\r\n    Annotator.prototype.shouldEmitExportSymbol = function (sym) {\r\n        if (sym.flags & ts.SymbolFlags.Alias) {\r\n            sym = this.typeChecker.getAliasedSymbol(sym);\r\n        }\r\n        if ((sym.flags & ts.SymbolFlags.Value) === 0) {\r\n            // Note: We create explicit reexports via closure at another place in\r\n            return false;\r\n        }\r\n        if (sym.flags & ts.SymbolFlags.ConstEnum) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    Annotator.prototype.handleSourceFile = function (sf) {\r\n        var start = this.emitSuppressChecktypes(sf);\r\n        this.writeNodeFrom(sf, start);\r\n    };\r\n    /**\r\n     * Emits an \\@suppress {checkTypes} fileoverview comment.\r\n     * Returns the place from where to start emitting the source file.\r\n     */\r\n    Annotator.prototype.emitSuppressChecktypes = function (sf) {\r\n        var comments = ts.getLeadingCommentRanges(sf.getFullText(), 0) || [];\r\n        var fileoverviewIdx = -1;\r\n        for (var i = comments.length - 1; i >= 0; i--) {\r\n            var parsed_1 = jsdoc.parse(sf.getFullText().substring(comments[i].pos, comments[i].end));\r\n            if (parsed_1 !== null && parsed_1.tags.some(function (t) { return FILEOVERVIEW_COMMENTS.has(t.tagName); })) {\r\n                fileoverviewIdx = i;\r\n                break;\r\n            }\r\n        }\r\n        // Add a @suppress {checkTypes} tag to each source file's JSDoc comment,\r\n        // being careful to retain existing comments and their @suppress'ions.\r\n        // Closure Compiler considers the *last* comment with @fileoverview (or @externs or @nocompile)\r\n        // that has not been attached to some other tree node to be the file overview comment, and\r\n        // only applies @suppress tags from it.\r\n        // AJD considers *any* comment mentioning @fileoverview.\r\n        if (fileoverviewIdx === -1) {\r\n            // No existing comment to merge with, just emit a new one.\r\n            this.emit(jsdoc.toString([\r\n                { tagName: 'fileoverview', text: 'added by tsickle' },\r\n                { tagName: 'suppress', type: 'checkTypes', text: 'checked by tsc' },\r\n            ]));\r\n            this.emit('\\n');\r\n            return sf.getFullStart();\r\n        }\r\n        var comment = comments[fileoverviewIdx];\r\n        this.writeRange(sf, 0, comment.pos);\r\n        var parsed = jsdoc.parse(sf.getFullText().substring(comment.pos, comment.end));\r\n        if (!parsed)\r\n            throw new Error('internal error: JSDoc comment does not parse');\r\n        var tags = parsed.tags;\r\n        // Add @suppress {checkTypes}, or add to the list in an existing @suppress tag.\r\n        // Closure compiler barfs if there's a duplicated @suppress tag in a file, so the tag must\r\n        // only appear once and be merged.\r\n        var suppressIdx = tags.findIndex(function (t) { return t.tagName === 'suppress'; });\r\n        if (suppressIdx !== -1) {\r\n            var suppressions = tags[suppressIdx].type || '';\r\n            var suppressionsList = suppressions.split(',').map(function (s) { return s.trim(); });\r\n            if (suppressionsList.indexOf('checkTypes') === -1) {\r\n                suppressionsList.push('checkTypes');\r\n            }\r\n            tags[suppressIdx].type = suppressionsList.join(',');\r\n        }\r\n        else {\r\n            tags.push({\r\n                tagName: 'suppress',\r\n                type: 'checkTypes',\r\n                text: 'checked by tsc',\r\n            });\r\n        }\r\n        this.emit(jsdoc.toString(tags));\r\n        if (sf.getFullText().substring(comment.end, comment.end + 2) !== '\\n\\n') {\r\n            this.emit('\\n\\n'); // separate from file body to avoid being dropped by tsc.\r\n        }\r\n        // Return this comment's end, so that subsequent code does not emit this comment multiple times,\r\n        // which can be an error in case of @fileoverview comments.\r\n        // Known issue: if this comment is not the last comment in the file's leading trivia, this will\r\n        // swallow comments before the next node, unless they are recognized as JSDoc comments on the\r\n        // node. That's because while each node will print its leading trivia when visited, they will\r\n        // not print areas that are partially blocked (like this, except for JSDoc). This is hard to fix\r\n        // as the node being emitted cannot know which range should still be printed. Generally speaking\r\n        // swallowing a comment is less risky than emitting one twice, so we take that into account.\r\n        return comment.end;\r\n    };\r\n    /**\r\n     * Given a \"export * from ...\" statement, gathers the symbol names it actually\r\n     * exports to be used in a statement like \"export {foo, bar, baz} from ...\".\r\n     *\r\n     * This is necessary because TS transpiles \"export *\" by just doing a runtime loop\r\n     * over the target module's exports, which means Closure won't see the declarations/types\r\n     * that are exported.\r\n     */\r\n    Annotator.prototype.expandSymbolsFromExportStar = function (exportDecl) {\r\n        // You can't have an \"export *\" without a module specifier.\r\n        var moduleSpecifier = exportDecl.moduleSpecifier;\r\n        // Gather the names of local exports, to avoid reexporting any\r\n        // names that are already locally exported.\r\n        var moduleSymbol = this.typeChecker.getSymbolAtLocation(this.file);\r\n        var moduleExports = moduleSymbol && moduleSymbol.exports || new Map();\r\n        // Expand the export list, then filter it to the symbols we want to reexport.\r\n        var exports = this.typeChecker.getExportsOfModule(this.mustGetSymbolAtLocation(moduleSpecifier));\r\n        var reexports = new Set();\r\n        for (var _i = 0, exports_1 = exports; _i < exports_1.length; _i++) {\r\n            var sym = exports_1[_i];\r\n            var name_3 = rewriter_1.unescapeName(sym.name);\r\n            if (moduleExports.has(name_3)) {\r\n                // This name is shadowed by a local definition, such as:\r\n                // - export var foo ...\r\n                // - export {foo} from ...\r\n                // - export {bar as foo} from ...\r\n                continue;\r\n            }\r\n            if (this.generatedExports.has(name_3)) {\r\n                // Already exported via an earlier expansion of an \"export * from ...\".\r\n                continue;\r\n            }\r\n            this.generatedExports.add(name_3);\r\n            reexports.add(sym);\r\n        }\r\n        return util_1.toArray(reexports.keys()).map(function (sym) {\r\n            return { name: sym.name, sym: sym };\r\n        });\r\n    };\r\n    /**\r\n     * Write an `exports.` assignment for each type alias exported in the given `exports`.\r\n     * TypeScript by itself does not export non-value symbols (e.g. interfaces, typedefs), as it\r\n     * expects to remove those entirely for runtime. For Closure, types must be\r\n     * exported as downstream code will import the type.\r\n     *\r\n     * The tsickle pass turns interfaces into values by generating a `function MyInterface() {}` for\r\n     * them, so in the second conversion pass, TypeScript does export a value for them. However for\r\n     * pure typedefs, tsickle only generates a property access with a JSDoc comment, so they need to\r\n     * be exported explicitly here.\r\n     */\r\n    Annotator.prototype.emitTypeDefExports = function (exports) {\r\n        if (this.host.untyped)\r\n            return;\r\n        for (var _i = 0, exports_2 = exports; _i < exports_2.length; _i++) {\r\n            var exp = exports_2[_i];\r\n            if (exp.sym.flags & ts.SymbolFlags.Alias)\r\n                exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);\r\n            var isTypeAlias = ((exp.sym.flags & ts.SymbolFlags.TypeAlias) !== 0 &&\r\n                (exp.sym.flags & ts.SymbolFlags.Value) === 0) ||\r\n                (exp.sym.flags & ts.SymbolFlags.Interface) !== 0 &&\r\n                    (exp.sym.flags & ts.SymbolFlags.Value) === 0;\r\n            if (!isTypeAlias)\r\n                continue;\r\n            var typeName = this.symbolsToAliasedNames.get(exp.sym) || exp.sym.name;\r\n            this.emit(\"\\n/** @typedef {\" + typeName + \"} */\\nexports.\" + exp.name + \"; // re-export typedef\");\r\n        }\r\n    };\r\n    /**\r\n     * Convert from implicit `import {} from 'pkg'` to `import {} from 'pkg/index'.\r\n     * TypeScript supports the shorthand, but not all ES6 module loaders do.\r\n     * Workaround for https://github.com/Microsoft/TypeScript/issues/12597\r\n     */\r\n    Annotator.prototype.resolveModuleSpecifier = function (moduleSpecifier) {\r\n        if (moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {\r\n            throw new Error(\"unhandled moduleSpecifier kind: \" + ts.SyntaxKind[moduleSpecifier.kind]);\r\n        }\r\n        var moduleId = moduleSpecifier.text;\r\n        if (this.host.convertIndexImportShorthand) {\r\n            if (!this.tsOpts || !this.tsHost) {\r\n                throw new Error('option convertIndexImportShorthand requires that annotate be called with a TypeScript host and options.');\r\n            }\r\n            var resolved = ts.resolveModuleName(moduleId, this.file.fileName, this.tsOpts, this.tsHost);\r\n            if (resolved && resolved.resolvedModule) {\r\n                var requestedModule = moduleId.replace(extension, '');\r\n                var resolvedModule = resolved.resolvedModule.resolvedFileName.replace(extension, '');\r\n                if (resolvedModule.indexOf('node_modules') === -1 &&\r\n                    requestedModule.substr(requestedModule.lastIndexOf('/')) !==\r\n                        resolvedModule.substr(resolvedModule.lastIndexOf('/'))) {\r\n                    moduleId = './' +\r\n                        path.relative(path.dirname(this.file.fileName), resolvedModule)\r\n                            .replace(path.sep, '/');\r\n                }\r\n            }\r\n        }\r\n        return moduleId;\r\n    };\r\n    /**\r\n     * Handles emit of an \"import ...\" statement.\r\n     * We need to do a bit of rewriting so that imported types show up under the\r\n     * correct name in JSDoc.\r\n     * @return true if the decl was handled, false to allow default processing.\r\n     */\r\n    Annotator.prototype.emitImportDeclaration = function (decl) {\r\n        this.writeLeadingTrivia(decl);\r\n        this.emit('import');\r\n        var importPath = this.resolveModuleSpecifier(decl.moduleSpecifier);\r\n        var importClause = decl.importClause;\r\n        if (!importClause) {\r\n            // import './foo';\r\n            this.emit(\"'\" + importPath + \"';\");\r\n            this.addSourceMapping(decl);\r\n            return true;\r\n        }\r\n        else if (importClause.name ||\r\n            (importClause.namedBindings &&\r\n                importClause.namedBindings.kind === ts.SyntaxKind.NamedImports)) {\r\n            this.visit(importClause);\r\n            this.emit(\" from '\" + importPath + \"';\");\r\n            this.addSourceMapping(decl);\r\n            // importClause.name implies\r\n            //   import a from ...;\r\n            // namedBindings being NamedImports implies\r\n            //   import {a as b} from ...;\r\n            //\r\n            // Both of these forms create a local name \"a\", which after TypeScript CommonJS compilation\r\n            // will become some renamed variable like \"module_1.default\" or \"module_1.a\" (for default vs\r\n            // named bindings, respectively).\r\n            // tsickle references types in JSDoc. Because the module prefixes are not predictable, and\r\n            // because TypeScript might remove imports entirely if they are only for types, the code below\r\n            // inserts an artificial `const prefix = goog.require` call for the module, and then registers\r\n            // all symbols from this import to be prefixed.\r\n            if (!this.host.untyped) {\r\n                var symbols = [];\r\n                if (importClause.name) {\r\n                    // import a from ...;\r\n                    symbols = [{\r\n                            name: rewriter_1.getIdentifierText(importClause.name),\r\n                            sym: this.mustGetSymbolAtLocation(importClause.name),\r\n                        }];\r\n                }\r\n                else {\r\n                    // import {a as b} from ...;\r\n                    if (!importClause.namedBindings ||\r\n                        importClause.namedBindings.kind !== ts.SyntaxKind.NamedImports) {\r\n                        throw new Error('unreached'); // Guaranteed by if check above.\r\n                    }\r\n                    symbols = this.getNamedSymbols(importClause.namedBindings.elements);\r\n                }\r\n                this.forwardDeclare(decl.moduleSpecifier, symbols, !!importClause.name);\r\n            }\r\n            return true;\r\n        }\r\n        else if (importClause.namedBindings &&\r\n            importClause.namedBindings.kind === ts.SyntaxKind.NamespaceImport) {\r\n            // import * as foo from ...;\r\n            this.visit(importClause);\r\n            this.emit(\" from '\" + importPath + \"';\");\r\n            this.addSourceMapping(decl);\r\n            return true;\r\n        }\r\n        else {\r\n            this.errorUnimplementedKind(decl, 'unexpected kind of import');\r\n            return false; // Use default processing.\r\n        }\r\n    };\r\n    Annotator.prototype.getNamedSymbols = function (specifiers) {\r\n        var _this = this;\r\n        return specifiers.map(function (e) {\r\n            return {\r\n                // e.name might be renaming symbol as in `export {Foo as Bar}`, where e.name would be 'Bar'\r\n                // and != sym.name. Store away the name so forwardDeclare below can emit the right name.\r\n                name: rewriter_1.getIdentifierText(e.name),\r\n                sym: _this.mustGetSymbolAtLocation(e.name),\r\n            };\r\n        });\r\n    };\r\n    /**\r\n     * Emits a `goog.forwardDeclare` alias for each symbol from the given list.\r\n     * @param specifier the import specifier, i.e. module path (\"from '...'\").\r\n     */\r\n    Annotator.prototype.forwardDeclare = function (specifier, exportedSymbols, isDefaultImport) {\r\n        if (isDefaultImport === void 0) { isDefaultImport = false; }\r\n        if (this.host.untyped)\r\n            return;\r\n        var importPath = this.resolveModuleSpecifier(specifier);\r\n        var nsImport = es5processor.extractGoogNamespaceImport(importPath);\r\n        var forwardDeclarePrefix = \"tsickle_forward_declare_\" + ++this.forwardDeclareCounter;\r\n        var moduleNamespace = nsImport !== null ? nsImport : this.host.pathToModuleName(this.file.fileName, importPath);\r\n        var moduleSymbol = this.typeChecker.getSymbolAtLocation(specifier);\r\n        // Scripts do not have a symbol. Scripts can still be imported, either as side effect imports or\r\n        // with an empty import set (\"{}\"). TypeScript does not emit a runtime load for an import with\r\n        // an empty list of symbols, but the import forces any global declarations from the library to\r\n        // be visible, which is what users use this for. No symbols from the script need forward\r\n        // declaration, so just return.\r\n        if (!moduleSymbol)\r\n            return;\r\n        var exports = this.typeChecker.getExportsOfModule(moduleSymbol);\r\n        // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.\r\n        // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires\r\n        // here would cause a change in load order, which is observable (and can lead to errors).\r\n        // Instead, goog.forwardDeclare types, which allows using them in type annotations without\r\n        // causing a load. See below for the exception to the rule.\r\n        this.emit(\"\\nconst \" + forwardDeclarePrefix + \" = goog.forwardDeclare(\\\"\" + moduleNamespace + \"\\\");\");\r\n        var hasValues = exports.some(function (e) { return (e.flags & ts.SymbolFlags.Value) !== 0; });\r\n        if (!hasValues) {\r\n            // Closure Compiler's toolchain will drop files that are never goog.require'd *before* type\r\n            // checking (e.g. when using --closure_entry_point or similar tools). This causes errors\r\n            // complaining about values not matching 'NoResolvedType', or modules not having a certain\r\n            // member.\r\n            // To fix, explicitly goog.require() modules that only export types. This should usually not\r\n            // cause breakages due to load order (as no symbols are accessible from the module - though\r\n            // contrived code could observe changes in side effects).\r\n            // This is a heuristic - if the module exports some values, but those are never imported,\r\n            // the file will still end up not being imported. Hopefully modules that export values are\r\n            // imported for their value in some place.\r\n            this.emit(\"\\ngoog.require(\\\"\" + moduleNamespace + \"\\\"); // force type-only module to be loaded\");\r\n        }\r\n        for (var _i = 0, exportedSymbols_1 = exportedSymbols; _i < exportedSymbols_1.length; _i++) {\r\n            var exp = exportedSymbols_1[_i];\r\n            if (exp.sym.flags & ts.SymbolFlags.Alias)\r\n                exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);\r\n            // goog: imports don't actually use the .default property that TS thinks they have.\r\n            var qualifiedName = nsImport && isDefaultImport ? forwardDeclarePrefix :\r\n                forwardDeclarePrefix + '.' + exp.sym.name;\r\n            this.symbolsToAliasedNames.set(exp.sym, qualifiedName);\r\n        }\r\n    };\r\n    Annotator.prototype.visitClassDeclaration = function (classDecl) {\r\n        this.addSourceMapping(classDecl);\r\n        var oldDecoratorConverter = this.currentDecoratorConverter;\r\n        this.currentDecoratorConverter =\r\n            new decorator.DecoratorClassVisitor(this.typeChecker, this, classDecl, this.importedNames);\r\n        var docTags = this.getJSDoc(classDecl) || [];\r\n        if (hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {\r\n            docTags.push({ tagName: 'abstract' });\r\n        }\r\n        if (!this.host.untyped) {\r\n            this.maybeAddTemplateClause(docTags, classDecl);\r\n            this.maybeAddHeritageClauses(docTags, classDecl);\r\n        }\r\n        this.emit('\\n');\r\n        if (docTags.length > 0)\r\n            this.emit(jsdoc.toString(docTags));\r\n        decorator.visitClassContentIncludingDecorators(classDecl, this, this.currentDecoratorConverter);\r\n        this.emitTypeAnnotationsHelper(classDecl);\r\n        this.currentDecoratorConverter = oldDecoratorConverter;\r\n        return true;\r\n    };\r\n    Annotator.prototype.emitInterface = function (iface) {\r\n        // If this symbol is both a type and a value, we cannot emit both into Closure's\r\n        // single namespace.\r\n        var sym = this.mustGetSymbolAtLocation(iface.name);\r\n        if (sym.flags & ts.SymbolFlags.Value)\r\n            return;\r\n        var docTags = this.getJSDoc(iface) || [];\r\n        docTags.push({ tagName: 'record' });\r\n        if (!this.host.untyped) {\r\n            this.maybeAddTemplateClause(docTags, iface);\r\n            this.maybeAddHeritageClauses(docTags, iface);\r\n        }\r\n        this.emit('\\n');\r\n        this.emit(jsdoc.toString(docTags));\r\n        if (hasModifierFlag(iface, ts.ModifierFlags.Export))\r\n            this.emit('export ');\r\n        var name = rewriter_1.getIdentifierText(iface.name);\r\n        this.emit(\"function \" + name + \"() {}\\n\");\r\n        this.emit(\"\\n\\nfunction \" + name + \"_tsickle_Closure_declarations() {\\n\");\r\n        var memberNamespace = [name, 'prototype'];\r\n        for (var _i = 0, _a = iface.members; _i < _a.length; _i++) {\r\n            var elem = _a[_i];\r\n            var isOptional = elem.questionToken != null;\r\n            this.visitProperty(memberNamespace, elem, isOptional);\r\n        }\r\n        this.emit(\"}\\n\");\r\n    };\r\n    /**\r\n     * emitTypeAnnotationsHelper produces a _tsickle_typeAnnotationsHelper() where\r\n     * none existed in the original source. It's necessary in the case where\r\n     * TypeScript syntax specifies there are additional properties on the class,\r\n     * because to declare these in Closure you must declare these in a method\r\n     * somewhere.\r\n     */\r\n    Annotator.prototype.emitTypeAnnotationsHelper = function (classDecl) {\r\n        var _this = this;\r\n        // Gather parameter properties from the constructor, if it exists.\r\n        var ctors = [];\r\n        var paramProps = [];\r\n        var nonStaticProps = [];\r\n        var staticProps = [];\r\n        var abstractMethods = [];\r\n        for (var _i = 0, _a = classDecl.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            if (member.kind === ts.SyntaxKind.Constructor) {\r\n                ctors.push(member);\r\n            }\r\n            else if (member.kind === ts.SyntaxKind.PropertyDeclaration) {\r\n                var prop = member;\r\n                var isStatic = hasModifierFlag(prop, ts.ModifierFlags.Static);\r\n                if (isStatic) {\r\n                    staticProps.push(prop);\r\n                }\r\n                else {\r\n                    nonStaticProps.push(prop);\r\n                }\r\n            }\r\n            else if (hasModifierFlag(member, ts.ModifierFlags.Abstract) &&\r\n                (member.kind === ts.SyntaxKind.MethodDeclaration ||\r\n                    member.kind === ts.SyntaxKind.GetAccessor ||\r\n                    member.kind === ts.SyntaxKind.SetAccessor)) {\r\n                abstractMethods.push(member);\r\n            }\r\n        }\r\n        if (ctors.length > 0) {\r\n            var ctor = ctors[0];\r\n            paramProps = ctor.parameters.filter(function (p) { return hasModifierFlag(p, FIELD_DECLARATION_MODIFIERS); });\r\n        }\r\n        if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&\r\n            abstractMethods.length === 0 &&\r\n            !(this.currentDecoratorConverter && this.currentDecoratorConverter.foundDecorators())) {\r\n            // There are no members so we don't need to emit any type\r\n            // annotations helper.\r\n            return;\r\n        }\r\n        if (!classDecl.name)\r\n            return;\r\n        var className = rewriter_1.getIdentifierText(classDecl.name);\r\n        this.emit(\"\\n\\nfunction \" + className + \"_tsickle_Closure_declarations() {\\n\");\r\n        if (this.currentDecoratorConverter) {\r\n            this.currentDecoratorConverter.emitMetadataTypeAnnotationsHelpers();\r\n        }\r\n        staticProps.forEach(function (p) { return _this.visitProperty([className], p); });\r\n        var memberNamespace = [className, 'prototype'];\r\n        nonStaticProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });\r\n        paramProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });\r\n        for (var _b = 0, abstractMethods_1 = abstractMethods; _b < abstractMethods_1.length; _b++) {\r\n            var fnDecl = abstractMethods_1[_b];\r\n            var name_4 = this.propertyName(fnDecl);\r\n            if (!name_4) {\r\n                this.error(fnDecl, 'anonymous abstract function');\r\n                continue;\r\n            }\r\n            var tags = decorators_1.hasExportingDecorator(fnDecl, this.typeChecker) ? [{ tagName: 'export' }] : [];\r\n            var paramNames = this.emitFunctionType([fnDecl], tags);\r\n            // memberNamespace because abstract methods cannot be static in TypeScript.\r\n            this.emit(memberNamespace.join('.') + \".\" + name_4 + \" = function(\" + paramNames.join(', ') + \") {};\\n\");\r\n        }\r\n        this.emit(\"}\\n\");\r\n    };\r\n    Annotator.prototype.propertyName = function (prop) {\r\n        if (!prop.name)\r\n            return null;\r\n        switch (prop.name.kind) {\r\n            case ts.SyntaxKind.Identifier:\r\n                return rewriter_1.getIdentifierText(prop.name);\r\n            case ts.SyntaxKind.StringLiteral:\r\n                // E.g. interface Foo { 'bar': number; }\r\n                // If 'bar' is a name that is not valid in Closure then there's nothing we can do.\r\n                var text = prop.name.text;\r\n                if (!isValidClosurePropertyName(text))\r\n                    return null;\r\n                return text;\r\n            default:\r\n                return null;\r\n        }\r\n    };\r\n    /**\r\n     * @param optional If true, property is optional (e.g. written \"foo?: string\").\r\n     */\r\n    Annotator.prototype.visitProperty = function (namespace, prop, optional) {\r\n        if (optional === void 0) { optional = false; }\r\n        var name = this.propertyName(prop);\r\n        if (!name) {\r\n            this.emit(\"/* TODO: handle strange member:\\n\" + this.escapeForComment(prop.getText()) + \"\\n*/\\n\");\r\n            return;\r\n        }\r\n        var type = this.typeToClosure(prop);\r\n        // When a property is optional, e.g.\r\n        //   foo?: string;\r\n        // Then the TypeScript type of the property is string|undefined, the\r\n        // typeToClosure translation handles it correctly, and string|undefined is\r\n        // how you write an optional property in Closure.\r\n        //\r\n        // But in the special case of an optional property with type any:\r\n        //   foo?: any;\r\n        // The TypeScript type of the property is just \"any\" (because any includes\r\n        // undefined as well) so our default translation of the type is just \"?\".\r\n        // To mark the property as optional in Closure it must have \"|undefined\",\r\n        // so the Closure type must be ?|undefined.\r\n        if (optional && type === '?')\r\n            type += '|undefined';\r\n        var tags = this.getJSDoc(prop) || [];\r\n        tags.push({ tagName: 'type', type: type });\r\n        if (decorators_1.hasExportingDecorator(prop, this.typeChecker)) {\r\n            tags.push({ tagName: 'export' });\r\n        }\r\n        // Avoid printing annotations that can conflict with @type\r\n        // This avoids Closure's error \"type annotation incompatible with other annotations\"\r\n        this.emit(jsdoc.toString(tags, new Set(['param', 'return'])));\r\n        namespace = namespace.concat([name]);\r\n        this.emit(namespace.join('.') + \";\\n\");\r\n    };\r\n    Annotator.prototype.visitTypeAlias = function (node) {\r\n        if (this.host.untyped)\r\n            return;\r\n        // If the type is also defined as a value, skip emitting it. Closure collapses type & value\r\n        // namespaces, the two emits would conflict if tsickle emitted both.\r\n        var sym = this.mustGetSymbolAtLocation(node.name);\r\n        if (sym.flags & ts.SymbolFlags.Value)\r\n            return;\r\n        // Write a Closure typedef, which involves an unused \"var\" declaration.\r\n        // Note: in the case of an export, we cannot emit a literal \"var\" because\r\n        // TypeScript drops exports that are never assigned to (and Closure\r\n        // requires us to not assign to typedef exports).  Instead, emit the\r\n        // \"exports.foo;\" line directly in that case.\r\n        this.emit(\"\\n/** @typedef {\" + this.typeToClosure(node) + \"} */\\n\");\r\n        if (hasModifierFlag(node, ts.ModifierFlags.Export)) {\r\n            this.emit('exports.');\r\n        }\r\n        else {\r\n            this.emit('var ');\r\n        }\r\n        this.emit(node.name.getText() + \";\\n\");\r\n    };\r\n    /**\r\n     * getEnumType computes the Closure type of an enum, by iterating through the members\r\n     * and gathering their types.\r\n     */\r\n    Annotator.prototype.getEnumType = function (enumDecl) {\r\n        var hasNumber = false;\r\n        var hasString = false;\r\n        for (var _i = 0, _a = enumDecl.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            if (member.initializer) {\r\n                var type = this.typeChecker.getTypeAtLocation(member.initializer);\r\n                // Note: checking against 'NumberLike' instead of just 'Number' means this code\r\n                // handles both\r\n                //   MEMBER = 3,  // TypeFlags.NumberLiteral\r\n                // and\r\n                //   MEMBER = someFunction(),  // TypeFlags.Number\r\n                if (type.flags & ts.TypeFlags.NumberLike) {\r\n                    hasNumber = true;\r\n                }\r\n                else if (type.flags & ts.TypeFlags.StringLike) {\r\n                    hasString = true;\r\n                }\r\n                else {\r\n                    // Enum contains something other than a string or a number; bail.\r\n                    return '?';\r\n                }\r\n            }\r\n            else {\r\n                // Members without initializers default to numeric.\r\n                hasNumber = true;\r\n            }\r\n        }\r\n        if (hasNumber && hasString) {\r\n            return 'number|string';\r\n        }\r\n        else if (hasNumber) {\r\n            return 'number';\r\n        }\r\n        else if (hasString) {\r\n            return 'string';\r\n        }\r\n        else {\r\n            // Perhaps an empty enum?\r\n            return '?';\r\n        }\r\n    };\r\n    /**\r\n     * Processes an EnumDeclaration into a Closure type. Always emits a Closure type, even in untyped\r\n     * mode, as that should be harmless (it only ever uses the number type).\r\n     */\r\n    Annotator.prototype.processEnum = function (node) {\r\n        // Emit the enum declaration, which looks like:\r\n        //   /** @enum {number} */\r\n        //   const Foo = {BAR: 0, BAZ: 1, ...};\r\n        //   export {Foo};  // even if originally exported on one line.\r\n        // This declares an enum type for Closure Compiler (and Closure JS users of this TS code).\r\n        // Splitting the enum into declaration and export is required so that local references to the\r\n        // type resolve (\"@type {Foo}\").\r\n        this.emit('\\n');\r\n        var name = node.name.getText();\r\n        var enumType = this.getEnumType(node);\r\n        this.emit(\"/** @enum {\" + enumType + \"} */\\n\");\r\n        this.emit(\"const \" + name + \": DontTypeCheckMe = {\");\r\n        // Emit enum values ('BAR: 0,').\r\n        var enumIndex = 0;\r\n        for (var _i = 0, _a = node.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            var memberName = member.name.getText();\r\n            // Emit any comments and leading whitespace on the enum value definition.\r\n            this.writeLeadingTrivia(member);\r\n            this.emit(memberName + \": \");\r\n            if (member.initializer) {\r\n                var enumConstValue = this.typeChecker.getConstantValue(member);\r\n                if (typeof enumConstValue === 'number') {\r\n                    enumIndex = enumConstValue + 1;\r\n                    this.emit(enumConstValue.toString());\r\n                }\r\n                else {\r\n                    // Non-numeric enum value (string or an expression).\r\n                    // Emit this initializer expression as-is.\r\n                    // Note: if the member's initializer expression refers to another\r\n                    // value within the enum (e.g. something like\r\n                    //   enum Foo {\r\n                    //     Field1,\r\n                    //     Field2 = Field1 + something(),\r\n                    //   }\r\n                    // Then when we emit the initializer we produce invalid code because\r\n                    // on the Closure side the reference to Field1 has to be namespaced,\r\n                    // e.g. written \"Foo.Field1 + something()\".\r\n                    // Hopefully this doesn't come up often -- if the enum instead has\r\n                    // something like\r\n                    //     Field2 = Field1 + 3,\r\n                    // then it's still a constant expression and we inline the constant\r\n                    // value in the above branch of this \"if\" statement.\r\n                    this.visit(member.initializer);\r\n                }\r\n            }\r\n            else {\r\n                this.emit(enumIndex.toString());\r\n                enumIndex++;\r\n            }\r\n            this.emit(',');\r\n        }\r\n        this.emit('};\\n');\r\n        var isExported = hasModifierFlag(node, ts.ModifierFlags.Export);\r\n        if (isExported)\r\n            this.emit(\"export {\" + name + \"};\\n\");\r\n        if (hasModifierFlag(node, ts.ModifierFlags.Const)) {\r\n            // By TypeScript semantics, const enums disappear after TS compilation.\r\n            // We still need to generate the runtime value above to make Closure Compiler's type system\r\n            // happy and allow refering to enums from JS code, but we should at least not emit string\r\n            // value mappings.\r\n            return;\r\n        }\r\n        // Emit the reverse mapping of foo[foo.BAR] = 'BAR'; lines for number enums.\r\n        if (enumType === 'number') {\r\n            for (var _b = 0, _c = node.members; _b < _c.length; _b++) {\r\n                var member = _c[_b];\r\n                var memberName = member.name.getText();\r\n                this.emit(name + \"[\" + name + \".\" + memberName + \"] = \\\"\" + memberName + \"\\\";\\n\");\r\n            }\r\n        }\r\n    };\r\n    return Annotator;\r\n}(ClosureRewriter));\r\n/** ExternsWriter generates Closure externs from TypeScript source. */\r\nvar ExternsWriter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExternsWriter, _super);\r\n    function ExternsWriter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ExternsWriter.prototype.process = function () {\r\n        var _this = this;\r\n        this.findExternRoots().forEach(function (node) { return _this.visit(node); });\r\n        return this.getOutput();\r\n    };\r\n    ExternsWriter.prototype.newTypeTranslator = function (context) {\r\n        var tt = _super.prototype.newTypeTranslator.call(this, context);\r\n        tt.isForExterns = true;\r\n        return tt;\r\n    };\r\n    ExternsWriter.prototype.findExternRoots = function () {\r\n        if (isDtsFileName(this.file.fileName)) {\r\n            return [this.file];\r\n        }\r\n        return this.file.statements.filter(function (stmt) { return hasModifierFlag(stmt, ts.ModifierFlags.Ambient); });\r\n    };\r\n    /** visit is the main entry point.  It generates externs from a ts.Node. */\r\n    ExternsWriter.prototype.visit = function (node, namespace) {\r\n        if (namespace === void 0) { namespace = []; }\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.SourceFile:\r\n                var sourceFile = node;\r\n                for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {\r\n                    var stmt = _a[_i];\r\n                    this.visit(stmt, namespace);\r\n                }\r\n                break;\r\n            case ts.SyntaxKind.ModuleDeclaration:\r\n                var decl = node;\r\n                switch (decl.name.kind) {\r\n                    case ts.SyntaxKind.Identifier:\r\n                        // E.g. \"declare namespace foo {\"\r\n                        var name_5 = rewriter_1.getIdentifierText(decl.name);\r\n                        if (name_5 === 'global') {\r\n                            // E.g. \"declare global { ... }\".  Reset to the outer namespace.\r\n                            namespace = [];\r\n                        }\r\n                        else {\r\n                            if (this.isFirstDeclaration(decl)) {\r\n                                this.emit('/** @const */\\n');\r\n                                this.writeExternsVariable(name_5, namespace, '{}');\r\n                            }\r\n                            namespace = namespace.concat(name_5);\r\n                        }\r\n                        if (decl.body)\r\n                            this.visit(decl.body, namespace);\r\n                        break;\r\n                    case ts.SyntaxKind.StringLiteral:\r\n                        // E.g. \"declare module 'foo' {\" (note the quotes).\r\n                        // We still want to emit externs for this module, but\r\n                        // Closure doesn't really provide a mechanism for\r\n                        // module-scoped externs.  For now, ignore the enclosing\r\n                        // namespace (because this is declaring a top-level module)\r\n                        // and emit into a fake namespace.\r\n                        // Declare the top-level \"tsickle_declare_module\".\r\n                        this.emit('/** @const */\\n');\r\n                        this.writeExternsVariable('tsickle_declare_module', [], '{}');\r\n                        namespace = ['tsickle_declare_module'];\r\n                        // Declare the inner \"tsickle_declare_module.foo\", if it's not\r\n                        // declared already elsewhere.\r\n                        var importName = decl.name.text;\r\n                        this.emit(\"// Derived from: declare module \\\"\" + importName + \"\\\"\\n\");\r\n                        // We also don't care about the actual name of the module (\"foo\"\r\n                        // in the above example), except that we want it to not conflict.\r\n                        importName = importName.replace(/_/, '__').replace(/[^A-Za-z]/g, '_');\r\n                        if (this.isFirstDeclaration(decl)) {\r\n                            this.emit('/** @const */\\n');\r\n                            this.writeExternsVariable(importName, namespace, '{}');\r\n                        }\r\n                        // Declare the contents inside the \"tsickle_declare_module.foo\".\r\n                        if (decl.body)\r\n                            this.visit(decl.body, namespace.concat(importName));\r\n                        break;\r\n                    default:\r\n                        this.errorUnimplementedKind(decl.name, 'externs generation of namespace');\r\n                }\r\n                break;\r\n            case ts.SyntaxKind.ModuleBlock:\r\n                var block = node;\r\n                for (var _b = 0, _c = block.statements; _b < _c.length; _b++) {\r\n                    var stmt = _c[_b];\r\n                    this.visit(stmt, namespace);\r\n                }\r\n                break;\r\n            case ts.SyntaxKind.ClassDeclaration:\r\n            case ts.SyntaxKind.InterfaceDeclaration:\r\n                this.writeExternsType(node, namespace);\r\n                break;\r\n            case ts.SyntaxKind.FunctionDeclaration:\r\n                var fnDecl = node;\r\n                var name_6 = fnDecl.name;\r\n                if (!name_6) {\r\n                    this.error(fnDecl, 'anonymous function in externs');\r\n                    break;\r\n                }\r\n                // Gather up all overloads of this function.\r\n                var sym = this.mustGetSymbolAtLocation(name_6);\r\n                var decls = sym.declarations.filter(function (d) { return d.kind === ts.SyntaxKind.FunctionDeclaration; });\r\n                // Only emit the first declaration of each overloaded function.\r\n                if (fnDecl !== decls[0])\r\n                    break;\r\n                var params = this.emitFunctionType(decls);\r\n                this.writeExternsFunction(name_6, params, namespace);\r\n                break;\r\n            case ts.SyntaxKind.VariableStatement:\r\n                for (var _d = 0, _e = node.declarationList.declarations; _d < _e.length; _d++) {\r\n                    var decl_1 = _e[_d];\r\n                    this.writeExternsVariableDecl(decl_1, namespace);\r\n                }\r\n                break;\r\n            case ts.SyntaxKind.EnumDeclaration:\r\n                this.writeExternsEnum(node, namespace);\r\n                break;\r\n            case ts.SyntaxKind.TypeAliasDeclaration:\r\n                this.writeExternsTypeAlias(node, namespace);\r\n                break;\r\n            default:\r\n                this.emit(\"\\n/* TODO: \" + ts.SyntaxKind[node.kind] + \" in \" + namespace.join('.') + \" */\\n\");\r\n                break;\r\n        }\r\n    };\r\n    /**\r\n     * isFirstDeclaration returns true if decl is the first declaration\r\n     * of its symbol.  E.g. imagine\r\n     *   interface Foo { x: number; }\r\n     *   interface Foo { y: number; }\r\n     * we only want to emit the \"@record\" for Foo on the first one.\r\n     */\r\n    ExternsWriter.prototype.isFirstDeclaration = function (decl) {\r\n        if (!decl.name)\r\n            return true;\r\n        var sym = this.mustGetSymbolAtLocation(decl.name);\r\n        if (!sym.declarations || sym.declarations.length < 2)\r\n            return true;\r\n        return decl === sym.declarations[0];\r\n    };\r\n    ExternsWriter.prototype.writeExternsType = function (decl, namespace) {\r\n        var name = decl.name;\r\n        if (!name) {\r\n            this.error(decl, 'anonymous type in externs');\r\n            return;\r\n        }\r\n        var typeName = namespace.concat([name.getText()]).join('.');\r\n        if (exports.closureExternsBlacklist.indexOf(typeName) >= 0)\r\n            return;\r\n        if (this.isFirstDeclaration(decl)) {\r\n            var paramNames = [];\r\n            var jsdocTags = [];\r\n            var writeJsDoc = true;\r\n            this.maybeAddHeritageClauses(jsdocTags, decl);\r\n            if (decl.kind === ts.SyntaxKind.ClassDeclaration) {\r\n                jsdocTags.push({ tagName: 'constructor' });\r\n                jsdocTags.push({ tagName: 'struct' });\r\n                var ctors = decl\r\n                    .members.filter(function (m) { return m.kind === ts.SyntaxKind.Constructor; });\r\n                if (ctors.length) {\r\n                    writeJsDoc = false;\r\n                    var firstCtor = ctors[0];\r\n                    var ctorTags = [{ tagName: 'constructor' }, { tagName: 'struct' }];\r\n                    if (ctors.length > 1) {\r\n                        paramNames = this.emitFunctionType(ctors, ctorTags);\r\n                    }\r\n                    else {\r\n                        paramNames = this.emitFunctionType([firstCtor], ctorTags);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                jsdocTags.push({ tagName: 'record' });\r\n                jsdocTags.push({ tagName: 'struct' });\r\n            }\r\n            if (writeJsDoc)\r\n                this.emit(jsdoc.toString(jsdocTags));\r\n            this.writeExternsFunction(name, paramNames, namespace);\r\n        }\r\n        // Process everything except (MethodSignature|MethodDeclaration|Constructor)\r\n        var methods = new Map();\r\n        for (var _i = 0, _a = decl.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            switch (member.kind) {\r\n                case ts.SyntaxKind.PropertySignature:\r\n                case ts.SyntaxKind.PropertyDeclaration:\r\n                    var prop = member;\r\n                    if (prop.name.kind === ts.SyntaxKind.Identifier) {\r\n                        this.emitJSDocType(prop);\r\n                        if (hasModifierFlag(prop, ts.ModifierFlags.Static)) {\r\n                            this.emit(\"\\n\" + typeName + \".\" + prop.name.getText() + \";\\n\");\r\n                        }\r\n                        else {\r\n                            this.emit(\"\\n\" + typeName + \".prototype.\" + prop.name.getText() + \";\\n\");\r\n                        }\r\n                        continue;\r\n                    }\r\n                    // TODO: For now property names other than Identifiers are not handled; e.g.\r\n                    //    interface Foo { \"123bar\": number }\r\n                    break;\r\n                case ts.SyntaxKind.MethodSignature:\r\n                case ts.SyntaxKind.MethodDeclaration:\r\n                    var method = member;\r\n                    var isStatic = hasModifierFlag(method, ts.ModifierFlags.Static);\r\n                    var methodSignature = method.name.getText() + \"$$$\" + (isStatic ? 'static' : 'instance');\r\n                    if (methods.has(methodSignature)) {\r\n                        methods.get(methodSignature).push(method);\r\n                    }\r\n                    else {\r\n                        methods.set(methodSignature, [method]);\r\n                    }\r\n                    continue;\r\n                case ts.SyntaxKind.Constructor:\r\n                    continue; // Handled above.\r\n                default:\r\n                    // Members can include things like index signatures, for e.g.\r\n                    //   interface Foo { [key: string]: number; }\r\n                    // For now, just skip it.\r\n                    break;\r\n            }\r\n            // If we get here, the member wasn't handled in the switch statement.\r\n            var memberName = namespace;\r\n            if (member.name) {\r\n                memberName = memberName.concat([member.name.getText()]);\r\n            }\r\n            this.emit(\"\\n/* TODO: \" + ts.SyntaxKind[member.kind] + \": \" + memberName.join('.') + \" */\\n\");\r\n        }\r\n        // Handle method declarations/signatures separately, since we need to deal with overloads.\r\n        for (var _b = 0, _c = Array.from(methods.values()); _b < _c.length; _b++) {\r\n            var methodVariants = _c[_b];\r\n            var firstMethodVariant = methodVariants[0];\r\n            var parameterNames = void 0;\r\n            if (methodVariants.length > 1) {\r\n                parameterNames = this.emitFunctionType(methodVariants);\r\n            }\r\n            else {\r\n                parameterNames = this.emitFunctionType([firstMethodVariant]);\r\n            }\r\n            var methodNamespace = namespace.concat([name.getText()]);\r\n            // If the method is static, don't add the prototype.\r\n            if (!hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {\r\n                methodNamespace.push('prototype');\r\n            }\r\n            this.writeExternsFunction(firstMethodVariant.name, parameterNames, methodNamespace);\r\n        }\r\n    };\r\n    ExternsWriter.prototype.writeExternsVariableDecl = function (decl, namespace) {\r\n        if (decl.name.kind === ts.SyntaxKind.Identifier) {\r\n            var name_7 = rewriter_1.getIdentifierText(decl.name);\r\n            if (exports.closureExternsBlacklist.indexOf(name_7) >= 0)\r\n                return;\r\n            this.emitJSDocType(decl);\r\n            this.emit('\\n');\r\n            this.writeExternsVariable(name_7, namespace);\r\n        }\r\n        else {\r\n            this.errorUnimplementedKind(decl.name, 'externs for variable');\r\n        }\r\n    };\r\n    ExternsWriter.prototype.writeExternsVariable = function (name, namespace, value) {\r\n        var qualifiedName = namespace.concat([name]).join('.');\r\n        if (namespace.length === 0)\r\n            this.emit(\"var \");\r\n        this.emit(qualifiedName);\r\n        if (value)\r\n            this.emit(\" = \" + value);\r\n        this.emit(';\\n');\r\n    };\r\n    ExternsWriter.prototype.writeExternsFunction = function (name, params, namespace) {\r\n        var paramsStr = params.join(', ');\r\n        if (namespace.length > 0) {\r\n            var fqn = namespace.join('.');\r\n            if (name.kind === ts.SyntaxKind.Identifier) {\r\n                fqn += '.'; // computed names include [ ] in their getText() representation.\r\n            }\r\n            fqn += name.getText();\r\n            this.emit(fqn + \" = function(\" + paramsStr + \") {};\\n\");\r\n        }\r\n        else {\r\n            if (name.kind !== ts.SyntaxKind.Identifier) {\r\n                this.error(name, 'Non-namespaced computed name in externs');\r\n            }\r\n            this.emit(\"function \" + name.getText() + \"(\" + paramsStr + \") {}\\n\");\r\n        }\r\n    };\r\n    ExternsWriter.prototype.writeExternsEnum = function (decl, namespace) {\r\n        var name = rewriter_1.getIdentifierText(decl.name);\r\n        this.emit('\\n/** @const */\\n');\r\n        this.writeExternsVariable(name, namespace, '{}');\r\n        namespace = namespace.concat([name]);\r\n        for (var _i = 0, _a = decl.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            var memberName = void 0;\r\n            switch (member.name.kind) {\r\n                case ts.SyntaxKind.Identifier:\r\n                    memberName = rewriter_1.getIdentifierText(member.name);\r\n                    break;\r\n                case ts.SyntaxKind.StringLiteral:\r\n                    var text = member.name.text;\r\n                    if (isValidClosurePropertyName(text))\r\n                        memberName = text;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (!memberName) {\r\n                this.emit(\"\\n/* TODO: \" + ts.SyntaxKind[member.name.kind] + \": \" + member.name.getText() + \" */\\n\");\r\n                continue;\r\n            }\r\n            this.emit('/** @const {number} */\\n');\r\n            this.writeExternsVariable(memberName, namespace);\r\n        }\r\n    };\r\n    ExternsWriter.prototype.writeExternsTypeAlias = function (decl, namespace) {\r\n        this.emit(\"\\n/** @typedef {\" + this.typeToClosure(decl) + \"} */\\n\");\r\n        this.writeExternsVariable(rewriter_1.getIdentifierText(decl.name), namespace);\r\n    };\r\n    return ExternsWriter;\r\n}(ClosureRewriter));\r\nfunction isPolymerBehaviorPropertyInCallExpression(pa) {\r\n    var parentParent = pa.parent && pa.parent.parent;\r\n    if (pa.name.kind !== ts.SyntaxKind.Identifier ||\r\n        pa.name.text !== 'behaviors' || !pa.parent || !pa.parent.parent ||\r\n        pa.parent.parent.kind !== ts.SyntaxKind.CallExpression) {\r\n        return false;\r\n    }\r\n    var expr = parentParent.expression;\r\n    return expr.kind === ts.SyntaxKind.Identifier && expr.text === 'Polymer';\r\n}\r\nfunction annotate(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {\r\n    return new Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper).annotate();\r\n}\r\nexports.annotate = annotate;\r\nfunction writeExterns(typeChecker, file, host) {\r\n    return new ExternsWriter(typeChecker, file, host).process();\r\n}\r\nexports.writeExterns = writeExterns;\r\n/** Concatenate all generated externs definitions together into a string. */\r\nfunction getGeneratedExterns(externs) {\r\n    var allExterns = exports.EXTERNS_HEADER;\r\n    for (var _i = 0, _a = Object.keys(externs); _i < _a.length; _i++) {\r\n        var fileName = _a[_i];\r\n        allExterns += \"// externs from \" + fileName + \":\\n\";\r\n        allExterns += externs[fileName];\r\n    }\r\n    return allExterns;\r\n}\r\nexports.getGeneratedExterns = getGeneratedExterns;\r\nfunction mergeEmitResults(emitResults) {\r\n    var diagnostics = [];\r\n    var emitSkipped = true;\r\n    var emittedFiles = [];\r\n    var externs = {};\r\n    var modulesManifest = new modules_manifest_1.ModulesManifest();\r\n    for (var _i = 0, emitResults_1 = emitResults; _i < emitResults_1.length; _i++) {\r\n        var er = emitResults_1[_i];\r\n        diagnostics.push.apply(diagnostics, er.diagnostics);\r\n        emitSkipped = emitSkipped || er.emitSkipped;\r\n        emittedFiles.push.apply(emittedFiles, er.emittedFiles);\r\n        Object.assign(externs, er.externs);\r\n        modulesManifest.addManifest(er.modulesManifest);\r\n    }\r\n    return { diagnostics: diagnostics, emitSkipped: emitSkipped, emittedFiles: emittedFiles, externs: externs, modulesManifest: modulesManifest };\r\n}\r\nexports.mergeEmitResults = mergeEmitResults;\r\nfunction emitWithTsickle(program, host, tsHost, tsOptions, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {\r\n    if (customTransformers === void 0) { customTransformers = {}; }\r\n    var tsickleDiagnostics = [];\r\n    var typeChecker = program.getTypeChecker();\r\n    var tsickleSourceTransformers = [];\r\n    // add tsickle transformers\r\n    if (host.transformTypesToClosure) {\r\n        // Note: tsickle.annotate can also lower decorators in the same run.\r\n        tsickleSourceTransformers.push(transformer_sourcemap_1.createTransformerFromSourceMap(function (sourceFile, sourceMapper) {\r\n            var _a = annotate(typeChecker, sourceFile, host, tsHost, tsOptions, sourceMapper), output = _a.output, diagnostics = _a.diagnostics;\r\n            tsickleDiagnostics.push.apply(tsickleDiagnostics, diagnostics);\r\n            return output;\r\n        }));\r\n    }\r\n    else if (host.transformDecorators) {\r\n        tsickleSourceTransformers.push(transformer_sourcemap_1.createTransformerFromSourceMap(function (sourceFile, sourceMapper) {\r\n            var _a = decorator.convertDecorators(typeChecker, sourceFile, sourceMapper), output = _a.output, diagnostics = _a.diagnostics;\r\n            tsickleDiagnostics.push.apply(tsickleDiagnostics, diagnostics);\r\n            return output;\r\n        }));\r\n    }\r\n    // // For debugging: transformer that just emits the same text.\r\n    // beforeTsTransformers.push(createTransformer(host, typeChecker, (sourceFile, sourceMapper) => {\r\n    //   sourceMapper.addMapping(sourceFile, {position: 0, line: 0, column: 0}, {position: 0, line: 0,\r\n    //   column: 0}, sourceFile.text.length); return sourceFile.text;\r\n    // }));\r\n    var tsickleTransformers = transformer_util_1.createCustomTransformers({ before: tsickleSourceTransformers });\r\n    var tsTransformers = {\r\n        before: (customTransformers.beforeTsickle || []).concat((tsickleTransformers.before || []).map(function (tf) { return skipTransformForSourceFileIfNeeded(host, tf); }), (customTransformers.beforeTs || [])),\r\n        after: (customTransformers.afterTs || []).concat((tsickleTransformers.after || []).map(function (tf) { return skipTransformForSourceFileIfNeeded(host, tf); }))\r\n    };\r\n    var writeFileDelegate = writeFile || tsHost.writeFile.bind(tsHost);\r\n    var modulesManifest = new modules_manifest_1.ModulesManifest();\r\n    var writeFileImpl = function (fileName, content, writeByteOrderMark, onError, sourceFiles) {\r\n        if (path.extname(fileName) !== '.map') {\r\n            if (tsOptions.inlineSourceMap) {\r\n                content = combineInlineSourceMaps(program, fileName, content);\r\n            }\r\n            else {\r\n                content = source_map_utils_1.removeInlineSourceMap(content);\r\n            }\r\n            content = es5processor.convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content);\r\n        }\r\n        else {\r\n            content = combineSourceMaps(program, fileName, content);\r\n        }\r\n        writeFileDelegate(fileName, content, writeByteOrderMark, onError, sourceFiles);\r\n    };\r\n    var _a = program.emit(targetSourceFile, writeFileImpl, cancellationToken, emitOnlyDtsFiles, tsTransformers), tsDiagnostics = _a.diagnostics, emitSkipped = _a.emitSkipped, emittedFiles = _a.emittedFiles;\r\n    var externs = {};\r\n    if (host.transformTypesToClosure) {\r\n        var sourceFiles = targetSourceFile ? [targetSourceFile] : program.getSourceFiles();\r\n        sourceFiles.forEach(function (sf) {\r\n            if (isDtsFileName(sf.fileName) && host.shouldSkipTsickleProcessing(sf.fileName)) {\r\n                return;\r\n            }\r\n            var _a = writeExterns(typeChecker, sf, host), output = _a.output, diagnostics = _a.diagnostics;\r\n            if (output) {\r\n                externs[sf.fileName] = output;\r\n            }\r\n            if (diagnostics) {\r\n                tsickleDiagnostics.push.apply(tsickleDiagnostics, diagnostics);\r\n            }\r\n        });\r\n    }\r\n    // All diagnostics (including warnings) are treated as errors.\r\n    // If the host decides to ignore warnings, just discard them.\r\n    // Warnings include stuff like \"don't use @type in your jsdoc\"; tsickle\r\n    // warns and then fixes up the code to be Closure-compatible anyway.\r\n    tsickleDiagnostics = tsickleDiagnostics.filter(function (d) { return d.category === ts.DiagnosticCategory.Error ||\r\n        !host.shouldIgnoreWarningsForPath(d.file.fileName); });\r\n    return {\r\n        modulesManifest: modulesManifest,\r\n        emitSkipped: emitSkipped,\r\n        emittedFiles: emittedFiles || [],\r\n        diagnostics: tsDiagnostics.concat(tsickleDiagnostics),\r\n        externs: externs\r\n    };\r\n}\r\nexports.emitWithTsickle = emitWithTsickle;\r\nfunction skipTransformForSourceFileIfNeeded(host, delegateFactory) {\r\n    return function (context) {\r\n        var delegate = delegateFactory(context);\r\n        return function (sourceFile) {\r\n            if (host.shouldSkipTsickleProcessing(sourceFile.fileName)) {\r\n                return sourceFile;\r\n            }\r\n            return delegate(sourceFile);\r\n        };\r\n    };\r\n}\r\nfunction combineInlineSourceMaps(program, filePath, compiledJsWithInlineSourceMap) {\r\n    if (isDtsFileName(filePath)) {\r\n        return compiledJsWithInlineSourceMap;\r\n    }\r\n    var sourceMapJson = source_map_utils_1.extractInlineSourceMap(compiledJsWithInlineSourceMap);\r\n    compiledJsWithInlineSourceMap = source_map_utils_1.removeInlineSourceMap(compiledJsWithInlineSourceMap);\r\n    var composedSourceMap = combineSourceMaps(program, filePath, sourceMapJson);\r\n    return source_map_utils_1.setInlineSourceMap(compiledJsWithInlineSourceMap, composedSourceMap);\r\n}\r\nfunction combineSourceMaps(program, filePath, tscSourceMapText) {\r\n    var tscSourceMap = source_map_utils_1.parseSourceMap(tscSourceMapText);\r\n    if (tscSourceMap.sourcesContent) {\r\n        // strip incoming sourcemaps from the sources in the sourcemap\r\n        // to reduce the size of the sourcemap.\r\n        tscSourceMap.sourcesContent = tscSourceMap.sourcesContent.map(function (content) {\r\n            if (source_map_utils_1.containsInlineSourceMap(content)) {\r\n                content = source_map_utils_1.removeInlineSourceMap(content);\r\n            }\r\n            return content;\r\n        });\r\n    }\r\n    var fileDir = path.dirname(filePath);\r\n    var tscSourceMapGenerator;\r\n    for (var _i = 0, _a = tscSourceMap.sources; _i < _a.length; _i++) {\r\n        var sourceFileName = _a[_i];\r\n        var sourceFile = program.getSourceFile(path.resolve(fileDir, sourceFileName));\r\n        if (!sourceFile || !source_map_utils_1.containsInlineSourceMap(sourceFile.text)) {\r\n            continue;\r\n        }\r\n        var preexistingSourceMapText = source_map_utils_1.extractInlineSourceMap(sourceFile.text);\r\n        if (!tscSourceMapGenerator) {\r\n            tscSourceMapGenerator = source_map_1.SourceMapGenerator.fromSourceMap(new source_map_1.SourceMapConsumer(tscSourceMap));\r\n        }\r\n        tscSourceMapGenerator.applySourceMap(new source_map_1.SourceMapConsumer(source_map_utils_1.parseSourceMap(preexistingSourceMapText, sourceFileName)));\r\n    }\r\n    return tscSourceMapGenerator ? tscSourceMapGenerator.toString() : tscSourceMapText;\r\n}\r\n//# sourceMappingURL=tsickle.js.map","sourceMap":{"version":3,"file":"tsickle.js","sourceRoot":"","sources":["node_modules/tsickle/src/tsickle.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport {RawSourceMap, SourceMapConsumer, SourceMapGenerator} from 'source-map';\nimport * as ts from 'typescript';\n\nimport * as decorator from './decorator-annotator';\nimport {hasExportingDecorator} from './decorators';\nimport * as es5processor from './es5processor';\nimport * as jsdoc from './jsdoc';\nimport {ModulesManifest} from './modules_manifest';\nimport {getIdentifierText, Rewriter, unescapeName} from './rewriter';\nimport {containsInlineSourceMap, extractInlineSourceMap, parseSourceMap, removeInlineSourceMap, setInlineSourceMap, SourceMapper, SourcePosition} from './source_map_utils';\nimport {createTransformerFromSourceMap} from './transformer_sourcemap';\nimport {createCustomTransformers} from './transformer_util';\nimport * as typeTranslator from './type-translator';\nimport {toArray} from './util';\n\nexport {convertDecorators} from './decorator-annotator';\nexport {FileMap, ModulesManifest} from './modules_manifest';\n\nexport interface AnnotatorHost {\n  /**\n   * If provided a function that logs an internal warning.\n   * These warnings are not actionable by an end user and should be hidden\n   * by default.\n   */\n  logWarning?: (warning: ts.Diagnostic) => void;\n  pathToModuleName: (context: string, importPath: string) => string;\n  /**\n   * If true, convert every type to the Closure {?} type, which means\n   * \"don't check types\".\n   */\n  untyped?: boolean;\n  /** If provided, a set of paths whose types should always generate as {?}. */\n  typeBlackListPaths?: Set<string>;\n  /**\n   * Convert shorthand \"/index\" imports to full path (include the \"/index\").\n   * Annotation will be slower because every import must be resolved.\n   */\n  convertIndexImportShorthand?: boolean;\n}\n\n/**\n * The header to be used in generated externs.  This is not included in the\n * output of annotate() because annotate() works one file at a time, and\n * typically you create one externs file from the entire compilation unit.\n */\nexport const EXTERNS_HEADER = `/**\n * @externs\n * @suppress {duplicate,checkTypes}\n */\n// NOTE: generated by tsickle, do not edit.\n`;\n\n/**\n * Symbols that are already declared as externs in Closure, that should\n * be avoided by tsickle's \"declare ...\" => externs.js conversion.\n */\nexport let closureExternsBlacklist: string[] = [\n  'exports',\n  'global',\n  'module',\n  // ErrorConstructor is the interface of the Error object itself.\n  // tsickle detects that this is part of the TypeScript standard library\n  // and assumes it's part of the Closure standard library, but this\n  // assumption is wrong for ErrorConstructor.  To properly handle this\n  // we'd somehow need to map methods defined on the ErrorConstructor\n  // interface into properties on Closure's Error object, but for now it's\n  // simpler to just blacklist it.\n  'ErrorConstructor',\n  'Symbol',\n  'WorkerGlobalScope',\n];\n\nexport function formatDiagnostics(diags: ts.Diagnostic[]): string {\n  return diags\n      .map((d) => {\n        let res = ts.DiagnosticCategory[d.category];\n        if (d.file) {\n          res += ' at ' + d.file.fileName + ':';\n          if (d.start) {\n            const {line, character} = d.file.getLineAndCharacterOfPosition(d.start);\n            res += (line + 1) + ':' + (character + 1) + ':';\n          }\n        }\n        res += ' ' + ts.flattenDiagnosticMessageText(d.messageText, '\\n');\n        return res;\n      })\n      .join('\\n');\n}\n\n/** @return true if node has the specified modifier flag set. */\nexport function hasModifierFlag(node: ts.Node, flag: ts.ModifierFlags): boolean {\n  return (ts.getCombinedModifierFlags(node) & flag) !== 0;\n}\n\n/** @return true if node has the specified modifier flag set. */\nfunction isAmbient(node: ts.Node): boolean {\n  let current: ts.Node|undefined = node;\n  while (current) {\n    if (hasModifierFlag(current, ts.ModifierFlags.Ambient)) return true;\n    current = current.parent;\n  }\n  return false;\n}\n\n/**\n * TypeScript allows you to write identifiers quoted, like:\n *   interface Foo {\n *     'bar': string;\n *     'complex name': string;\n *   }\n *   Foo.bar;  // ok\n *   Foo['bar']  // ok\n *   Foo['complex name']  // ok\n *\n * In Closure-land, we want identify that the legal name 'bar' can become an\n * ordinary field, but we need to skip strings like 'complex name'.\n */\nfunction isValidClosurePropertyName(name: string): boolean {\n  // In local experimentation, it appears that reserved words like 'var' and\n  // 'if' are legal JS and still accepted by Closure.\n  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);\n}\n\nexport function isDtsFileName(fileName: string): boolean {\n  return /\\.d\\.ts$/.test(fileName);\n}\n\n/** Returns the Closure name of a function parameter, special-casing destructuring. */\nfunction getParameterName(param: ts.ParameterDeclaration, index: number): string {\n  switch (param.name.kind) {\n    case ts.SyntaxKind.Identifier:\n      let name = getIdentifierText(param.name as ts.Identifier);\n      // TypeScript allows parameters named \"arguments\", but Closure\n      // disallows this, even in externs.\n      if (name === 'arguments') name = 'tsickle_arguments';\n      return name;\n    case ts.SyntaxKind.ArrayBindingPattern:\n    case ts.SyntaxKind.ObjectBindingPattern:\n      // Closure crashes if you put a binding pattern in the externs.\n      // Avoid this by just generating an unused name; the name is\n      // ignored anyway.\n      return `__${index}`;\n    default:\n      // The above list of kinds is exhaustive.  param.name is 'never' at this point.\n      const paramName = param.name as ts.Node;\n      throw new Error(`unhandled function parameter kind: ${ts.SyntaxKind[paramName.kind]}`);\n  }\n}\n\n/** Flags that declare a field of the same name if set on a ctor parameter. */\nconst FIELD_DECLARATION_MODIFIERS: ts.ModifierFlags = ts.ModifierFlags.Private |\n    ts.ModifierFlags.Protected | ts.ModifierFlags.Public | ts.ModifierFlags.Readonly;\n\n/**\n * A symbol combined with its name in the local file. Symbols can be renamed on import or export\n * (`import {Foo as Bar}`).\n */\ninterface NamedSymbol {\n  /** The local name of the symbol (named `Bar` in the example above). */\n  name: string;\n  /** The symbol (named `Foo` in the example above). */\n  sym: ts.Symbol;\n}\n\n/**\n * A Rewriter subclass that adds Tsickle-specific (Closure translation) functionality.\n *\n * One Rewriter subclass manages .ts => .ts+Closure translation.\n * Another Rewriter subclass manages .ts => externs translation.\n */\nclass ClosureRewriter extends Rewriter {\n  /**\n   * A mapping of aliases for symbols in the current file, used when emitting types.\n   * TypeScript emits imported symbols with unpredictable prefixes. To generate correct type\n   * annotations, tsickle creates its own aliases for types, and registers them in this map (see\n   * `emitImportDeclaration` and `forwardDeclare()` below). The aliases are then used when emitting\n   * types.\n   */\n  symbolsToAliasedNames = new Map<ts.Symbol, string>();\n\n  constructor(\n      protected typeChecker: ts.TypeChecker, file: ts.SourceFile, protected host: AnnotatorHost,\n      sourceMapper?: SourceMapper) {\n    super(file, sourceMapper);\n  }\n\n  /**\n   * Get the ts.Symbol at a location or throw.\n   * The TypeScript API can return undefined when fetching a symbol, but\n   * in many contexts we know it won't (e.g. our input is already type-checked).\n   */\n  mustGetSymbolAtLocation(node: ts.Node): ts.Symbol {\n    const sym = this.typeChecker.getSymbolAtLocation(node);\n    if (!sym) throw new Error('no symbol');\n    return sym;\n  }\n\n  /**\n   * Handles emittng the jsdoc for methods, including overloads.\n   * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.\n   * - Total number of parameters will be the maximum count found across all variants.\n   * - Different names at the same parameter index will be joined with \"_or_\"\n   * - Variable args (...type[] in TypeScript) will be output as \"...type\",\n   *    except if found at the same index as another argument.\n   * @param  fnDecls Pass > 1 declaration for overloads of same name\n   * @return The list of parameter names that should be used to emit the actual\n   *    function statement; for overloads, name will have been merged.\n   */\n  emitFunctionType(fnDecls: ts.SignatureDeclaration[], extraTags: jsdoc.Tag[] = []): string[] {\n    const typeChecker = this.typeChecker;\n    const newDoc = extraTags;\n    const lens = fnDecls.map(fnDecl => fnDecl.parameters.length);\n    const minArgsCount = Math.min(...lens);\n    const maxArgsCount = Math.max(...lens);\n    const isConstructor = fnDecls.find(d => d.kind === ts.SyntaxKind.Constructor) !== undefined;\n    // For each parameter index i, paramTags[i] is an array of parameters\n    // that can be found at index i.  E.g.\n    //    function foo(x: string)\n    //    function foo(y: number, z: string)\n    // then paramTags[0] = [info about x, info about y].\n    const paramTags: jsdoc.Tag[][] = [];\n    const returnTags: jsdoc.Tag[] = [];\n    const typeParameterNames = new Set<string>();\n\n    for (const fnDecl of fnDecls) {\n      // Construct the JSDoc comment by reading the existing JSDoc, if\n      // any, and merging it with the known types of the function\n      // parameters and return type.\n      const docTags = this.getJSDoc(fnDecl) || [];\n\n      // Copy all the tags other than @param/@return into the new\n      // JSDoc without any change; @param/@return are handled specially.\n      // TODO: there may be problems if an annotation doesn't apply to all overloads;\n      // is it worth checking for this and erroring?\n      for (const tag of docTags) {\n        if (tag.tagName === 'param' || tag.tagName === 'return') continue;\n        newDoc.push(tag);\n      }\n\n      // Add @abstract on \"abstract\" declarations.\n      if (hasModifierFlag(fnDecl, ts.ModifierFlags.Abstract)) {\n        newDoc.push({tagName: 'abstract'});\n      }\n\n      // Add any @template tags.\n      // Multiple declarations with the same template variable names should work:\n      // the declarations get turned into union types, and Closure Compiler will need\n      // to find a union where all type arguments are satisfied.\n      if (fnDecl.typeParameters) {\n        for (const tp of fnDecl.typeParameters) {\n          typeParameterNames.add(getIdentifierText(tp.name));\n        }\n      }\n      // Merge the parameters into a single list of merged names and list of types\n      const sig = typeChecker.getSignatureFromDeclaration(fnDecl);\n      if (!sig) throw new Error(`invalid signature ${fnDecl.name}`);\n      for (let i = 0; i < sig.declaration.parameters.length; i++) {\n        const paramNode = sig.declaration.parameters[i];\n\n        const name = getParameterName(paramNode, i);\n        const isThisParam = name === 'this';\n\n        const newTag: jsdoc.Tag = {\n          tagName: isThisParam ? 'this' : 'param',\n          optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,\n          parameterName: isThisParam ? undefined : name,\n        };\n\n        let type = typeChecker.getTypeAtLocation(paramNode);\n        if (paramNode.dotDotDotToken !== undefined) {\n          newTag.restParam = true;\n          // In TypeScript you write \"...x: number[]\", but in Closure\n          // you don't write the array: \"@param {...number} x\".  Unwrap\n          // the Array<> wrapper.\n          const typeRef = type as ts.TypeReference;\n          if (!typeRef.typeArguments) throw new Error('invalid rest param');\n          type = typeRef.typeArguments![0];\n        }\n        newTag.type = this.typeToClosure(fnDecl, type);\n\n        for (const {tagName, parameterName, text} of docTags) {\n          if (tagName === 'param' && parameterName === newTag.parameterName) {\n            newTag.text = text;\n            break;\n          }\n        }\n        if (!paramTags[i]) paramTags.push([]);\n        paramTags[i].push(newTag);\n      }\n\n      // Return type.\n      if (!isConstructor) {\n        const retType = typeChecker.getReturnTypeOfSignature(sig);\n        const retTypeString: string = this.typeToClosure(fnDecl, retType);\n        let returnDoc: string|undefined;\n        for (const {tagName, text} of docTags) {\n          if (tagName === 'return') {\n            returnDoc = text;\n            break;\n          }\n        }\n        returnTags.push({\n          tagName: 'return',\n          type: retTypeString,\n          text: returnDoc,\n        });\n      }\n    }\n\n    if (typeParameterNames.size > 0) {\n      newDoc.push({tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ')});\n    }\n\n    // Merge the JSDoc tags for each overloaded parameter.\n    // Ensure each parameter has a unique name; the merging process can otherwise\n    // accidentally generate the same parameter name twice.\n    const paramNames = new Set();\n    let foundOptional = false;\n    for (let i = 0; i < maxArgsCount; i++) {\n      const paramTag = jsdoc.merge(paramTags[i]);\n      if (paramNames.has(paramTag.parameterName)) {\n        paramTag.parameterName += i.toString();\n      }\n      paramNames.add(paramTag.parameterName);\n      // If the tag is optional, mark parameters following optional as optional,\n      // even if they are not, since Closure restricts this, see\n      // https://github.com/google/closure-compiler/issues/2314\n      if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {\n        foundOptional = true;\n        paramTag.optional = true;\n      }\n      newDoc.push(paramTag);\n      if (paramTag.restParam) {\n        // Cannot have any parameters after a rest param.\n        // Just dump the remaining parameters.\n        break;\n      }\n    }\n\n    // Merge the JSDoc tags for each overloaded return.\n    if (!isConstructor) {\n      newDoc.push(jsdoc.merge(returnTags));\n    }\n\n    this.emit('\\n' + jsdoc.toString(newDoc));\n    return newDoc.filter(t => t.tagName === 'param').map(t => t.parameterName!);\n  }\n\n  /**\n   * Returns null if there is no existing comment.\n   */\n  getJSDoc(node: ts.Node): jsdoc.Tag[]|null {\n    const text = node.getFullText();\n    const comments = ts.getLeadingCommentRanges(text, 0);\n\n    if (!comments || comments.length === 0) return null;\n\n    // We need to search backwards for the first JSDoc comment to avoid ignoring such when another\n    // code-level comment is between that comment and the function declaration (see\n    // testfiles/doc_params for an example).\n    let docRelativePos = 0;\n    let parsed: jsdoc.ParsedJSDocComment|null = null;\n    for (let i = comments.length - 1; i >= 0; i--) {\n      const {pos, end} = comments[i];\n      // end is relative within node.getFullText(), add getFullStart to obtain coordinates that are\n      // comparable to node positions.\n      const docRelativeEnd = end + node.getFullStart();\n      if (docRelativeEnd <= this.file.getStart() &&\n          this.file.text.substring(docRelativeEnd).startsWith('\\n\\n')) {\n        // This comment is at the very beginning of the file and there's an empty line between the\n        // comment and this node. That means we should treat it as a file-level comment, not\n        // attached to this code node.\n        return null;\n      }\n\n      const comment = text.substring(pos, end);\n      parsed = jsdoc.parse(comment);\n      if (parsed) {\n        docRelativePos = node.getFullStart() + pos;\n        break;\n      }\n    }\n\n    if (!parsed) return null;\n\n    if (parsed.warnings) {\n      const start = docRelativePos;\n      this.diagnostics.push({\n        file: this.file,\n        start,\n        length: node.getStart() - start,\n        messageText: parsed.warnings.join('\\n'),\n        category: ts.DiagnosticCategory.Warning,\n        code: 0,\n      });\n    }\n    return parsed.tags;\n  }\n\n  maybeAddTemplateClause(docTags: jsdoc.Tag[], decl: HasTypeParameters) {\n    if (!decl.typeParameters) return;\n    // Closure does not support template constraints (T extends X).\n    docTags.push({\n      tagName: 'template',\n      text: decl.typeParameters\n                .map(tp => {\n                  if (tp.constraint) {\n                    this.emit('\\n// unsupported: template constraints.');\n                  }\n                  return getIdentifierText(tp.name);\n                })\n                .join(', ')\n    });\n  }\n\n  maybeAddHeritageClauses(\n      docTags: jsdoc.Tag[], decl: ts.ClassLikeDeclaration|ts.InterfaceDeclaration) {\n    if (!decl.heritageClauses) return;\n    for (const heritage of decl.heritageClauses!) {\n      if (!heritage.types) continue;\n      const isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;\n      if (isClass && heritage.token !== ts.SyntaxKind.ImplementsKeyword && !isAmbient(decl)) {\n        // If a class has \"extends Foo\", that is preserved in the ES6 output\n        // and we don't need to do anything.  But if it has \"implements Foo\",\n        // that is a TS-specific thing and we need to translate it to the\n        // the Closure \"@implements {Foo}\".\n        // However for ambient declarations, we only emit externs, and in those we do need to\n        // add \"@extends {Foo}\" as they use ES5 syntax.\n        continue;\n      }\n      for (const impl of heritage.types) {\n        let tagName = decl.kind === ts.SyntaxKind.InterfaceDeclaration ? 'extends' : 'implements';\n\n        // We can only @implements an interface, not a class.\n        // But it's fine to translate TS \"implements Class\" into Closure\n        // \"@extends {Class}\" because this is just a type hint.\n        const typeChecker = this.typeChecker;\n        const sym = this.mustGetSymbolAtLocation(impl.expression);\n        let alias: ts.Symbol = sym;\n        if (sym.flags & ts.SymbolFlags.TypeAlias) {\n          // It's implementing a type alias.  Follow the type alias back\n          // to the original symbol to check whether it's a type or a value.\n          const type = this.typeChecker.getDeclaredTypeOfSymbol(sym);\n          if (!type.symbol) {\n            // It's not clear when this can happen, but if it does all we\n            // do is fail to emit the @implements, which isn't so harmful.\n            continue;\n          }\n          alias = type.symbol;\n        }\n        if (alias.flags & ts.SymbolFlags.Alias) {\n          alias = typeChecker.getAliasedSymbol(alias);\n        }\n        const typeTranslator = this.newTypeTranslator(impl.expression);\n        if (typeTranslator.isBlackListed(alias)) {\n          continue;\n        }\n        if (alias.flags & ts.SymbolFlags.Class) {\n          if (!isClass) {\n            // Only classes can extend classes in TS. Ignoring the heritage clause should be safe,\n            // as interfaces are @record anyway, so should prevent property disambiguation.\n\n            // Problem: validate that methods are there?\n            continue;\n          }\n          tagName = 'extends';\n        } else if (alias.flags & ts.SymbolFlags.Value) {\n          // If the symbol was already in the value namespace, then it will\n          // not be a type in the Closure output (because Closure collapses\n          // the type and value namespaces).  Just ignore the implements.\n          continue;\n        }\n        // typeToClosure includes nullability modifiers, so call symbolToString directly here.\n        docTags.push({tagName, type: typeTranslator.symbolToString(sym, true)});\n      }\n    }\n  }\n\n  /** Emits a type annotation in JSDoc, or {?} if the type is unavailable. */\n  emitJSDocType(node: ts.Node, additionalDocTag?: string, type?: ts.Type) {\n    this.emit(' /**');\n    if (additionalDocTag) {\n      this.emit(' ' + additionalDocTag);\n    }\n    this.emit(` @type {${this.typeToClosure(node, type)}} */`);\n  }\n\n  /**\n   * Convert a TypeScript ts.Type into the equivalent Closure type.\n   *\n   * @param context The ts.Node containing the type reference; used for resolving symbols\n   *     in context.\n   * @param type The type to translate; if not provided, the Node's type will be used.\n   */\n  typeToClosure(context: ts.Node, type?: ts.Type): string {\n    if (this.host.untyped) {\n      return '?';\n    }\n\n    const typeChecker = this.typeChecker;\n    if (!type) {\n      type = typeChecker.getTypeAtLocation(context);\n    }\n    return this.newTypeTranslator(context).translate(type);\n  }\n\n  newTypeTranslator(context: ts.Node) {\n    const translator = new typeTranslator.TypeTranslator(\n        this.typeChecker, context, this.host.typeBlackListPaths, this.symbolsToAliasedNames);\n    translator.warn = msg => this.debugWarn(context, msg);\n    return translator;\n  }\n\n  /**\n   * debug logs a debug warning.  These should only be used for cases\n   * where tsickle is making a questionable judgement about what to do.\n   * By default, tsickle does not report any warnings to the caller,\n   * and warnings are hidden behind a debug flag, as warnings are only\n   * for tsickle to debug itself.\n   */\n  debugWarn(node: ts.Node, messageText: string) {\n    if (!this.host.logWarning) return;\n    // Use a ts.Diagnosic so that the warning includes context and file offets.\n    const diagnostic: ts.Diagnostic = {\n      file: this.file,\n      start: node.getStart(),\n      length: node.getEnd() - node.getStart(),\n      messageText,\n      category: ts.DiagnosticCategory.Warning,\n      code: 0,\n    };\n    this.host.logWarning(diagnostic);\n  }\n}\n\ntype HasTypeParameters =\n    ts.InterfaceDeclaration|ts.ClassLikeDeclaration|ts.TypeAliasDeclaration|ts.SignatureDeclaration;\n\n// Matches common extensions of TypeScript input filenames\nconst extension = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\n\nconst FILEOVERVIEW_COMMENTS: ReadonlySet<string> =\n    new Set(['fileoverview', 'externs', 'modName', 'mods', 'pintomodule']);\n\n/** Annotator translates a .ts to a .ts with Closure annotations. */\nclass Annotator extends ClosureRewriter {\n  /** Exported symbol names that have been generated by expanding an \"export * from ...\". */\n  private generatedExports = new Set<string>();\n  /** DecoratorClassVisitor when lowering decorators while closure annotating */\n  private currentDecoratorConverter: decorator.DecoratorClassVisitor|undefined;\n  /** Collection of Identifiers used in an `import {foo}` declaration with their Symbol */\n  private importedNames: Array<{name: ts.Identifier, declarationNames: ts.Identifier[]}> = [];\n\n  private templateSpanStackCount = 0;\n  private polymerBehaviorStackCount = 0;\n\n  constructor(\n      typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost,\n      private tsHost?: ts.ModuleResolutionHost, private tsOpts?: ts.CompilerOptions,\n      sourceMapper?: SourceMapper) {\n    super(typeChecker, file, host, sourceMapper);\n  }\n\n  annotate() {\n    this.visit(this.file);\n    return this.getOutput();\n  }\n\n  getExportDeclarationNames(node: ts.Node): ts.Identifier[] {\n    switch (node.kind) {\n      case ts.SyntaxKind.VariableStatement:\n        const varDecl = node as ts.VariableStatement;\n        return varDecl.declarationList.declarations.map(\n            (d) => this.getExportDeclarationNames(d)[0]);\n      case ts.SyntaxKind.VariableDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.ModuleDeclaration:\n        const decl = node as ts.NamedDeclaration;\n        if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {\n          break;\n        }\n        return [decl.name];\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        const typeAlias = node as ts.TypeAliasDeclaration;\n        return [typeAlias.name];\n      default:\n        break;\n    }\n    this.error(\n        node, `unsupported export declaration ${ts.SyntaxKind[node.kind]}: ${node.getText()}`);\n    return [];\n  }\n\n  /**\n   * Emits an ES6 export for the ambient declaration behind node, if it is indeed exported.\n   */\n  maybeEmitAmbientDeclarationExport(node: ts.Node) {\n    // In TypeScript, `export declare` simply generates no code in the exporting module, but does\n    // generate a regular import in the importing module.\n    // For Closure Compiler, such declarations must still be exported, so that importing code in\n    // other modules can reference them. Because tsickle generates global symbols for such types,\n    // the appropriate semantics are referencing the global name.\n    if (this.host.untyped || !hasModifierFlag(node, ts.ModifierFlags.Export)) {\n      return;\n    }\n    const declNames = this.getExportDeclarationNames(node);\n    for (const decl of declNames) {\n      const sym = this.mustGetSymbolAtLocation(decl);\n      const isValue = sym.flags & ts.SymbolFlags.Value;\n      const declName = getIdentifierText(decl);\n      if (node.kind === ts.SyntaxKind.VariableStatement) {\n        // For variables, TypeScript rewrites every reference to the variable name as an\n        // \"exports.\" access, to maintain mutable ES6 exports semantics. Indirecting through the\n        // window object means we reference the correct global symbol. Closure Compiler does\n        // understand that \"var foo\" in externs corresponds to \"window.foo\".\n        this.emit(`\\nexports.${declName} = window.${declName};\\n`);\n      } else if (!isValue) {\n        // Do not emit re-exports for ModuleDeclarations.\n        // Ambient ModuleDeclarations are always referenced as global symbols, so they don't need to\n        // be exported.\n        if (node.kind === ts.SyntaxKind.ModuleDeclaration) continue;\n        // Non-value objects do not exist at runtime, so we cannot access the symbol (it only\n        // exists in externs). Export them as a typedef, which forwards to the type in externs.\n        this.emit(`\\n/** @typedef {${declName}} */\\nexports.${declName};\\n`);\n      } else {\n        this.emit(`\\nexports.${declName} = ${declName};\\n`);\n      }\n    }\n  }\n\n  /**\n   * Examines a ts.Node and decides whether to do special processing of it for output.\n   *\n   * @return True if the ts.Node has been handled, false if we should\n   *     emit it as is and visit its children.\n   */\n  maybeProcess(node: ts.Node): boolean {\n    if (hasModifierFlag(node, ts.ModifierFlags.Ambient) || isDtsFileName(this.file.fileName)) {\n      // An ambient declaration declares types for TypeScript's benefit, so we want to skip Tsickle\n      // conversion of its contents.\n      this.writeRange(node, node.getFullStart(), node.getEnd());\n      // ... but it might need to be exported for downstream importing code.\n      this.maybeEmitAmbientDeclarationExport(node);\n      return true;\n    }\n    if (this.currentDecoratorConverter) {\n      this.currentDecoratorConverter.beforeProcessNode(node);\n    }\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n        this.handleSourceFile(node as ts.SourceFile);\n        return true;\n      case ts.SyntaxKind.ImportDeclaration:\n        this.importedNames.push(\n            ...decorator.collectImportedNames(this.typeChecker, node as ts.ImportDeclaration));\n        return this.emitImportDeclaration(node as ts.ImportDeclaration);\n      case ts.SyntaxKind.ExportDeclaration:\n        const exportDecl = node as ts.ExportDeclaration;\n        this.writeLeadingTrivia(node);\n        this.emit('export');\n        let exportedSymbols: NamedSymbol[] = [];\n        if (!exportDecl.exportClause && exportDecl.moduleSpecifier) {\n          // It's an \"export * from ...\" statement.\n          // Rewrite it to re-export each exported symbol directly.\n          exportedSymbols = this.expandSymbolsFromExportStar(exportDecl);\n          const exportSymbolsToEmit =\n              exportedSymbols.filter(s => this.shouldEmitExportSymbol(s.sym));\n          this.emit(` {${exportSymbolsToEmit.map(e => unescapeName(e.name)).join(',')}}`);\n        } else {\n          if (exportDecl.exportClause) {\n            exportedSymbols = this.getNamedSymbols(exportDecl.exportClause.elements);\n            this.visit(exportDecl.exportClause);\n          }\n        }\n        if (exportDecl.moduleSpecifier) {\n          this.emit(` from '${this.resolveModuleSpecifier(exportDecl.moduleSpecifier)}';`);\n        } else {\n          // export {...};\n          this.emit(';');\n        }\n        this.addSourceMapping(node);\n        if (exportDecl.moduleSpecifier) {\n          this.forwardDeclare(exportDecl.moduleSpecifier, exportedSymbols);\n        }\n        if (exportedSymbols.length) {\n          this.emitTypeDefExports(exportedSymbols);\n        }\n        return true;\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this.emitInterface(node as ts.InterfaceDeclaration);\n        // Emit the TS interface verbatim, with no tsickle processing of properties.\n        this.writeRange(node, node.getFullStart(), node.getEnd());\n        return true;\n      case ts.SyntaxKind.VariableDeclaration:\n        const varDecl = node as ts.VariableDeclaration;\n        // Only emit a type annotation when it's a plain variable and\n        // not a binding pattern, as Closure doesn't(?) have a syntax\n        // for annotating binding patterns.  See issue #128.\n        // Don't emit type annotation when the variable statement is a @polymerBehavior,\n        // as otherwise the polymer closure checker will fail.\n        // See b/64389806\n        if (this.polymerBehaviorStackCount === 0 &&\n            varDecl.name.kind === ts.SyntaxKind.Identifier) {\n          this.emitJSDocType(varDecl);\n        }\n        return false;\n      case ts.SyntaxKind.ClassDeclaration:\n        const classNode = node as ts.ClassDeclaration;\n        this.visitClassDeclaration(classNode);\n        return true;\n      case ts.SyntaxKind.PublicKeyword:\n      case ts.SyntaxKind.PrivateKeyword:\n        // The \"public\"/\"private\" keywords are encountered in two places:\n        // 1) In class fields (which don't appear in the transformed output).\n        // 2) In \"parameter properties\", e.g.\n        //      constructor(/** @export */ public foo: string).\n        // In case 2 it's important to not emit that JSDoc in the generated\n        // constructor, as this is illegal for Closure.  It's safe to just\n        // always skip comments preceding the 'public' keyword.\n        // See test_files/parameter_properties.ts.\n        this.writeNode(node, /* skipComments */ true);\n        return true;\n      case ts.SyntaxKind.Constructor:\n        const ctor = node as ts.ConstructorDeclaration;\n        this.emitFunctionType([ctor]);\n        // Write the \"constructor(...) {\" bit, but iterate through any\n        // parameters if given so that we can examine them more closely.\n        this.writeNodeFrom(ctor, ctor.getStart());\n        return true;\n      case ts.SyntaxKind.ArrowFunction:\n        // It's difficult to annotate arrow functions due to a bug in\n        // TypeScript (see tsickle issue 57).  For now, just pass them\n        // through unannotated.\n        return false;\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n        const fnDecl = node as ts.FunctionLikeDeclaration;\n        const tags = hasExportingDecorator(node, this.typeChecker) ? [{tagName: 'export'}] : [];\n\n        if (!fnDecl.body) {\n          // Two cases: abstract methods and overloaded methods/functions.\n          // Abstract methods are handled in emitTypeAnnotationsHandler.\n          // Overloads are union-ized into the shared type in emitFunctionType.\n          return false;\n        }\n\n        this.emitFunctionType([fnDecl], tags);\n        this.writeNodeFrom(fnDecl, fnDecl.getStart());\n        return true;\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        this.writeNode(node);\n        this.visitTypeAlias(node as ts.TypeAliasDeclaration);\n        return true;\n      case ts.SyntaxKind.EnumDeclaration:\n        this.processEnum(node as ts.EnumDeclaration);\n        return true;\n      case ts.SyntaxKind.TemplateSpan:\n        this.templateSpanStackCount++;\n        this.writeNode(node);\n        this.templateSpanStackCount--;\n        return true;\n      case ts.SyntaxKind.TypeAssertionExpression:\n      case ts.SyntaxKind.AsExpression:\n        // Both of these cases are AssertionExpressions.\n        const typeAssertion = node as ts.AssertionExpression;\n        if (this.polymerBehaviorStackCount > 0) {\n          // Don't emit type casts for Polymer behaviors that are declared\n          // by calling the Polymer function\n          // as the Polymer closure plugin does not work when emitting them.\n          // See b/64389806.\n          // Note: This only matters in the transformer version of tsickle,\n          // as the non transformer version never emitted type casts due to\n          // https://github.com/Microsoft/TypeScript/issues/9873 (see below).\n          return false;\n        }\n        // When using a type casts in template expressions,\n        // closure requires another pair of parens, otherwise it will\n        // complain with \"Misplaced type annotation. Type annotations are not allowed here.\"\n        if (this.templateSpanStackCount > 0) {\n          this.emit('(');\n        }\n        this.emitJSDocType(typeAssertion);\n        // When TypeScript emits JS, it removes one layer of \"redundant\"\n        // parens, but we need them for the Closure type assertion.  Work\n        // around this by using two parens.  See test_files/coerce.*.\n        // This is needed in both, the transformer and non transformer version.\n        // TODO: in the non transformer version, the comment is currently dropped\n        //  alltegether from pure assignments due to\n        //  https://github.com/Microsoft/TypeScript/issues/9873.\n        this.emit('((');\n        this.writeNode(node);\n        this.emit('))');\n        if (this.templateSpanStackCount > 0) {\n          this.emit(')');\n        }\n        return true;\n      case ts.SyntaxKind.NonNullExpression:\n        const nnexpr = node as ts.NonNullExpression;\n        let type = this.typeChecker.getTypeAtLocation(nnexpr.expression);\n        if (type.flags & ts.TypeFlags.Union) {\n          const nonNullUnion =\n              (type as ts.UnionType)\n                  .types.filter(\n                      t => (t.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) === 0);\n          const typeCopy = Object.assign({}, type as ts.UnionType);\n          typeCopy.types = nonNullUnion;\n          type = typeCopy;\n        }\n        // See comment above.\n        if (this.templateSpanStackCount > 0) {\n          this.emit('(');\n        }\n        this.emitJSDocType(nnexpr, undefined, type);\n        // See comment above.\n        this.emit('((');\n        this.writeNode(nnexpr.expression);\n        this.emit('))');\n        if (this.templateSpanStackCount > 0) {\n          this.emit(')');\n        }\n        return true;\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.VariableStatement:\n        const docTags = this.getJSDoc(node) || [];\n        if (hasExportingDecorator(node, this.typeChecker)) {\n          docTags.push({tagName: 'export'});\n        }\n\n        if (docTags.length > 0 && node.getFirstToken()) {\n          this.emit('\\n');\n          this.emit(jsdoc.toString(docTags));\n          const isPolymerBehavior = docTags.some(t => t.tagName === 'polymerBehavior');\n          if (isPolymerBehavior) {\n            this.polymerBehaviorStackCount++;\n          }\n          this.writeNodeFrom(node, node.getStart());\n          if (isPolymerBehavior) {\n            this.polymerBehaviorStackCount--;\n          }\n          return true;\n        }\n        break;\n      case ts.SyntaxKind.PropertyAssignment:\n        const pa = node as ts.PropertyAssignment;\n        if (isPolymerBehaviorPropertyInCallExpression(pa)) {\n          this.polymerBehaviorStackCount++;\n          this.writeNodeFrom(node, node.getStart());\n          this.polymerBehaviorStackCount--;\n          return true;\n        }\n        return false;\n      case ts.SyntaxKind.ElementAccessExpression:\n        // Warn for quoted accesses to properties that have a symbol declared.\n        // Mixing quoted and non-quoted access to a symbol (x['foo'] and x.foo) risks breaking\n        // Closure Compiler renaming. Quoted access is more cumbersome to write than dotted access\n        // though, so chances are users did intend to avoid renaming. The better fix is to use\n        // `declare interface` though.\n        const eae = node as ts.ElementAccessExpression;\n        if (!eae.argumentExpression ||\n            eae.argumentExpression.kind !== ts.SyntaxKind.StringLiteral) {\n          return false;\n        }\n        const quotedPropSym = this.typeChecker.getSymbolAtLocation(eae.argumentExpression);\n        // If it has a symbol, it's actually a regular declared property.\n        if (!quotedPropSym) return false;\n        const declarationHasQuotes =\n            !quotedPropSym.declarations || quotedPropSym.declarations.some(d => {\n              const decl = d as ts.NamedDeclaration;\n              if (!decl.name) return false;\n              return decl.name.kind === ts.SyntaxKind.StringLiteral;\n            });\n        // If the property is declared with quotes, it should also be accessed with them.\n        if (declarationHasQuotes) return false;\n        const propName = (eae.argumentExpression as ts.StringLiteral).text;\n        // Properties containing non-JS identifier names can only be accessed with quotes.\n        if (!isValidClosurePropertyName(propName)) return false;\n        const symName = this.typeChecker.symbolToString(quotedPropSym);\n        this.debugWarn(\n            eae,\n            `Declared property ${symName} accessed with quotes. ` +\n                `This can lead to renaming bugs. A better fix is to use 'declare interface' ` +\n                `on the declaration.`);\n        // Previously, the code below changed the quoted into a non-quoted access.\n        // this.writeNode(eae.expression);\n        // this.emit(`.${propName}`);\n        return false;\n      case ts.SyntaxKind.PropertyAccessExpression:\n        // Convert dotted accesses to types that have an index type declared to quoted accesses, to\n        // avoid Closure renaming one access but not the other.\n        // This can happen because TS allows dotted access to string index types.\n        const pae = node as ts.PropertyAccessExpression;\n        const t = this.typeChecker.getTypeAtLocation(pae.expression);\n        if (!t.getStringIndexType()) return false;\n        // Types can have string index signatures and declared properties (of the matching type).\n        // These properties have a symbol, as opposed to pure string index types.\n        const propSym = this.typeChecker.getSymbolAtLocation(pae.name);\n        // The decision to return below is a judgement call. Presumably, in most situations, dotted\n        // access to a property is correct, and should not be turned into quoted access even if\n        // there is a string index on the type. However it is possible to construct programs where\n        // this is incorrect, e.g. where user code assigns into a property through the index access\n        // in another location.\n        if (propSym) return false;\n\n        this.debugWarn(\n            pae,\n            this.typeChecker.typeToString(t) +\n                ` has a string index type but is accessed using dotted access. ` +\n                `Quoting the access.`);\n        this.writeNode(pae.expression);\n        this.emit('[\"');\n        this.writeNode(pae.name);\n        this.emit('\"]');\n        return true;\n      case ts.SyntaxKind.Decorator:\n        if (this.currentDecoratorConverter) {\n          return this.currentDecoratorConverter.maybeProcessDecorator(node as ts.Decorator);\n        }\n        return false;\n      default:\n        break;\n    }\n    return false;\n  }\n\n  private shouldEmitExportSymbol(sym: ts.Symbol): boolean {\n    if (sym.flags & ts.SymbolFlags.Alias) {\n      sym = this.typeChecker.getAliasedSymbol(sym);\n    }\n    if ((sym.flags & ts.SymbolFlags.Value) === 0) {\n      // Note: We create explicit reexports via closure at another place in\n      return false;\n    }\n    if (sym.flags & ts.SymbolFlags.ConstEnum) {\n      return false;\n    }\n    return true;\n  }\n\n  private handleSourceFile(sf: ts.SourceFile) {\n    const start = this.emitSuppressChecktypes(sf);\n    this.writeNodeFrom(sf, start);\n  }\n\n  /**\n   * Emits an \\@suppress {checkTypes} fileoverview comment.\n   * Returns the place from where to start emitting the source file.\n   */\n  private emitSuppressChecktypes(sf: ts.SourceFile): number {\n    const comments = ts.getLeadingCommentRanges(sf.getFullText(), 0) || [];\n\n    let fileoverviewIdx = -1;\n    for (let i = comments.length - 1; i >= 0; i--) {\n      const parsed = jsdoc.parse(sf.getFullText().substring(comments[i].pos, comments[i].end));\n      if (parsed !== null && parsed.tags.some(t => FILEOVERVIEW_COMMENTS.has(t.tagName))) {\n        fileoverviewIdx = i;\n        break;\n      }\n    }\n    // Add a @suppress {checkTypes} tag to each source file's JSDoc comment,\n    // being careful to retain existing comments and their @suppress'ions.\n    // Closure Compiler considers the *last* comment with @fileoverview (or @externs or @nocompile)\n    // that has not been attached to some other tree node to be the file overview comment, and\n    // only applies @suppress tags from it.\n    // AJD considers *any* comment mentioning @fileoverview.\n    if (fileoverviewIdx === -1) {\n      // No existing comment to merge with, just emit a new one.\n      this.emit(jsdoc.toString([\n        {tagName: 'fileoverview', text: 'added by tsickle'},\n        {tagName: 'suppress', type: 'checkTypes', text: 'checked by tsc'},\n      ]));\n      this.emit('\\n');\n      return sf.getFullStart();\n    }\n    const comment = comments[fileoverviewIdx];\n    this.writeRange(sf, 0, comment.pos);\n\n    const parsed = jsdoc.parse(sf.getFullText().substring(comment.pos, comment.end));\n    if (!parsed) throw new Error('internal error: JSDoc comment does not parse');\n    const {tags} = parsed;\n\n    // Add @suppress {checkTypes}, or add to the list in an existing @suppress tag.\n    // Closure compiler barfs if there's a duplicated @suppress tag in a file, so the tag must\n    // only appear once and be merged.\n    const suppressIdx = tags.findIndex(t => t.tagName === 'suppress');\n    if (suppressIdx !== -1) {\n      const suppressions = tags[suppressIdx].type || '';\n      const suppressionsList = suppressions.split(',').map(s => s.trim());\n      if (suppressionsList.indexOf('checkTypes') === -1) {\n        suppressionsList.push('checkTypes');\n      }\n      tags[suppressIdx].type = suppressionsList.join(',');\n    } else {\n      tags.push({\n        tagName: 'suppress',\n        type: 'checkTypes',\n        text: 'checked by tsc',\n      });\n    }\n    this.emit(jsdoc.toString(tags));\n    if (sf.getFullText().substring(comment.end, comment.end + 2) !== '\\n\\n') {\n      this.emit('\\n\\n');  // separate from file body to avoid being dropped by tsc.\n    }\n    // Return this comment's end, so that subsequent code does not emit this comment multiple times,\n    // which can be an error in case of @fileoverview comments.\n    // Known issue: if this comment is not the last comment in the file's leading trivia, this will\n    // swallow comments before the next node, unless they are recognized as JSDoc comments on the\n    // node. That's because while each node will print its leading trivia when visited, they will\n    // not print areas that are partially blocked (like this, except for JSDoc). This is hard to fix\n    // as the node being emitted cannot know which range should still be printed. Generally speaking\n    // swallowing a comment is less risky than emitting one twice, so we take that into account.\n    return comment.end;\n  }\n\n  /**\n   * Given a \"export * from ...\" statement, gathers the symbol names it actually\n   * exports to be used in a statement like \"export {foo, bar, baz} from ...\".\n   *\n   * This is necessary because TS transpiles \"export *\" by just doing a runtime loop\n   * over the target module's exports, which means Closure won't see the declarations/types\n   * that are exported.\n   */\n  private expandSymbolsFromExportStar(exportDecl: ts.ExportDeclaration): NamedSymbol[] {\n    // You can't have an \"export *\" without a module specifier.\n    const moduleSpecifier = exportDecl.moduleSpecifier!;\n\n    // Gather the names of local exports, to avoid reexporting any\n    // names that are already locally exported.\n    const moduleSymbol = this.typeChecker.getSymbolAtLocation(this.file);\n    const moduleExports = moduleSymbol && moduleSymbol.exports || new Map<string, ts.Symbol>();\n\n    // Expand the export list, then filter it to the symbols we want to reexport.\n    const exports =\n        this.typeChecker.getExportsOfModule(this.mustGetSymbolAtLocation(moduleSpecifier));\n    const reexports = new Set<ts.Symbol>();\n    for (const sym of exports) {\n      const name = unescapeName(sym.name);\n      if (moduleExports.has(name)) {\n        // This name is shadowed by a local definition, such as:\n        // - export var foo ...\n        // - export {foo} from ...\n        // - export {bar as foo} from ...\n        continue;\n      }\n      if (this.generatedExports.has(name)) {\n        // Already exported via an earlier expansion of an \"export * from ...\".\n        continue;\n      }\n      this.generatedExports.add(name);\n      reexports.add(sym);\n    }\n    return toArray(reexports.keys()).map(sym => {\n      return {name: sym.name, sym};\n    });\n  }\n\n  /**\n   * Write an `exports.` assignment for each type alias exported in the given `exports`.\n   * TypeScript by itself does not export non-value symbols (e.g. interfaces, typedefs), as it\n   * expects to remove those entirely for runtime. For Closure, types must be\n   * exported as downstream code will import the type.\n   *\n   * The tsickle pass turns interfaces into values by generating a `function MyInterface() {}` for\n   * them, so in the second conversion pass, TypeScript does export a value for them. However for\n   * pure typedefs, tsickle only generates a property access with a JSDoc comment, so they need to\n   * be exported explicitly here.\n   */\n  private emitTypeDefExports(exports: NamedSymbol[]) {\n    if (this.host.untyped) return;\n    for (const exp of exports) {\n      if (exp.sym.flags & ts.SymbolFlags.Alias)\n        exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);\n      const isTypeAlias = ((exp.sym.flags & ts.SymbolFlags.TypeAlias) !== 0 &&\n                           (exp.sym.flags & ts.SymbolFlags.Value) === 0) ||\n          (exp.sym.flags & ts.SymbolFlags.Interface) !== 0 &&\n              (exp.sym.flags & ts.SymbolFlags.Value) === 0;\n      if (!isTypeAlias) continue;\n      const typeName = this.symbolsToAliasedNames.get(exp.sym) || exp.sym.name;\n      this.emit(`\\n/** @typedef {${typeName}} */\\nexports.${exp.name}; // re-export typedef`);\n    }\n  }\n\n  /**\n   * Convert from implicit `import {} from 'pkg'` to `import {} from 'pkg/index'.\n   * TypeScript supports the shorthand, but not all ES6 module loaders do.\n   * Workaround for https://github.com/Microsoft/TypeScript/issues/12597\n   */\n  private resolveModuleSpecifier(moduleSpecifier: ts.Expression): string {\n    if (moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {\n      throw new Error(`unhandled moduleSpecifier kind: ${ts.SyntaxKind[moduleSpecifier.kind]}`);\n    }\n    let moduleId = (moduleSpecifier as ts.StringLiteral).text;\n    if (this.host.convertIndexImportShorthand) {\n      if (!this.tsOpts || !this.tsHost) {\n        throw new Error(\n            'option convertIndexImportShorthand requires that annotate be called with a TypeScript host and options.');\n      }\n      const resolved = ts.resolveModuleName(moduleId, this.file.fileName, this.tsOpts, this.tsHost);\n      if (resolved && resolved.resolvedModule) {\n        const requestedModule = moduleId.replace(extension, '');\n        const resolvedModule = resolved.resolvedModule.resolvedFileName.replace(extension, '');\n        if (resolvedModule.indexOf('node_modules') === -1 &&\n            requestedModule.substr(requestedModule.lastIndexOf('/')) !==\n                resolvedModule.substr(resolvedModule.lastIndexOf('/'))) {\n          moduleId = './' +\n              path.relative(path.dirname(this.file.fileName), resolvedModule)\n                  .replace(path.sep, '/');\n        }\n      }\n    }\n    return moduleId;\n  }\n\n  /**\n   * Handles emit of an \"import ...\" statement.\n   * We need to do a bit of rewriting so that imported types show up under the\n   * correct name in JSDoc.\n   * @return true if the decl was handled, false to allow default processing.\n   */\n  private emitImportDeclaration(decl: ts.ImportDeclaration): boolean {\n    this.writeLeadingTrivia(decl);\n    this.emit('import');\n    const importPath = this.resolveModuleSpecifier(decl.moduleSpecifier);\n    const importClause = decl.importClause;\n    if (!importClause) {\n      // import './foo';\n      this.emit(`'${importPath}';`);\n      this.addSourceMapping(decl);\n      return true;\n    } else if (\n        importClause.name ||\n        (importClause.namedBindings &&\n         importClause.namedBindings.kind === ts.SyntaxKind.NamedImports)) {\n      this.visit(importClause);\n      this.emit(` from '${importPath}';`);\n      this.addSourceMapping(decl);\n\n      // importClause.name implies\n      //   import a from ...;\n      // namedBindings being NamedImports implies\n      //   import {a as b} from ...;\n      //\n      // Both of these forms create a local name \"a\", which after TypeScript CommonJS compilation\n      // will become some renamed variable like \"module_1.default\" or \"module_1.a\" (for default vs\n      // named bindings, respectively).\n      // tsickle references types in JSDoc. Because the module prefixes are not predictable, and\n      // because TypeScript might remove imports entirely if they are only for types, the code below\n      // inserts an artificial `const prefix = goog.require` call for the module, and then registers\n      // all symbols from this import to be prefixed.\n      if (!this.host.untyped) {\n        let symbols: NamedSymbol[] = [];\n        if (importClause.name) {\n          // import a from ...;\n          symbols = [{\n            name: getIdentifierText(importClause.name),\n            sym: this.mustGetSymbolAtLocation(importClause.name),\n          }];\n        } else {\n          // import {a as b} from ...;\n          if (!importClause.namedBindings ||\n              importClause.namedBindings.kind !== ts.SyntaxKind.NamedImports) {\n            throw new Error('unreached');  // Guaranteed by if check above.\n          }\n          symbols = this.getNamedSymbols(importClause.namedBindings.elements);\n        }\n        this.forwardDeclare(decl.moduleSpecifier, symbols, !!importClause.name);\n      }\n      return true;\n    } else if (\n        importClause.namedBindings &&\n        importClause.namedBindings.kind === ts.SyntaxKind.NamespaceImport) {\n      // import * as foo from ...;\n      this.visit(importClause);\n      this.emit(` from '${importPath}';`);\n      this.addSourceMapping(decl);\n      return true;\n    } else {\n      this.errorUnimplementedKind(decl, 'unexpected kind of import');\n      return false;  // Use default processing.\n    }\n  }\n\n  private getNamedSymbols(specifiers: Array<ts.ImportSpecifier|ts.ExportSpecifier>): NamedSymbol[] {\n    return specifiers.map(e => {\n      return {\n        // e.name might be renaming symbol as in `export {Foo as Bar}`, where e.name would be 'Bar'\n        // and != sym.name. Store away the name so forwardDeclare below can emit the right name.\n        name: getIdentifierText(e.name),\n        sym: this.mustGetSymbolAtLocation(e.name),\n      };\n    });\n  }\n\n  private forwardDeclareCounter = 0;\n\n  /**\n   * Emits a `goog.forwardDeclare` alias for each symbol from the given list.\n   * @param specifier the import specifier, i.e. module path (\"from '...'\").\n   */\n  private forwardDeclare(\n      specifier: ts.Expression, exportedSymbols: NamedSymbol[], isDefaultImport = false) {\n    if (this.host.untyped) return;\n    const importPath = this.resolveModuleSpecifier(specifier);\n    const nsImport = es5processor.extractGoogNamespaceImport(importPath);\n    const forwardDeclarePrefix = `tsickle_forward_declare_${++this.forwardDeclareCounter}`;\n    const moduleNamespace =\n        nsImport !== null ? nsImport : this.host.pathToModuleName(this.file.fileName, importPath);\n    const moduleSymbol = this.typeChecker.getSymbolAtLocation(specifier);\n    // Scripts do not have a symbol. Scripts can still be imported, either as side effect imports or\n    // with an empty import set (\"{}\"). TypeScript does not emit a runtime load for an import with\n    // an empty list of symbols, but the import forces any global declarations from the library to\n    // be visible, which is what users use this for. No symbols from the script need forward\n    // declaration, so just return.\n    if (!moduleSymbol) return;\n    const exports = this.typeChecker.getExportsOfModule(moduleSymbol);\n    // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.\n    // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires\n    // here would cause a change in load order, which is observable (and can lead to errors).\n    // Instead, goog.forwardDeclare types, which allows using them in type annotations without\n    // causing a load. See below for the exception to the rule.\n    this.emit(`\\nconst ${forwardDeclarePrefix} = goog.forwardDeclare(\"${moduleNamespace}\");`);\n    const hasValues = exports.some(e => (e.flags & ts.SymbolFlags.Value) !== 0);\n    if (!hasValues) {\n      // Closure Compiler's toolchain will drop files that are never goog.require'd *before* type\n      // checking (e.g. when using --closure_entry_point or similar tools). This causes errors\n      // complaining about values not matching 'NoResolvedType', or modules not having a certain\n      // member.\n      // To fix, explicitly goog.require() modules that only export types. This should usually not\n      // cause breakages due to load order (as no symbols are accessible from the module - though\n      // contrived code could observe changes in side effects).\n      // This is a heuristic - if the module exports some values, but those are never imported,\n      // the file will still end up not being imported. Hopefully modules that export values are\n      // imported for their value in some place.\n      this.emit(`\\ngoog.require(\"${moduleNamespace}\"); // force type-only module to be loaded`);\n    }\n    for (const exp of exportedSymbols) {\n      if (exp.sym.flags & ts.SymbolFlags.Alias)\n        exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);\n      // goog: imports don't actually use the .default property that TS thinks they have.\n      const qualifiedName = nsImport && isDefaultImport ? forwardDeclarePrefix :\n                                                          forwardDeclarePrefix + '.' + exp.sym.name;\n      this.symbolsToAliasedNames.set(exp.sym, qualifiedName);\n    }\n  }\n\n  private visitClassDeclaration(classDecl: ts.ClassDeclaration) {\n    this.addSourceMapping(classDecl);\n    const oldDecoratorConverter = this.currentDecoratorConverter;\n    this.currentDecoratorConverter =\n        new decorator.DecoratorClassVisitor(this.typeChecker, this, classDecl, this.importedNames);\n\n    const docTags = this.getJSDoc(classDecl) || [];\n    if (hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {\n      docTags.push({tagName: 'abstract'});\n    }\n\n    if (!this.host.untyped) {\n      this.maybeAddTemplateClause(docTags, classDecl);\n      this.maybeAddHeritageClauses(docTags, classDecl);\n    }\n\n    this.emit('\\n');\n    if (docTags.length > 0) this.emit(jsdoc.toString(docTags));\n    decorator.visitClassContentIncludingDecorators(classDecl, this, this.currentDecoratorConverter);\n    this.emitTypeAnnotationsHelper(classDecl);\n\n    this.currentDecoratorConverter = oldDecoratorConverter;\n    return true;\n  }\n\n  private emitInterface(iface: ts.InterfaceDeclaration) {\n    // If this symbol is both a type and a value, we cannot emit both into Closure's\n    // single namespace.\n    const sym = this.mustGetSymbolAtLocation(iface.name);\n    if (sym.flags & ts.SymbolFlags.Value) return;\n\n    const docTags = this.getJSDoc(iface) || [];\n    docTags.push({tagName: 'record'});\n    if (!this.host.untyped) {\n      this.maybeAddTemplateClause(docTags, iface);\n      this.maybeAddHeritageClauses(docTags, iface);\n    }\n\n    this.emit('\\n');\n    this.emit(jsdoc.toString(docTags));\n\n    if (hasModifierFlag(iface, ts.ModifierFlags.Export)) this.emit('export ');\n    const name = getIdentifierText(iface.name);\n    this.emit(`function ${name}() {}\\n`);\n\n    this.emit(`\\n\\nfunction ${name}_tsickle_Closure_declarations() {\\n`);\n    const memberNamespace = [name, 'prototype'];\n    for (const elem of iface.members) {\n      const isOptional = elem.questionToken != null;\n      this.visitProperty(memberNamespace, elem, isOptional);\n    }\n    this.emit(`}\\n`);\n  }\n\n  /**\n   * emitTypeAnnotationsHelper produces a _tsickle_typeAnnotationsHelper() where\n   * none existed in the original source. It's necessary in the case where\n   * TypeScript syntax specifies there are additional properties on the class,\n   * because to declare these in Closure you must declare these in a method\n   * somewhere.\n   */\n  private emitTypeAnnotationsHelper(classDecl: ts.ClassDeclaration) {\n    // Gather parameter properties from the constructor, if it exists.\n    const ctors: ts.ConstructorDeclaration[] = [];\n    let paramProps: ts.ParameterDeclaration[] = [];\n    const nonStaticProps: ts.PropertyDeclaration[] = [];\n    const staticProps: ts.PropertyDeclaration[] = [];\n    const abstractMethods: ts.FunctionLikeDeclaration[] = [];\n    for (const member of classDecl.members) {\n      if (member.kind === ts.SyntaxKind.Constructor) {\n        ctors.push(member as ts.ConstructorDeclaration);\n      } else if (member.kind === ts.SyntaxKind.PropertyDeclaration) {\n        const prop = member as ts.PropertyDeclaration;\n        const isStatic = hasModifierFlag(prop, ts.ModifierFlags.Static);\n        if (isStatic) {\n          staticProps.push(prop);\n        } else {\n          nonStaticProps.push(prop);\n        }\n      } else if (\n          hasModifierFlag(member, ts.ModifierFlags.Abstract) &&\n          (member.kind === ts.SyntaxKind.MethodDeclaration ||\n           member.kind === ts.SyntaxKind.GetAccessor ||\n           member.kind === ts.SyntaxKind.SetAccessor)) {\n        abstractMethods.push(\n            member as ts.MethodDeclaration | ts.GetAccessorDeclaration | ts.SetAccessorDeclaration);\n      }\n    }\n\n    if (ctors.length > 0) {\n      const ctor = ctors[0];\n      paramProps = ctor.parameters.filter(p => hasModifierFlag(p, FIELD_DECLARATION_MODIFIERS));\n    }\n\n    if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&\n        abstractMethods.length === 0 &&\n        !(this.currentDecoratorConverter && this.currentDecoratorConverter.foundDecorators())) {\n      // There are no members so we don't need to emit any type\n      // annotations helper.\n      return;\n    }\n\n    if (!classDecl.name) return;\n    const className = getIdentifierText(classDecl.name);\n\n    this.emit(`\\n\\nfunction ${className}_tsickle_Closure_declarations() {\\n`);\n    if (this.currentDecoratorConverter) {\n      this.currentDecoratorConverter.emitMetadataTypeAnnotationsHelpers();\n    }\n    staticProps.forEach(p => this.visitProperty([className], p));\n    const memberNamespace = [className, 'prototype'];\n    nonStaticProps.forEach((p) => this.visitProperty(memberNamespace, p));\n    paramProps.forEach((p) => this.visitProperty(memberNamespace, p));\n\n    for (const fnDecl of abstractMethods) {\n      const name = this.propertyName(fnDecl);\n      if (!name) {\n        this.error(fnDecl, 'anonymous abstract function');\n        continue;\n      }\n      const tags = hasExportingDecorator(fnDecl, this.typeChecker) ? [{tagName: 'export'}] : [];\n      const paramNames = this.emitFunctionType([fnDecl], tags);\n      // memberNamespace because abstract methods cannot be static in TypeScript.\n      this.emit(`${memberNamespace.join('.')}.${name} = function(${paramNames.join(', ')}) {};\\n`);\n    }\n\n    this.emit(`}\\n`);\n  }\n\n  private propertyName(prop: ts.NamedDeclaration): string|null {\n    if (!prop.name) return null;\n\n    switch (prop.name.kind) {\n      case ts.SyntaxKind.Identifier:\n        return getIdentifierText(prop.name as ts.Identifier);\n      case ts.SyntaxKind.StringLiteral:\n        // E.g. interface Foo { 'bar': number; }\n        // If 'bar' is a name that is not valid in Closure then there's nothing we can do.\n        const text = (prop.name as ts.StringLiteral).text;\n        if (!isValidClosurePropertyName(text)) return null;\n        return text;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @param optional If true, property is optional (e.g. written \"foo?: string\").\n   */\n  private visitProperty(namespace: string[], prop: ts.Declaration, optional = false) {\n    const name = this.propertyName(prop);\n    if (!name) {\n      this.emit(`/* TODO: handle strange member:\\n${this.escapeForComment(prop.getText())}\\n*/\\n`);\n      return;\n    }\n\n    let type = this.typeToClosure(prop);\n    // When a property is optional, e.g.\n    //   foo?: string;\n    // Then the TypeScript type of the property is string|undefined, the\n    // typeToClosure translation handles it correctly, and string|undefined is\n    // how you write an optional property in Closure.\n    //\n    // But in the special case of an optional property with type any:\n    //   foo?: any;\n    // The TypeScript type of the property is just \"any\" (because any includes\n    // undefined as well) so our default translation of the type is just \"?\".\n    // To mark the property as optional in Closure it must have \"|undefined\",\n    // so the Closure type must be ?|undefined.\n    if (optional && type === '?') type += '|undefined';\n\n    const tags = this.getJSDoc(prop) || [];\n    tags.push({tagName: 'type', type});\n    if (hasExportingDecorator(prop, this.typeChecker)) {\n      tags.push({tagName: 'export'});\n    }\n    // Avoid printing annotations that can conflict with @type\n    // This avoids Closure's error \"type annotation incompatible with other annotations\"\n    this.emit(jsdoc.toString(tags, new Set(['param', 'return'])));\n    namespace = namespace.concat([name]);\n    this.emit(`${namespace.join('.')};\\n`);\n  }\n\n  private visitTypeAlias(node: ts.TypeAliasDeclaration) {\n    if (this.host.untyped) return;\n\n    // If the type is also defined as a value, skip emitting it. Closure collapses type & value\n    // namespaces, the two emits would conflict if tsickle emitted both.\n    const sym = this.mustGetSymbolAtLocation(node.name);\n    if (sym.flags & ts.SymbolFlags.Value) return;\n\n    // Write a Closure typedef, which involves an unused \"var\" declaration.\n    // Note: in the case of an export, we cannot emit a literal \"var\" because\n    // TypeScript drops exports that are never assigned to (and Closure\n    // requires us to not assign to typedef exports).  Instead, emit the\n    // \"exports.foo;\" line directly in that case.\n    this.emit(`\\n/** @typedef {${this.typeToClosure(node)}} */\\n`);\n    if (hasModifierFlag(node, ts.ModifierFlags.Export)) {\n      this.emit('exports.');\n    } else {\n      this.emit('var ');\n    }\n    this.emit(`${node.name.getText()};\\n`);\n  }\n\n  /**\n   * getEnumType computes the Closure type of an enum, by iterating through the members\n   * and gathering their types.\n   */\n  private getEnumType(enumDecl: ts.EnumDeclaration): 'number|string'|'number'|'string'|'?' {\n    let hasNumber = false;\n    let hasString = false;\n    for (const member of enumDecl.members) {\n      if (member.initializer) {\n        const type = this.typeChecker.getTypeAtLocation(member.initializer);\n        // Note: checking against 'NumberLike' instead of just 'Number' means this code\n        // handles both\n        //   MEMBER = 3,  // TypeFlags.NumberLiteral\n        // and\n        //   MEMBER = someFunction(),  // TypeFlags.Number\n        if (type.flags & ts.TypeFlags.NumberLike) {\n          hasNumber = true;\n        } else if (type.flags & ts.TypeFlags.StringLike) {\n          hasString = true;\n        } else {\n          // Enum contains something other than a string or a number; bail.\n          return '?';\n        }\n      } else {\n        // Members without initializers default to numeric.\n        hasNumber = true;\n      }\n    }\n    if (hasNumber && hasString) {\n      return 'number|string';\n    } else if (hasNumber) {\n      return 'number';\n    } else if (hasString) {\n      return 'string';\n    } else {\n      // Perhaps an empty enum?\n      return '?';\n    }\n  }\n\n  /**\n   * Processes an EnumDeclaration into a Closure type. Always emits a Closure type, even in untyped\n   * mode, as that should be harmless (it only ever uses the number type).\n   */\n  private processEnum(node: ts.EnumDeclaration) {\n    // Emit the enum declaration, which looks like:\n    //   /** @enum {number} */\n    //   const Foo = {BAR: 0, BAZ: 1, ...};\n    //   export {Foo};  // even if originally exported on one line.\n    // This declares an enum type for Closure Compiler (and Closure JS users of this TS code).\n    // Splitting the enum into declaration and export is required so that local references to the\n    // type resolve (\"@type {Foo}\").\n    this.emit('\\n');\n    const name = node.name.getText();\n\n    const enumType = this.getEnumType(node);\n    this.emit(`/** @enum {${enumType}} */\\n`);\n    this.emit(`const ${name}: DontTypeCheckMe = {`);\n    // Emit enum values ('BAR: 0,').\n    let enumIndex = 0;\n    for (const member of node.members) {\n      const memberName = member.name.getText();\n      // Emit any comments and leading whitespace on the enum value definition.\n      this.writeLeadingTrivia(member);\n      this.emit(`${memberName}: `);\n\n      if (member.initializer) {\n        const enumConstValue = this.typeChecker.getConstantValue(member);\n        if (typeof enumConstValue === 'number') {\n          enumIndex = enumConstValue + 1;\n          this.emit(enumConstValue.toString());\n        } else {\n          // Non-numeric enum value (string or an expression).\n          // Emit this initializer expression as-is.\n          // Note: if the member's initializer expression refers to another\n          // value within the enum (e.g. something like\n          //   enum Foo {\n          //     Field1,\n          //     Field2 = Field1 + something(),\n          //   }\n          // Then when we emit the initializer we produce invalid code because\n          // on the Closure side the reference to Field1 has to be namespaced,\n          // e.g. written \"Foo.Field1 + something()\".\n          // Hopefully this doesn't come up often -- if the enum instead has\n          // something like\n          //     Field2 = Field1 + 3,\n          // then it's still a constant expression and we inline the constant\n          // value in the above branch of this \"if\" statement.\n          this.visit(member.initializer);\n        }\n      } else {\n        this.emit(enumIndex.toString());\n        enumIndex++;\n      }\n      this.emit(',');\n    }\n    this.emit('};\\n');\n\n    const isExported = hasModifierFlag(node, ts.ModifierFlags.Export);\n    if (isExported) this.emit(`export {${name}};\\n`);\n\n    if (hasModifierFlag(node, ts.ModifierFlags.Const)) {\n      // By TypeScript semantics, const enums disappear after TS compilation.\n      // We still need to generate the runtime value above to make Closure Compiler's type system\n      // happy and allow refering to enums from JS code, but we should at least not emit string\n      // value mappings.\n      return;\n    }\n\n    // Emit the reverse mapping of foo[foo.BAR] = 'BAR'; lines for number enums.\n    if (enumType === 'number') {\n      for (const member of node.members) {\n        const memberName = member.name.getText();\n        this.emit(`${name}[${name}.${memberName}] = \"${memberName}\";\\n`);\n      }\n    }\n  }\n}\n\n/** ExternsWriter generates Closure externs from TypeScript source. */\nclass ExternsWriter extends ClosureRewriter {\n  process(): {output: string, diagnostics: ts.Diagnostic[]} {\n    this.findExternRoots().forEach(node => this.visit(node));\n    return this.getOutput();\n  }\n\n  newTypeTranslator(context: ts.Node) {\n    const tt = super.newTypeTranslator(context);\n    tt.isForExterns = true;\n    return tt;\n  }\n\n  private findExternRoots(): ts.Node[] {\n    if (isDtsFileName(this.file.fileName)) {\n      return [this.file];\n    }\n    return this.file.statements.filter(stmt => hasModifierFlag(stmt, ts.ModifierFlags.Ambient));\n  }\n\n  /** visit is the main entry point.  It generates externs from a ts.Node. */\n  public visit(node: ts.Node, namespace: string[] = []) {\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n        const sourceFile = node as ts.SourceFile;\n        for (const stmt of sourceFile.statements) {\n          this.visit(stmt, namespace);\n        }\n        break;\n      case ts.SyntaxKind.ModuleDeclaration:\n        const decl = node as ts.ModuleDeclaration;\n        switch (decl.name.kind) {\n          case ts.SyntaxKind.Identifier:\n            // E.g. \"declare namespace foo {\"\n            const name = getIdentifierText(decl.name as ts.Identifier);\n            if (name === 'global') {\n              // E.g. \"declare global { ... }\".  Reset to the outer namespace.\n              namespace = [];\n            } else {\n              if (this.isFirstDeclaration(decl)) {\n                this.emit('/** @const */\\n');\n                this.writeExternsVariable(name, namespace, '{}');\n              }\n              namespace = namespace.concat(name);\n            }\n            if (decl.body) this.visit(decl.body, namespace);\n            break;\n          case ts.SyntaxKind.StringLiteral:\n            // E.g. \"declare module 'foo' {\" (note the quotes).\n            // We still want to emit externs for this module, but\n            // Closure doesn't really provide a mechanism for\n            // module-scoped externs.  For now, ignore the enclosing\n            // namespace (because this is declaring a top-level module)\n            // and emit into a fake namespace.\n\n            // Declare the top-level \"tsickle_declare_module\".\n            this.emit('/** @const */\\n');\n            this.writeExternsVariable('tsickle_declare_module', [], '{}');\n            namespace = ['tsickle_declare_module'];\n\n            // Declare the inner \"tsickle_declare_module.foo\", if it's not\n            // declared already elsewhere.\n            let importName = (decl.name as ts.StringLiteral).text;\n            this.emit(`// Derived from: declare module \"${importName}\"\\n`);\n            // We also don't care about the actual name of the module (\"foo\"\n            // in the above example), except that we want it to not conflict.\n            importName = importName.replace(/_/, '__').replace(/[^A-Za-z]/g, '_');\n            if (this.isFirstDeclaration(decl)) {\n              this.emit('/** @const */\\n');\n              this.writeExternsVariable(importName, namespace, '{}');\n            }\n\n            // Declare the contents inside the \"tsickle_declare_module.foo\".\n            if (decl.body) this.visit(decl.body, namespace.concat(importName));\n            break;\n          default:\n            this.errorUnimplementedKind(decl.name, 'externs generation of namespace');\n        }\n        break;\n      case ts.SyntaxKind.ModuleBlock:\n        const block = node as ts.ModuleBlock;\n        for (const stmt of block.statements) {\n          this.visit(stmt, namespace);\n        }\n        break;\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this.writeExternsType(node as ts.InterfaceDeclaration | ts.ClassDeclaration, namespace);\n        break;\n      case ts.SyntaxKind.FunctionDeclaration:\n        const fnDecl = node as ts.FunctionDeclaration;\n        const name = fnDecl.name;\n        if (!name) {\n          this.error(fnDecl, 'anonymous function in externs');\n          break;\n        }\n        // Gather up all overloads of this function.\n        const sym = this.mustGetSymbolAtLocation(name);\n        const decls = sym.declarations!.filter(d => d.kind === ts.SyntaxKind.FunctionDeclaration) as\n            ts.FunctionDeclaration[];\n        // Only emit the first declaration of each overloaded function.\n        if (fnDecl !== decls[0]) break;\n        const params = this.emitFunctionType(decls);\n        this.writeExternsFunction(name, params, namespace);\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        for (const decl of (node as ts.VariableStatement).declarationList.declarations) {\n          this.writeExternsVariableDecl(decl, namespace);\n        }\n        break;\n      case ts.SyntaxKind.EnumDeclaration:\n        this.writeExternsEnum(node as ts.EnumDeclaration, namespace);\n        break;\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        this.writeExternsTypeAlias(node as ts.TypeAliasDeclaration, namespace);\n        break;\n      default:\n        this.emit(`\\n/* TODO: ${ts.SyntaxKind[node.kind]} in ${namespace.join('.')} */\\n`);\n        break;\n    }\n  }\n\n  /**\n   * isFirstDeclaration returns true if decl is the first declaration\n   * of its symbol.  E.g. imagine\n   *   interface Foo { x: number; }\n   *   interface Foo { y: number; }\n   * we only want to emit the \"@record\" for Foo on the first one.\n   */\n  private isFirstDeclaration(decl: ts.DeclarationStatement): boolean {\n    if (!decl.name) return true;\n    const sym = this.mustGetSymbolAtLocation(decl.name);\n    if (!sym.declarations || sym.declarations.length < 2) return true;\n    return decl === sym.declarations[0];\n  }\n\n  private writeExternsType(decl: ts.InterfaceDeclaration|ts.ClassDeclaration, namespace: string[]) {\n    const name = decl.name;\n    if (!name) {\n      this.error(decl, 'anonymous type in externs');\n      return;\n    }\n    const typeName = namespace.concat([name.getText()]).join('.');\n    if (closureExternsBlacklist.indexOf(typeName) >= 0) return;\n\n    if (this.isFirstDeclaration(decl)) {\n      let paramNames: string[] = [];\n      const jsdocTags: jsdoc.Tag[] = [];\n      let writeJsDoc = true;\n      this.maybeAddHeritageClauses(jsdocTags, decl);\n      if (decl.kind === ts.SyntaxKind.ClassDeclaration) {\n        jsdocTags.push({tagName: 'constructor'});\n        jsdocTags.push({tagName: 'struct'});\n        const ctors = (decl as ts.ClassDeclaration)\n                          .members.filter((m) => m.kind === ts.SyntaxKind.Constructor);\n        if (ctors.length) {\n          writeJsDoc = false;\n          const firstCtor: ts.ConstructorDeclaration = ctors[0] as ts.ConstructorDeclaration;\n          const ctorTags = [{tagName: 'constructor'}, {tagName: 'struct'}];\n          if (ctors.length > 1) {\n            paramNames = this.emitFunctionType(ctors as ts.ConstructorDeclaration[], ctorTags);\n          } else {\n            paramNames = this.emitFunctionType([firstCtor], ctorTags);\n          }\n        }\n      } else {\n        jsdocTags.push({tagName: 'record'});\n        jsdocTags.push({tagName: 'struct'});\n      }\n      if (writeJsDoc) this.emit(jsdoc.toString(jsdocTags));\n      this.writeExternsFunction(name, paramNames, namespace);\n    }\n\n    // Process everything except (MethodSignature|MethodDeclaration|Constructor)\n    const methods = new Map<string, ts.MethodDeclaration[]>();\n    for (const member of decl.members) {\n      switch (member.kind) {\n        case ts.SyntaxKind.PropertySignature:\n        case ts.SyntaxKind.PropertyDeclaration:\n          const prop = member as ts.PropertySignature;\n          if (prop.name.kind === ts.SyntaxKind.Identifier) {\n            this.emitJSDocType(prop);\n            if (hasModifierFlag(prop, ts.ModifierFlags.Static)) {\n              this.emit(`\\n${typeName}.${prop.name.getText()};\\n`);\n            } else {\n              this.emit(`\\n${typeName}.prototype.${prop.name.getText()};\\n`);\n            }\n            continue;\n          }\n          // TODO: For now property names other than Identifiers are not handled; e.g.\n          //    interface Foo { \"123bar\": number }\n          break;\n        case ts.SyntaxKind.MethodSignature:\n        case ts.SyntaxKind.MethodDeclaration:\n          const method = member as ts.MethodDeclaration;\n          const isStatic = hasModifierFlag(method, ts.ModifierFlags.Static);\n          const methodSignature = `${method.name.getText()}$$$${isStatic ? 'static' : 'instance'}`;\n\n          if (methods.has(methodSignature)) {\n            methods.get(methodSignature)!.push(method);\n          } else {\n            methods.set(methodSignature, [method]);\n          }\n          continue;\n        case ts.SyntaxKind.Constructor:\n          continue;  // Handled above.\n        default:\n          // Members can include things like index signatures, for e.g.\n          //   interface Foo { [key: string]: number; }\n          // For now, just skip it.\n          break;\n      }\n      // If we get here, the member wasn't handled in the switch statement.\n      let memberName = namespace;\n      if (member.name) {\n        memberName = memberName.concat([member.name.getText()]);\n      }\n      this.emit(`\\n/* TODO: ${ts.SyntaxKind[member.kind]}: ${memberName.join('.')} */\\n`);\n    }\n\n    // Handle method declarations/signatures separately, since we need to deal with overloads.\n    for (const methodVariants of Array.from(methods.values())) {\n      const firstMethodVariant = methodVariants[0];\n      let parameterNames: string[];\n      if (methodVariants.length > 1) {\n        parameterNames = this.emitFunctionType(methodVariants);\n      } else {\n        parameterNames = this.emitFunctionType([firstMethodVariant]);\n      }\n      const methodNamespace = namespace.concat([name.getText()]);\n      // If the method is static, don't add the prototype.\n      if (!hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {\n        methodNamespace.push('prototype');\n      }\n      this.writeExternsFunction(firstMethodVariant.name, parameterNames, methodNamespace);\n    }\n  }\n\n  private writeExternsVariableDecl(decl: ts.VariableDeclaration, namespace: string[]) {\n    if (decl.name.kind === ts.SyntaxKind.Identifier) {\n      const name = getIdentifierText(decl.name as ts.Identifier);\n      if (closureExternsBlacklist.indexOf(name) >= 0) return;\n      this.emitJSDocType(decl);\n      this.emit('\\n');\n      this.writeExternsVariable(name, namespace);\n    } else {\n      this.errorUnimplementedKind(decl.name, 'externs for variable');\n    }\n  }\n\n  private writeExternsVariable(name: string, namespace: string[], value?: string) {\n    const qualifiedName = namespace.concat([name]).join('.');\n    if (namespace.length === 0) this.emit(`var `);\n    this.emit(qualifiedName);\n    if (value) this.emit(` = ${value}`);\n    this.emit(';\\n');\n  }\n\n  private writeExternsFunction(name: ts.Node, params: string[], namespace: string[]) {\n    const paramsStr = params.join(', ');\n    if (namespace.length > 0) {\n      let fqn = namespace.join('.');\n      if (name.kind === ts.SyntaxKind.Identifier) {\n        fqn += '.';  // computed names include [ ] in their getText() representation.\n      }\n      fqn += name.getText();\n      this.emit(`${fqn} = function(${paramsStr}) {};\\n`);\n    } else {\n      if (name.kind !== ts.SyntaxKind.Identifier) {\n        this.error(name, 'Non-namespaced computed name in externs');\n      }\n      this.emit(`function ${name.getText()}(${paramsStr}) {}\\n`);\n    }\n  }\n\n  private writeExternsEnum(decl: ts.EnumDeclaration, namespace: string[]) {\n    const name = getIdentifierText(decl.name);\n    this.emit('\\n/** @const */\\n');\n    this.writeExternsVariable(name, namespace, '{}');\n    namespace = namespace.concat([name]);\n    for (const member of decl.members) {\n      let memberName: string|undefined;\n      switch (member.name.kind) {\n        case ts.SyntaxKind.Identifier:\n          memberName = getIdentifierText(member.name as ts.Identifier);\n          break;\n        case ts.SyntaxKind.StringLiteral:\n          const text = (member.name as ts.StringLiteral).text;\n          if (isValidClosurePropertyName(text)) memberName = text;\n          break;\n        default:\n          break;\n      }\n      if (!memberName) {\n        this.emit(`\\n/* TODO: ${ts.SyntaxKind[member.name.kind]}: ${member.name.getText()} */\\n`);\n        continue;\n      }\n      this.emit('/** @const {number} */\\n');\n      this.writeExternsVariable(memberName, namespace);\n    }\n  }\n\n  private writeExternsTypeAlias(decl: ts.TypeAliasDeclaration, namespace: string[]) {\n    this.emit(`\\n/** @typedef {${this.typeToClosure(decl)}} */\\n`);\n    this.writeExternsVariable(getIdentifierText(decl.name), namespace);\n  }\n}\n\nfunction isPolymerBehaviorPropertyInCallExpression(pa: ts.PropertyAssignment): boolean {\n  const parentParent = pa.parent && pa.parent.parent;\n  if (pa.name.kind !== ts.SyntaxKind.Identifier ||\n      (pa.name as ts.Identifier).text !== 'behaviors' || !pa.parent || !pa.parent.parent ||\n      pa.parent.parent.kind !== ts.SyntaxKind.CallExpression) {\n    return false;\n  }\n\n  const expr = (parentParent as ts.CallExpression).expression;\n  return expr.kind === ts.SyntaxKind.Identifier && (expr as ts.Identifier).text === 'Polymer';\n}\n\nexport function annotate(\n    typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost,\n    tsHost?: ts.ModuleResolutionHost, tsOpts?: ts.CompilerOptions,\n    sourceMapper?: SourceMapper): {output: string, diagnostics: ts.Diagnostic[]} {\n  return new Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper).annotate();\n}\n\nexport function writeExterns(typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost):\n    {output: string, diagnostics: ts.Diagnostic[]} {\n  return new ExternsWriter(typeChecker, file, host).process();\n}\n\n/** Concatenate all generated externs definitions together into a string. */\nexport function getGeneratedExterns(externs: {[fileName: string]: string}): string {\n  let allExterns = EXTERNS_HEADER;\n  for (const fileName of Object.keys(externs)) {\n    allExterns += `// externs from ${fileName}:\\n`;\n    allExterns += externs[fileName];\n  }\n  return allExterns;\n}\n\nexport interface TsickleHost extends es5processor.Es5ProcessorHost, AnnotatorHost {\n  /**\n   * Whether to downlevel decorators\n   */\n  transformDecorators?: boolean;\n  /**\n   * Whether to convers types to closure\n   */\n  transformTypesToClosure?: boolean;\n  /**\n   * If true, tsickle and decorator downlevel processing will be skipped for\n   * that file.\n   */\n  shouldSkipTsickleProcessing(fileName: string): boolean;\n  /**\n   * Tsickle treats warnings as errors, if true, ignore warnings.  This might be\n   * useful for e.g. third party code.\n   */\n  shouldIgnoreWarningsForPath(filePath: string): boolean;\n}\n\nexport function mergeEmitResults(emitResults: EmitResult[]): EmitResult {\n  const diagnostics: ts.Diagnostic[] = [];\n  let emitSkipped = true;\n  const emittedFiles: string[] = [];\n  const externs: {[fileName: string]: string} = {};\n  const modulesManifest = new ModulesManifest();\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...er.emittedFiles);\n    Object.assign(externs, er.externs);\n    modulesManifest.addManifest(er.modulesManifest);\n  }\n  return {diagnostics, emitSkipped, emittedFiles, externs, modulesManifest};\n}\n\nexport interface EmitResult extends ts.EmitResult {\n  // The manifest of JS modules output by the compiler.\n  modulesManifest: ModulesManifest;\n  /** externs.js files produced by tsickle, if any. */\n  externs: {[fileName: string]: string};\n}\n\nexport interface EmitTransformers {\n  beforeTsickle?: Array<ts.TransformerFactory<ts.SourceFile>>;\n  beforeTs?: Array<ts.TransformerFactory<ts.SourceFile>>;\n  afterTs?: Array<ts.TransformerFactory<ts.SourceFile>>;\n}\n\nexport function emitWithTsickle(\n    program: ts.Program, host: TsickleHost, tsHost: ts.CompilerHost, tsOptions: ts.CompilerOptions,\n    targetSourceFile?: ts.SourceFile, writeFile?: ts.WriteFileCallback,\n    cancellationToken?: ts.CancellationToken, emitOnlyDtsFiles?: boolean,\n    customTransformers: EmitTransformers = {}): EmitResult {\n  let tsickleDiagnostics: ts.Diagnostic[] = [];\n  const typeChecker = program.getTypeChecker();\n  const tsickleSourceTransformers: Array<ts.TransformerFactory<ts.SourceFile>> = [];\n  // add tsickle transformers\n  if (host.transformTypesToClosure) {\n    // Note: tsickle.annotate can also lower decorators in the same run.\n    tsickleSourceTransformers.push(createTransformerFromSourceMap((sourceFile, sourceMapper) => {\n      const {output, diagnostics} =\n          annotate(typeChecker, sourceFile, host, tsHost, tsOptions, sourceMapper);\n      tsickleDiagnostics.push(...diagnostics);\n      return output;\n    }));\n  } else if (host.transformDecorators) {\n    tsickleSourceTransformers.push(createTransformerFromSourceMap((sourceFile, sourceMapper) => {\n      const {output, diagnostics} =\n          decorator.convertDecorators(typeChecker, sourceFile, sourceMapper);\n      tsickleDiagnostics.push(...diagnostics);\n      return output;\n    }));\n  }\n  // // For debugging: transformer that just emits the same text.\n  // beforeTsTransformers.push(createTransformer(host, typeChecker, (sourceFile, sourceMapper) => {\n  //   sourceMapper.addMapping(sourceFile, {position: 0, line: 0, column: 0}, {position: 0, line: 0,\n  //   column: 0}, sourceFile.text.length); return sourceFile.text;\n  // }));\n  const tsickleTransformers = createCustomTransformers({before: tsickleSourceTransformers});\n  const tsTransformers: ts.CustomTransformers = {\n    before: [\n      ...(customTransformers.beforeTsickle || []),\n      ...(tsickleTransformers.before || []).map(tf => skipTransformForSourceFileIfNeeded(host, tf)),\n      ...(customTransformers.beforeTs || []),\n    ],\n    after: [\n      ...(customTransformers.afterTs || []),\n      ...(tsickleTransformers.after || []).map(tf => skipTransformForSourceFileIfNeeded(host, tf))\n    ]\n  };\n\n  const writeFileDelegate = writeFile || tsHost.writeFile.bind(tsHost);\n  const modulesManifest = new ModulesManifest();\n  const writeFileImpl =\n      (fileName: string, content: string, writeByteOrderMark: boolean,\n       onError?: (message: string) => void, sourceFiles?: ts.SourceFile[]) => {\n        if (path.extname(fileName) !== '.map') {\n          if (tsOptions.inlineSourceMap) {\n            content = combineInlineSourceMaps(program, fileName, content);\n          } else {\n            content = removeInlineSourceMap(content);\n          }\n          content = es5processor.convertCommonJsToGoogModuleIfNeeded(\n              host, modulesManifest, fileName, content);\n        } else {\n          content = combineSourceMaps(program, fileName, content);\n        }\n        writeFileDelegate(fileName, content, writeByteOrderMark, onError, sourceFiles);\n      };\n\n  const {diagnostics: tsDiagnostics, emitSkipped, emittedFiles} = program.emit(\n      targetSourceFile, writeFileImpl, cancellationToken, emitOnlyDtsFiles, tsTransformers);\n\n  const externs: {[fileName: string]: string} = {};\n  if (host.transformTypesToClosure) {\n    const sourceFiles = targetSourceFile ? [targetSourceFile] : program.getSourceFiles();\n    sourceFiles.forEach(sf => {\n      if (isDtsFileName(sf.fileName) && host.shouldSkipTsickleProcessing(sf.fileName)) {\n        return;\n      }\n      const {output, diagnostics} = writeExterns(typeChecker, sf, host);\n      if (output) {\n        externs[sf.fileName] = output;\n      }\n      if (diagnostics) {\n        tsickleDiagnostics.push(...diagnostics);\n      }\n    });\n  }\n  // All diagnostics (including warnings) are treated as errors.\n  // If the host decides to ignore warnings, just discard them.\n  // Warnings include stuff like \"don't use @type in your jsdoc\"; tsickle\n  // warns and then fixes up the code to be Closure-compatible anyway.\n  tsickleDiagnostics = tsickleDiagnostics.filter(\n      d => d.category === ts.DiagnosticCategory.Error ||\n          !host.shouldIgnoreWarningsForPath(d.file!.fileName));\n\n  return {\n    modulesManifest,\n    emitSkipped,\n    emittedFiles: emittedFiles || [],\n    diagnostics: [...tsDiagnostics, ...tsickleDiagnostics],\n    externs\n  };\n}\n\nfunction skipTransformForSourceFileIfNeeded(\n    host: TsickleHost,\n    delegateFactory: ts.TransformerFactory<ts.SourceFile>): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const delegate = delegateFactory(context);\n    return (sourceFile: ts.SourceFile) => {\n      if (host.shouldSkipTsickleProcessing(sourceFile.fileName)) {\n        return sourceFile;\n      }\n      return delegate(sourceFile);\n    };\n  };\n}\n\nfunction combineInlineSourceMaps(\n    program: ts.Program, filePath: string, compiledJsWithInlineSourceMap: string): string {\n  if (isDtsFileName(filePath)) {\n    return compiledJsWithInlineSourceMap;\n  }\n  const sourceMapJson = extractInlineSourceMap(compiledJsWithInlineSourceMap);\n  compiledJsWithInlineSourceMap = removeInlineSourceMap(compiledJsWithInlineSourceMap);\n  const composedSourceMap = combineSourceMaps(program, filePath, sourceMapJson);\n  return setInlineSourceMap(compiledJsWithInlineSourceMap, composedSourceMap);\n}\n\nfunction combineSourceMaps(\n    program: ts.Program, filePath: string, tscSourceMapText: string): string {\n  const tscSourceMap = parseSourceMap(tscSourceMapText);\n  if (tscSourceMap.sourcesContent) {\n    // strip incoming sourcemaps from the sources in the sourcemap\n    // to reduce the size of the sourcemap.\n    tscSourceMap.sourcesContent = tscSourceMap.sourcesContent.map(content => {\n      if (containsInlineSourceMap(content)) {\n        content = removeInlineSourceMap(content);\n      }\n      return content;\n    });\n  }\n  const fileDir = path.dirname(filePath);\n  let tscSourceMapGenerator: SourceMapGenerator|undefined;\n  for (const sourceFileName of tscSourceMap.sources) {\n    const sourceFile = program.getSourceFile(path.resolve(fileDir, sourceFileName));\n    if (!sourceFile || !containsInlineSourceMap(sourceFile.text)) {\n      continue;\n    }\n    const preexistingSourceMapText = extractInlineSourceMap(sourceFile.text);\n    if (!tscSourceMapGenerator) {\n      tscSourceMapGenerator = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(tscSourceMap));\n    }\n    tscSourceMapGenerator.applySourceMap(\n        new SourceMapConsumer(parseSourceMap(preexistingSourceMapText, sourceFileName)));\n  }\n  return tscSourceMapGenerator ? tscSourceMapGenerator.toString() : tscSourceMapText;\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/decorator-annotator.ts","node_modules/tsickle/src/decorators.ts","node_modules/tsickle/src/es5processor.ts","node_modules/tsickle/src/jsdoc.ts","node_modules/tsickle/src/modules_manifest.ts","node_modules/tsickle/src/rewriter.ts","node_modules/tsickle/src/source_map_utils.ts","node_modules/tsickle/src/transformer_sourcemap.ts","node_modules/tsickle/src/transformer_util.ts","node_modules/tsickle/src/type-translator.ts","node_modules/tsickle/src/util.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"path","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"source-map","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./decorator-annotator","resolvedPath":"node_modules/tsickle/src/decorator-annotator","external":false,"resolved":true},{"modulePath":"./decorators","resolvedPath":"node_modules/tsickle/src/decorators","external":false,"resolved":true},{"modulePath":"./es5processor","resolvedPath":"node_modules/tsickle/src/es5processor","external":false,"resolved":true},{"modulePath":"./jsdoc","resolvedPath":"node_modules/tsickle/src/jsdoc","external":false,"resolved":true},{"modulePath":"./modules_manifest","resolvedPath":"node_modules/tsickle/src/modules_manifest","external":false,"resolved":true},{"modulePath":"./rewriter","resolvedPath":"node_modules/tsickle/src/rewriter","external":false,"resolved":true},{"modulePath":"./source_map_utils","resolvedPath":"node_modules/tsickle/src/source_map_utils","external":false,"resolved":true},{"modulePath":"./transformer_sourcemap","resolvedPath":"node_modules/tsickle/src/transformer_sourcemap","external":false,"resolved":true},{"modulePath":"./transformer_util","resolvedPath":"node_modules/tsickle/src/transformer_util","external":false,"resolved":true},{"modulePath":"./type-translator","resolvedPath":"node_modules/tsickle/src/type-translator","external":false,"resolved":true},{"modulePath":"./util","resolvedPath":"node_modules/tsickle/src/util","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Cannot find module 'path'.","line":9,"column":23},{"code":2307,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Cannot find module 'source-map'.","line":10,"column":67},{"code":2307,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Cannot find module 'typescript'.","line":11,"column":21},{"code":2354,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"This syntax requires an imported helper but module 'tslib' cannot be found.","line":180,"column":23},{"code":2339,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Property 'diagnostics' does not exist on type 'EmitResult'.","line":1952,"column":28},{"code":2339,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Property 'emitSkipped' does not exist on type 'EmitResult'.","line":1953,"column":37},{"code":2339,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Property 'emittedFiles' does not exist on type 'EmitResult'.","line":1954,"column":29},{"code":2322,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Type '{ diagnostics: any[]; emitSkipped: boolean; emittedFiles: string[]; externs: { [fileName: string]...' is not assignable to type 'EmitResult'.\n  Object literal may only specify known properties, and 'diagnostics' does not exist in type 'EmitResult'.","line":1958,"column":11},{"code":2322,"fileName":"node_modules/tsickle/src/tsickle.ts","message":"Type '{ modulesManifest: ModulesManifest; emitSkipped: any; emittedFiles: any; diagnostics: any[]; exte...' is not assignable to type 'EmitResult'.\n  Object literal may only specify known properties, and 'emitSkipped' does not exist in type 'EmitResult'.","line":2065,"column":5}]},"hash":"e73e0582640a757093fae28556607dd883fef505"}