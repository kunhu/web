{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar ts = require(\"typescript\");\r\nvar util_1 = require(\"./util\");\r\n/**\r\n * Determines if fileName refers to a builtin lib.d.ts file.\r\n * This is a terrible hack but it mirrors a similar thing done in Clutz.\r\n */\r\nfunction isBuiltinLibDTS(fileName) {\r\n    return fileName.match(/\\blib\\.(?:[^/]+\\.)?d\\.ts$/) != null;\r\n}\r\nexports.isBuiltinLibDTS = isBuiltinLibDTS;\r\n/**\r\n * @return True if the named type is considered compatible with the Closure-defined\r\n *     type of the same name, e.g. \"Array\".  Note that we don't actually enforce\r\n *     that the types are actually compatible, but mostly just hope that they are due\r\n *     to being derived from the same HTML specs.\r\n */\r\nfunction isClosureProvidedType(symbol) {\r\n    return symbol.declarations != null &&\r\n        symbol.declarations.some(function (n) { return isBuiltinLibDTS(n.getSourceFile().fileName); });\r\n}\r\nfunction typeToDebugString(type) {\r\n    var debugString = \"flags:0x\" + type.flags.toString(16);\r\n    // Just the unique flags (powers of two). Declared in src/compiler/types.ts.\r\n    var basicTypes = [\r\n        ts.TypeFlags.Any, ts.TypeFlags.String, ts.TypeFlags.Number,\r\n        ts.TypeFlags.Boolean, ts.TypeFlags.Enum, ts.TypeFlags.StringLiteral,\r\n        ts.TypeFlags.NumberLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.EnumLiteral,\r\n        ts.TypeFlags.ESSymbol, ts.TypeFlags.Void, ts.TypeFlags.Undefined,\r\n        ts.TypeFlags.Null, ts.TypeFlags.Never, ts.TypeFlags.TypeParameter,\r\n        ts.TypeFlags.Object, ts.TypeFlags.Union, ts.TypeFlags.Intersection,\r\n        ts.TypeFlags.Index, ts.TypeFlags.IndexedAccess, ts.TypeFlags.NonPrimitive,\r\n    ];\r\n    for (var _i = 0, basicTypes_1 = basicTypes; _i < basicTypes_1.length; _i++) {\r\n        var flag = basicTypes_1[_i];\r\n        if ((type.flags & flag) !== 0) {\r\n            debugString += \" \" + ts.TypeFlags[flag];\r\n        }\r\n    }\r\n    if (type.flags === ts.TypeFlags.Object) {\r\n        var objType = type;\r\n        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.\r\n        var objectFlags = [\r\n            ts.ObjectFlags.Class,\r\n            ts.ObjectFlags.Interface,\r\n            ts.ObjectFlags.Reference,\r\n            ts.ObjectFlags.Tuple,\r\n            ts.ObjectFlags.Anonymous,\r\n            ts.ObjectFlags.Mapped,\r\n            ts.ObjectFlags.Instantiated,\r\n            ts.ObjectFlags.ObjectLiteral,\r\n            ts.ObjectFlags.EvolvingArray,\r\n            ts.ObjectFlags.ObjectLiteralPatternWithComputedProperties,\r\n        ];\r\n        for (var _a = 0, objectFlags_1 = objectFlags; _a < objectFlags_1.length; _a++) {\r\n            var flag = objectFlags_1[_a];\r\n            if ((objType.objectFlags & flag) !== 0) {\r\n                debugString += \" object:\" + ts.ObjectFlags[flag];\r\n            }\r\n        }\r\n    }\r\n    if (type.symbol && type.symbol.name !== '__type') {\r\n        debugString += \" symbol.name:\" + JSON.stringify(type.symbol.name);\r\n    }\r\n    if (type.pattern) {\r\n        debugString += \" destructuring:true\";\r\n    }\r\n    return \"{type \" + debugString + \"}\";\r\n}\r\nexports.typeToDebugString = typeToDebugString;\r\nfunction symbolToDebugString(sym) {\r\n    var debugString = JSON.stringify(sym.name) + \" flags:0x\" + sym.flags.toString(16);\r\n    // Just the unique flags (powers of two). Declared in src/compiler/types.ts.\r\n    var symbolFlags = [\r\n        ts.SymbolFlags.FunctionScopedVariable,\r\n        ts.SymbolFlags.BlockScopedVariable,\r\n        ts.SymbolFlags.Property,\r\n        ts.SymbolFlags.EnumMember,\r\n        ts.SymbolFlags.Function,\r\n        ts.SymbolFlags.Class,\r\n        ts.SymbolFlags.Interface,\r\n        ts.SymbolFlags.ConstEnum,\r\n        ts.SymbolFlags.RegularEnum,\r\n        ts.SymbolFlags.ValueModule,\r\n        ts.SymbolFlags.NamespaceModule,\r\n        ts.SymbolFlags.TypeLiteral,\r\n        ts.SymbolFlags.ObjectLiteral,\r\n        ts.SymbolFlags.Method,\r\n        ts.SymbolFlags.Constructor,\r\n        ts.SymbolFlags.GetAccessor,\r\n        ts.SymbolFlags.SetAccessor,\r\n        ts.SymbolFlags.Signature,\r\n        ts.SymbolFlags.TypeParameter,\r\n        ts.SymbolFlags.TypeAlias,\r\n        ts.SymbolFlags.ExportValue,\r\n        ts.SymbolFlags.ExportType,\r\n        ts.SymbolFlags.ExportNamespace,\r\n        ts.SymbolFlags.Alias,\r\n        ts.SymbolFlags.Prototype,\r\n        ts.SymbolFlags.ExportStar,\r\n        ts.SymbolFlags.Optional,\r\n        ts.SymbolFlags.Transient,\r\n    ];\r\n    for (var _i = 0, symbolFlags_1 = symbolFlags; _i < symbolFlags_1.length; _i++) {\r\n        var flag = symbolFlags_1[_i];\r\n        if ((sym.flags & flag) !== 0) {\r\n            debugString += \" \" + ts.SymbolFlags[flag];\r\n        }\r\n    }\r\n    return debugString;\r\n}\r\nexports.symbolToDebugString = symbolToDebugString;\r\n/** TypeTranslator translates TypeScript types to Closure types. */\r\nvar TypeTranslator = /** @class */ (function () {\r\n    /**\r\n     * @param node is the source AST ts.Node the type comes from.  This is used\r\n     *     in some cases (e.g. anonymous types) for looking up field names.\r\n     * @param pathBlackList is a set of paths that should never get typed;\r\n     *     any reference to symbols defined in these paths should by typed\r\n     *     as {?}.\r\n     * @param symbolsToPrefix a mapping from symbols (`Foo`) to a prefix they should be emitted with\r\n     *     (`tsickle_import.Foo`).\r\n     */\r\n    function TypeTranslator(typeChecker, node, pathBlackList, symbolsToAliasedNames) {\r\n        if (symbolsToAliasedNames === void 0) { symbolsToAliasedNames = new Map(); }\r\n        this.typeChecker = typeChecker;\r\n        this.node = node;\r\n        this.pathBlackList = pathBlackList;\r\n        this.symbolsToAliasedNames = symbolsToAliasedNames;\r\n        /**\r\n         * A list of types we've encountered while emitting; used to avoid getting stuck in recursive\r\n         * types.\r\n         */\r\n        this.seenTypes = [];\r\n        /**\r\n         * Whether to write types suitable for an \\@externs file. Externs types must not refer to\r\n         * non-externs types (i.e. non ambient types) and need to use fully qualified names.\r\n         */\r\n        this.isForExterns = false;\r\n        // Normalize paths to not break checks on Windows.\r\n        if (this.pathBlackList != null) {\r\n            this.pathBlackList =\r\n                new Set(Array.from(this.pathBlackList.values()).map(function (p) { return path.normalize(p); }));\r\n        }\r\n    }\r\n    /**\r\n     * Converts a ts.Symbol to a string.\r\n     * Other approaches that don't work:\r\n     * - TypeChecker.typeToString translates Array as T[].\r\n     * - TypeChecker.symbolToString emits types without their namespace,\r\n     *   and doesn't let you pass the flag to control that.\r\n     * @param useFqn whether to scope the name using its fully qualified name. Closure's template\r\n     *     arguments are always scoped to the class containing them, where TypeScript's template args\r\n     *     would be fully qualified. I.e. this flag is false for generic types.\r\n     */\r\n    TypeTranslator.prototype.symbolToString = function (sym, useFqn) {\r\n        // This follows getSingleLineStringWriter in the TypeScript compiler.\r\n        var str = '';\r\n        var symAlias = sym;\r\n        if (symAlias.flags & ts.SymbolFlags.Alias) {\r\n            symAlias = this.typeChecker.getAliasedSymbol(symAlias);\r\n        }\r\n        var alias = this.symbolsToAliasedNames.get(symAlias);\r\n        if (alias)\r\n            return alias;\r\n        if (useFqn && this.isForExterns) {\r\n            // For regular type emit, we can use TypeScript's naming rules, as they match Closure's name\r\n            // scoping rules. However when emitting externs files for ambients, naming rules change. As\r\n            // Closure doesn't support externs modules, all names must be global and use global fully\r\n            // qualified names. The code below uses TypeScript to convert a symbol to a full qualified\r\n            // name and then emits that.\r\n            var fqn = this.typeChecker.getFullyQualifiedName(sym);\r\n            if (fqn.startsWith(\"\\\"\") || fqn.startsWith(\"'\")) {\r\n                // Quoted FQNs mean the name is from a module, e.g. `'path/to/module'.some.qualified.Name`.\r\n                // tsickle generally re-scopes names in modules that are moved to externs into the global\r\n                // namespace. That does not quite match TS' semantics where ambient types from modules are\r\n                // local. However value declarations that are local to modules but not defined do not make\r\n                // sense if not global, e.g. \"declare class X {}; new X();\" cannot work unless `X` is\r\n                // actually a global.\r\n                // So this code strips the module path from the type and uses the FQN as a global.\r\n                fqn = fqn.replace(/^[\"'][^\"']+['\"]\\./, '');\r\n            }\r\n            // Declarations in module can re-open global types using \"declare global { ... }\". The fqn\r\n            // then contains the prefix \"global.\" here. As we're mapping to global types, just strip the\r\n            // prefix.\r\n            var isInGlobal = (sym.declarations || []).some(function (d) {\r\n                var current = d;\r\n                while (current) {\r\n                    if (current.flags & ts.NodeFlags.GlobalAugmentation)\r\n                        return true;\r\n                    current = current.parent;\r\n                }\r\n                return false;\r\n            });\r\n            if (isInGlobal) {\r\n                fqn = fqn.replace(/^global\\./, '');\r\n            }\r\n            return this.stripClutzNamespace(fqn);\r\n        }\r\n        var writeText = function (text) { return str += text; };\r\n        var doNothing = function () {\r\n            return;\r\n        };\r\n        var builder = this.typeChecker.getSymbolDisplayBuilder();\r\n        var writer = {\r\n            writeKeyword: writeText,\r\n            writeOperator: writeText,\r\n            writePunctuation: writeText,\r\n            writeSpace: writeText,\r\n            writeStringLiteral: writeText,\r\n            writeParameter: writeText,\r\n            writeProperty: writeText,\r\n            writeSymbol: writeText,\r\n            writeLine: doNothing,\r\n            increaseIndent: doNothing,\r\n            decreaseIndent: doNothing,\r\n            clear: doNothing,\r\n            trackSymbol: function (symbol, enclosingDeclaration, meaning) {\r\n                return;\r\n            },\r\n            reportInaccessibleThisError: doNothing,\r\n            reportPrivateInBaseOfClassExpression: doNothing,\r\n        };\r\n        builder.buildSymbolDisplay(sym, writer, this.node);\r\n        return this.stripClutzNamespace(str);\r\n    };\r\n    // Clutz (https://github.com/angular/clutz) emits global type symbols hidden in a special\r\n    // ಠ_ಠ.clutz namespace. While most code seen by Tsickle will only ever see local aliases, Clutz\r\n    // symbols can be written by users directly in code, and they can appear by dereferencing\r\n    // TypeAliases. The code below simply strips the prefix, the remaining type name then matches\r\n    // Closure's type.\r\n    TypeTranslator.prototype.stripClutzNamespace = function (name) {\r\n        if (name.startsWith('ಠ_ಠ.clutz.'))\r\n            return name.substring('ಠ_ಠ.clutz.'.length);\r\n        return name;\r\n    };\r\n    TypeTranslator.prototype.translate = function (type) {\r\n        // NOTE: Though type.flags has the name \"flags\", it usually can only be one\r\n        // of the enum options at a time (except for unions of literal types, e.g. unions of boolean\r\n        // values, string values, enum values). This switch handles all the cases in the ts.TypeFlags\r\n        // enum in the order they occur.\r\n        // NOTE: Some TypeFlags are marked \"internal\" in the d.ts but still show up in the value of\r\n        // type.flags. This mask limits the flag checks to the ones in the public API. \"lastFlag\" here\r\n        // is the last flag handled in this switch statement, and should be kept in sync with\r\n        // typescript.d.ts.\r\n        // NonPrimitive occurs on its own on the lower case \"object\" type. Special case to \"!Object\".\r\n        if (type.flags === ts.TypeFlags.NonPrimitive)\r\n            return '!Object';\r\n        var isAmbient = false;\r\n        var isNamespace = false;\r\n        var isModule = false;\r\n        if (type.symbol) {\r\n            for (var _i = 0, _a = type.symbol.declarations || []; _i < _a.length; _i++) {\r\n                var decl = _a[_i];\r\n                if (ts.isExternalModule(decl.getSourceFile()))\r\n                    isModule = true;\r\n                var current = decl;\r\n                while (current) {\r\n                    if (ts.getCombinedModifierFlags(current) & ts.ModifierFlags.Ambient)\r\n                        isAmbient = true;\r\n                    if (current.kind === ts.SyntaxKind.ModuleDeclaration)\r\n                        isNamespace = true;\r\n                    current = current.parent;\r\n                }\r\n            }\r\n        }\r\n        // tsickle cannot generate types for non-ambient namespaces.\r\n        if (isNamespace && !isAmbient)\r\n            return '?';\r\n        // Types in externs cannot reference types from external modules.\r\n        // However ambient types in modules get moved to externs, too, so type references work and we\r\n        // can emit a precise type.\r\n        if (this.isForExterns && isModule && !isAmbient)\r\n            return '?';\r\n        var lastFlag = ts.TypeFlags.IndexedAccess;\r\n        var mask = (lastFlag << 1) - 1;\r\n        switch (type.flags & mask) {\r\n            case ts.TypeFlags.Any:\r\n                return '?';\r\n            case ts.TypeFlags.String:\r\n            case ts.TypeFlags.StringLiteral:\r\n                return 'string';\r\n            case ts.TypeFlags.Number:\r\n            case ts.TypeFlags.NumberLiteral:\r\n                return 'number';\r\n            case ts.TypeFlags.Boolean:\r\n            case ts.TypeFlags.BooleanLiteral:\r\n                // See the note in translateUnion about booleans.\r\n                return 'boolean';\r\n            case ts.TypeFlags.Enum:\r\n                if (!type.symbol) {\r\n                    this.warn(\"EnumType without a symbol\");\r\n                    return '?';\r\n                }\r\n                return this.symbolToString(type.symbol, true);\r\n            case ts.TypeFlags.ESSymbol:\r\n                // NOTE: currently this is just a typedef for {?}, shrug.\r\n                // https://github.com/google/closure-compiler/blob/55cf43ee31e80d89d7087af65b5542aa63987874/externs/es3.js#L34\r\n                return 'symbol';\r\n            case ts.TypeFlags.Void:\r\n                return 'void';\r\n            case ts.TypeFlags.Undefined:\r\n                return 'undefined';\r\n            case ts.TypeFlags.Null:\r\n                return 'null';\r\n            case ts.TypeFlags.Never:\r\n                this.warn(\"should not emit a 'never' type\");\r\n                return '?';\r\n            case ts.TypeFlags.TypeParameter:\r\n                // This is e.g. the T in a type like Foo<T>.\r\n                if (!type.symbol) {\r\n                    this.warn(\"TypeParameter without a symbol\"); // should not happen (tm)\r\n                    return '?';\r\n                }\r\n                // In Closure Compiler, type parameters *are* scoped to their containing class.\r\n                var useFqn = false;\r\n                return this.symbolToString(type.symbol, useFqn);\r\n            case ts.TypeFlags.Object:\r\n                return this.translateObject(type);\r\n            case ts.TypeFlags.Union:\r\n                return this.translateUnion(type);\r\n            case ts.TypeFlags.Intersection:\r\n            case ts.TypeFlags.Index:\r\n            case ts.TypeFlags.IndexedAccess:\r\n                // TODO(ts2.1): handle these special types.\r\n                this.warn(\"unhandled type flags: \" + ts.TypeFlags[type.flags]);\r\n                return '?';\r\n            default:\r\n                // Handle cases where multiple flags are set.\r\n                // Types with literal members are represented as\r\n                //   ts.TypeFlags.Union | [literal member]\r\n                // E.g. an enum typed value is a union type with the enum's members as its members. A\r\n                // boolean type is a union type with 'true' and 'false' as its members.\r\n                // Note also that in a more complex union, e.g. boolean|number, then it's a union of three\r\n                // things (true|false|number) and ts.TypeFlags.Boolean doesn't show up at all.\r\n                if (type.flags & ts.TypeFlags.Union) {\r\n                    return this.translateUnion(type);\r\n                }\r\n                if (type.flags & ts.TypeFlags.EnumLiteral) {\r\n                    return this.translateEnumLiteral(type);\r\n                }\r\n                // The switch statement should have been exhaustive.\r\n                throw new Error(\"unknown type flags \" + type.flags + \" on \" + typeToDebugString(type));\r\n        }\r\n    };\r\n    TypeTranslator.prototype.translateUnion = function (type) {\r\n        var _this = this;\r\n        var parts = type.types.map(function (t) { return _this.translate(t); });\r\n        // Union types that include literals (e.g. boolean, enum) can end up repeating the same Closure\r\n        // type. For example: true | boolean will be translated to boolean | boolean.\r\n        // Remove duplicates to produce types that read better.\r\n        parts = parts.filter(function (el, idx) { return parts.indexOf(el) === idx; });\r\n        return parts.length === 1 ? parts[0] : \"(\" + parts.join('|') + \")\";\r\n    };\r\n    TypeTranslator.prototype.translateEnumLiteral = function (type) {\r\n        // Suppose you had:\r\n        //   enum EnumType { MEMBER }\r\n        // then the type of \"EnumType.MEMBER\" is an enum literal (the thing passed to this function)\r\n        // and it has type flags that include\r\n        //   ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral\r\n        //\r\n        // Closure Compiler doesn't support literals in types, so this code must not emit\r\n        // \"EnumType.MEMBER\", but rather \"EnumType\".\r\n        var enumLiteralBaseType = this.typeChecker.getBaseTypeOfLiteralType(type);\r\n        if (!enumLiteralBaseType.symbol) {\r\n            this.warn(\"EnumLiteralType without a symbol\");\r\n            return '?';\r\n        }\r\n        return this.symbolToString(enumLiteralBaseType.symbol, true);\r\n    };\r\n    // translateObject translates a ts.ObjectType, which is the type of all\r\n    // object-like things in TS, such as classes and interfaces.\r\n    TypeTranslator.prototype.translateObject = function (type) {\r\n        var _this = this;\r\n        if (type.symbol && this.isBlackListed(type.symbol))\r\n            return '?';\r\n        // NOTE: objectFlags is an enum, but a given type can have multiple flags.\r\n        // Array<string> is both ts.ObjectFlags.Reference and ts.ObjectFlags.Interface.\r\n        if (type.objectFlags & ts.ObjectFlags.Class) {\r\n            if (!type.symbol) {\r\n                this.warn('class has no symbol');\r\n                return '?';\r\n            }\r\n            return '!' + this.symbolToString(type.symbol, /* useFqn */ true);\r\n        }\r\n        else if (type.objectFlags & ts.ObjectFlags.Interface) {\r\n            // Note: ts.InterfaceType has a typeParameters field, but that\r\n            // specifies the parameters that the interface type *expects*\r\n            // when it's used, and should not be transformed to the output.\r\n            // E.g. a type like Array<number> is a TypeReference to the\r\n            // InterfaceType \"Array\", but the \"number\" type parameter is\r\n            // part of the outer TypeReference, not a typeParameter on\r\n            // the InterfaceType.\r\n            if (!type.symbol) {\r\n                this.warn('interface has no symbol');\r\n                return '?';\r\n            }\r\n            if (type.symbol.flags & ts.SymbolFlags.Value) {\r\n                // The symbol is both a type and a value.\r\n                // For user-defined types in this state, we don't have a Closure name\r\n                // for the type.  See the type_and_value test.\r\n                if (!isClosureProvidedType(type.symbol)) {\r\n                    this.warn(\"type/symbol conflict for \" + type.symbol.name + \", using {?} for now\");\r\n                    return '?';\r\n                }\r\n            }\r\n            return '!' + this.symbolToString(type.symbol, /* useFqn */ true);\r\n        }\r\n        else if (type.objectFlags & ts.ObjectFlags.Reference) {\r\n            // A reference to another type, e.g. Array<number> refers to Array.\r\n            // Emit the referenced type and any type arguments.\r\n            var referenceType = type;\r\n            // A tuple is a ReferenceType where the target is flagged Tuple and the\r\n            // typeArguments are the tuple arguments.  Just treat it as a mystery\r\n            // array, because Closure doesn't understand tuples.\r\n            if (referenceType.target.objectFlags & ts.ObjectFlags.Tuple) {\r\n                return '!Array<?>';\r\n            }\r\n            var typeStr = '';\r\n            if (referenceType.target === referenceType) {\r\n                // We get into an infinite loop here if the inner reference is\r\n                // the same as the outer; this can occur when this function\r\n                // fails to translate a more specific type before getting to\r\n                // this point.\r\n                throw new Error(\"reference loop in \" + typeToDebugString(referenceType) + \" \" + referenceType.flags);\r\n            }\r\n            typeStr += this.translate(referenceType.target);\r\n            // Translate can return '?' for a number of situations, e.g. type/value conflicts.\r\n            // `?<?>` is illegal syntax in Closure Compiler, so just return `?` here.\r\n            if (typeStr === '?')\r\n                return '?';\r\n            if (referenceType.typeArguments) {\r\n                var params = referenceType.typeArguments.map(function (t) { return _this.translate(t); });\r\n                typeStr += \"<\" + params.join(', ') + \">\";\r\n            }\r\n            return typeStr;\r\n        }\r\n        else if (type.objectFlags & ts.ObjectFlags.Anonymous) {\r\n            if (!type.symbol) {\r\n                // This comes up when generating code for an arrow function as passed\r\n                // to a generic function.  The passed-in type is tagged as anonymous\r\n                // and has no properties so it's hard to figure out what to generate.\r\n                // Just avoid it for now so we don't crash.\r\n                this.warn('anonymous type has no symbol');\r\n                return '?';\r\n            }\r\n            if (type.symbol.flags & ts.SymbolFlags.TypeLiteral) {\r\n                return this.translateTypeLiteral(type);\r\n            }\r\n            else if (type.symbol.flags & ts.SymbolFlags.Function ||\r\n                type.symbol.flags & ts.SymbolFlags.Method) {\r\n                var sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\r\n                if (sigs.length === 1) {\r\n                    return this.signatureToClosure(sigs[0]);\r\n                }\r\n            }\r\n            this.warn('unhandled anonymous type');\r\n            return '?';\r\n        }\r\n        /*\r\n        TODO(ts2.1): more unhandled object type flags:\r\n          Tuple\r\n          Mapped\r\n          Instantiated\r\n          ObjectLiteral\r\n          EvolvingArray\r\n          ObjectLiteralPatternWithComputedProperties\r\n        */\r\n        this.warn(\"unhandled type \" + typeToDebugString(type));\r\n        return '?';\r\n    };\r\n    /**\r\n     * translateTypeLiteral translates a ts.SymbolFlags.TypeLiteral type, which\r\n     * is the anonymous type encountered in e.g.\r\n     *   let x: {a: number};\r\n     */\r\n    TypeTranslator.prototype.translateTypeLiteral = function (type) {\r\n        // Avoid infinite loops on recursive types.\r\n        // It would be nice to just emit the name of the recursive type here,\r\n        // but type.symbol doesn't seem to have the name here (perhaps something\r\n        // to do with aliases?).\r\n        if (this.seenTypes.indexOf(type) !== -1)\r\n            return '?';\r\n        this.seenTypes.push(type);\r\n        // Gather up all the named fields and whether the object is also callable.\r\n        var callable = false;\r\n        var indexable = false;\r\n        var fields = [];\r\n        if (!type.symbol || !type.symbol.members) {\r\n            this.warn('type literal has no symbol');\r\n            return '?';\r\n        }\r\n        // special-case construct signatures.\r\n        var ctors = type.getConstructSignatures();\r\n        if (ctors.length) {\r\n            // TODO(martinprobst): this does not support additional properties defined on constructors\r\n            // (not expressible in Closure), nor multiple constructors (same).\r\n            var params = this.convertParams(ctors[0]);\r\n            var paramsStr = params.length ? (', ' + params.join(', ')) : '';\r\n            var constructedType = this.translate(ctors[0].getReturnType());\r\n            // In the specific case of the \"new\" in a function, it appears that\r\n            //   function(new: !Bar)\r\n            // fails to parse, while\r\n            //   function(new: (!Bar))\r\n            // parses in the way you'd expect.\r\n            // It appears from testing that Closure ignores the ! anyway and just\r\n            // assumes the result will be non-null in either case.  (To be pedantic,\r\n            // it's possible to return null from a ctor it seems like a bad idea.)\r\n            return \"function(new: (\" + constructedType + \")\" + paramsStr + \"): ?\";\r\n        }\r\n        for (var _i = 0, _a = util_1.toArray(type.symbol.members.keys()); _i < _a.length; _i++) {\r\n            var field = _a[_i];\r\n            switch (field) {\r\n                case '__call':\r\n                    callable = true;\r\n                    break;\r\n                case '__index':\r\n                    indexable = true;\r\n                    break;\r\n                default:\r\n                    var member = type.symbol.members.get(field);\r\n                    // optional members are handled by the type including |undefined in a union type.\r\n                    var memberType = this.translate(this.typeChecker.getTypeOfSymbolAtLocation(member, this.node));\r\n                    fields.push(field + \": \" + memberType);\r\n                    break;\r\n            }\r\n        }\r\n        // Try to special-case plain key-value objects and functions.\r\n        if (fields.length === 0) {\r\n            if (callable && !indexable) {\r\n                // A function type.\r\n                var sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\r\n                if (sigs.length === 1) {\r\n                    return this.signatureToClosure(sigs[0]);\r\n                }\r\n            }\r\n            else if (indexable && !callable) {\r\n                // A plain key-value map type.\r\n                var keyType = 'string';\r\n                var valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.String);\r\n                if (!valType) {\r\n                    keyType = 'number';\r\n                    valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.Number);\r\n                }\r\n                if (!valType) {\r\n                    this.warn('unknown index key type');\r\n                    return \"!Object<?,?>\";\r\n                }\r\n                return \"!Object<\" + keyType + \",\" + this.translate(valType) + \">\";\r\n            }\r\n            else if (!callable && !indexable) {\r\n                // Special-case the empty object {} because Closure doesn't like it.\r\n                // TODO(evanm): revisit this if it is a problem.\r\n                return '!Object';\r\n            }\r\n        }\r\n        if (!callable && !indexable) {\r\n            // Not callable, not indexable; implies a plain object with fields in it.\r\n            return \"{\" + fields.join(', ') + \"}\";\r\n        }\r\n        this.warn('unhandled type literal');\r\n        return '?';\r\n    };\r\n    /** Converts a ts.Signature (function signature) to a Closure function type. */\r\n    TypeTranslator.prototype.signatureToClosure = function (sig) {\r\n        var params = this.convertParams(sig);\r\n        var typeStr = \"function(\" + params.join(', ') + \")\";\r\n        var retType = this.translate(this.typeChecker.getReturnTypeOfSignature(sig));\r\n        if (retType) {\r\n            typeStr += \": \" + retType;\r\n        }\r\n        return typeStr;\r\n    };\r\n    TypeTranslator.prototype.convertParams = function (sig) {\r\n        var _this = this;\r\n        return sig.parameters.map(function (param) {\r\n            var paramType = _this.typeChecker.getTypeOfSymbolAtLocation(param, _this.node);\r\n            return _this.translate(paramType);\r\n        });\r\n    };\r\n    TypeTranslator.prototype.warn = function (msg) {\r\n        // By default, warn() does nothing.  The caller will overwrite this\r\n        // if it wants different behavior.\r\n    };\r\n    /** @return true if sym should always have type {?}. */\r\n    TypeTranslator.prototype.isBlackListed = function (symbol) {\r\n        if (this.pathBlackList === undefined)\r\n            return false;\r\n        var pathBlackList = this.pathBlackList;\r\n        // Some builtin types, such as {}, get represented by a symbol that has no declarations.\r\n        if (symbol.declarations === undefined)\r\n            return false;\r\n        return symbol.declarations.every(function (n) {\r\n            var fileName = path.normalize(n.getSourceFile().fileName);\r\n            return pathBlackList.has(fileName);\r\n        });\r\n    };\r\n    return TypeTranslator;\r\n}());\r\nexports.TypeTranslator = TypeTranslator;\r\n//# sourceMappingURL=type-translator.js.map","sourceMap":{"version":3,"file":"type-translator.js","sourceRoot":"","sources":["node_modules/tsickle/src/type-translator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport {toArray} from './util';\n\n/**\n * Determines if fileName refers to a builtin lib.d.ts file.\n * This is a terrible hack but it mirrors a similar thing done in Clutz.\n */\nexport function isBuiltinLibDTS(fileName: string): boolean {\n  return fileName.match(/\\blib\\.(?:[^/]+\\.)?d\\.ts$/) != null;\n}\n\n/**\n * @return True if the named type is considered compatible with the Closure-defined\n *     type of the same name, e.g. \"Array\".  Note that we don't actually enforce\n *     that the types are actually compatible, but mostly just hope that they are due\n *     to being derived from the same HTML specs.\n */\nfunction isClosureProvidedType(symbol: ts.Symbol): boolean {\n  return symbol.declarations != null &&\n      symbol.declarations.some(n => isBuiltinLibDTS(n.getSourceFile().fileName));\n}\n\nexport function typeToDebugString(type: ts.Type): string {\n  let debugString = `flags:0x${type.flags.toString(16)}`;\n\n  // Just the unique flags (powers of two). Declared in src/compiler/types.ts.\n  const basicTypes: ts.TypeFlags[] = [\n    ts.TypeFlags.Any,           ts.TypeFlags.String,         ts.TypeFlags.Number,\n    ts.TypeFlags.Boolean,       ts.TypeFlags.Enum,           ts.TypeFlags.StringLiteral,\n    ts.TypeFlags.NumberLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.EnumLiteral,\n    ts.TypeFlags.ESSymbol,      ts.TypeFlags.Void,           ts.TypeFlags.Undefined,\n    ts.TypeFlags.Null,          ts.TypeFlags.Never,          ts.TypeFlags.TypeParameter,\n    ts.TypeFlags.Object,        ts.TypeFlags.Union,          ts.TypeFlags.Intersection,\n    ts.TypeFlags.Index,         ts.TypeFlags.IndexedAccess,  ts.TypeFlags.NonPrimitive,\n  ];\n  for (const flag of basicTypes) {\n    if ((type.flags & flag) !== 0) {\n      debugString += ` ${ts.TypeFlags[flag]}`;\n    }\n  }\n\n  if (type.flags === ts.TypeFlags.Object) {\n    const objType = type as ts.ObjectType;\n    // Just the unique flags (powers of two). Declared in src/compiler/types.ts.\n    const objectFlags: ts.ObjectFlags[] = [\n      ts.ObjectFlags.Class,\n      ts.ObjectFlags.Interface,\n      ts.ObjectFlags.Reference,\n      ts.ObjectFlags.Tuple,\n      ts.ObjectFlags.Anonymous,\n      ts.ObjectFlags.Mapped,\n      ts.ObjectFlags.Instantiated,\n      ts.ObjectFlags.ObjectLiteral,\n      ts.ObjectFlags.EvolvingArray,\n      ts.ObjectFlags.ObjectLiteralPatternWithComputedProperties,\n    ];\n    for (const flag of objectFlags) {\n      if ((objType.objectFlags & flag) !== 0) {\n        debugString += ` object:${ts.ObjectFlags[flag]}`;\n      }\n    }\n  }\n\n  if (type.symbol && type.symbol.name !== '__type') {\n    debugString += ` symbol.name:${JSON.stringify(type.symbol.name)}`;\n  }\n\n  if (type.pattern) {\n    debugString += ` destructuring:true`;\n  }\n\n  return `{type ${debugString}}`;\n}\n\nexport function symbolToDebugString(sym: ts.Symbol): string {\n  let debugString = `${JSON.stringify(sym.name)} flags:0x${sym.flags.toString(16)}`;\n\n  // Just the unique flags (powers of two). Declared in src/compiler/types.ts.\n  const symbolFlags = [\n    ts.SymbolFlags.FunctionScopedVariable,\n    ts.SymbolFlags.BlockScopedVariable,\n    ts.SymbolFlags.Property,\n    ts.SymbolFlags.EnumMember,\n    ts.SymbolFlags.Function,\n    ts.SymbolFlags.Class,\n    ts.SymbolFlags.Interface,\n    ts.SymbolFlags.ConstEnum,\n    ts.SymbolFlags.RegularEnum,\n    ts.SymbolFlags.ValueModule,\n    ts.SymbolFlags.NamespaceModule,\n    ts.SymbolFlags.TypeLiteral,\n    ts.SymbolFlags.ObjectLiteral,\n    ts.SymbolFlags.Method,\n    ts.SymbolFlags.Constructor,\n    ts.SymbolFlags.GetAccessor,\n    ts.SymbolFlags.SetAccessor,\n    ts.SymbolFlags.Signature,\n    ts.SymbolFlags.TypeParameter,\n    ts.SymbolFlags.TypeAlias,\n    ts.SymbolFlags.ExportValue,\n    ts.SymbolFlags.ExportType,\n    ts.SymbolFlags.ExportNamespace,\n    ts.SymbolFlags.Alias,\n    ts.SymbolFlags.Prototype,\n    ts.SymbolFlags.ExportStar,\n    ts.SymbolFlags.Optional,\n    ts.SymbolFlags.Transient,\n  ];\n  for (const flag of symbolFlags) {\n    if ((sym.flags & flag) !== 0) {\n      debugString += ` ${ts.SymbolFlags[flag]}`;\n    }\n  }\n\n  return debugString;\n}\n\n/** TypeTranslator translates TypeScript types to Closure types. */\nexport class TypeTranslator {\n  /**\n   * A list of types we've encountered while emitting; used to avoid getting stuck in recursive\n   * types.\n   */\n  private readonly seenTypes: ts.Type[] = [];\n\n  /**\n   * Whether to write types suitable for an \\@externs file. Externs types must not refer to\n   * non-externs types (i.e. non ambient types) and need to use fully qualified names.\n   */\n  isForExterns = false;\n\n  /**\n   * @param node is the source AST ts.Node the type comes from.  This is used\n   *     in some cases (e.g. anonymous types) for looking up field names.\n   * @param pathBlackList is a set of paths that should never get typed;\n   *     any reference to symbols defined in these paths should by typed\n   *     as {?}.\n   * @param symbolsToPrefix a mapping from symbols (`Foo`) to a prefix they should be emitted with\n   *     (`tsickle_import.Foo`).\n   */\n  constructor(\n      private readonly typeChecker: ts.TypeChecker, private readonly node: ts.Node,\n      private readonly pathBlackList?: Set<string>,\n      private readonly symbolsToAliasedNames = new Map<ts.Symbol, string>()) {\n    // Normalize paths to not break checks on Windows.\n    if (this.pathBlackList != null) {\n      this.pathBlackList =\n          new Set<string>(Array.from(this.pathBlackList.values()).map(p => path.normalize(p)));\n    }\n  }\n\n  /**\n   * Converts a ts.Symbol to a string.\n   * Other approaches that don't work:\n   * - TypeChecker.typeToString translates Array as T[].\n   * - TypeChecker.symbolToString emits types without their namespace,\n   *   and doesn't let you pass the flag to control that.\n   * @param useFqn whether to scope the name using its fully qualified name. Closure's template\n   *     arguments are always scoped to the class containing them, where TypeScript's template args\n   *     would be fully qualified. I.e. this flag is false for generic types.\n   */\n  public symbolToString(sym: ts.Symbol, useFqn: boolean): string {\n    // This follows getSingleLineStringWriter in the TypeScript compiler.\n    let str = '';\n    let symAlias = sym;\n    if (symAlias.flags & ts.SymbolFlags.Alias) {\n      symAlias = this.typeChecker.getAliasedSymbol(symAlias);\n    }\n    const alias = this.symbolsToAliasedNames.get(symAlias);\n    if (alias) return alias;\n    if (useFqn && this.isForExterns) {\n      // For regular type emit, we can use TypeScript's naming rules, as they match Closure's name\n      // scoping rules. However when emitting externs files for ambients, naming rules change. As\n      // Closure doesn't support externs modules, all names must be global and use global fully\n      // qualified names. The code below uses TypeScript to convert a symbol to a full qualified\n      // name and then emits that.\n      let fqn = this.typeChecker.getFullyQualifiedName(sym);\n      if (fqn.startsWith(`\"`) || fqn.startsWith(`'`)) {\n        // Quoted FQNs mean the name is from a module, e.g. `'path/to/module'.some.qualified.Name`.\n        // tsickle generally re-scopes names in modules that are moved to externs into the global\n        // namespace. That does not quite match TS' semantics where ambient types from modules are\n        // local. However value declarations that are local to modules but not defined do not make\n        // sense if not global, e.g. \"declare class X {}; new X();\" cannot work unless `X` is\n        // actually a global.\n        // So this code strips the module path from the type and uses the FQN as a global.\n        fqn = fqn.replace(/^[\"'][^\"']+['\"]\\./, '');\n      }\n      // Declarations in module can re-open global types using \"declare global { ... }\". The fqn\n      // then contains the prefix \"global.\" here. As we're mapping to global types, just strip the\n      // prefix.\n      const isInGlobal = (sym.declarations || []).some(d => {\n        let current: ts.Node|undefined = d;\n        while (current) {\n          if (current.flags & ts.NodeFlags.GlobalAugmentation) return true;\n          current = current.parent;\n        }\n        return false;\n      });\n      if (isInGlobal) {\n        fqn = fqn.replace(/^global\\./, '');\n      }\n      return this.stripClutzNamespace(fqn);\n    }\n    const writeText = (text: string) => str += text;\n    const doNothing = () => {\n      return;\n    };\n\n    const builder = this.typeChecker.getSymbolDisplayBuilder();\n    const writer: ts.SymbolWriter = {\n      writeKeyword: writeText,\n      writeOperator: writeText,\n      writePunctuation: writeText,\n      writeSpace: writeText,\n      writeStringLiteral: writeText,\n      writeParameter: writeText,\n      writeProperty: writeText,\n      writeSymbol: writeText,\n      writeLine: doNothing,\n      increaseIndent: doNothing,\n      decreaseIndent: doNothing,\n      clear: doNothing,\n      trackSymbol(symbol: ts.Symbol, enclosingDeclaration?: ts.Node, meaning?: ts.SymbolFlags) {\n        return;\n      },\n      reportInaccessibleThisError: doNothing,\n      reportPrivateInBaseOfClassExpression: doNothing,\n    };\n    builder.buildSymbolDisplay(sym, writer, this.node);\n    return this.stripClutzNamespace(str);\n  }\n\n  // Clutz (https://github.com/angular/clutz) emits global type symbols hidden in a special\n  // ಠ_ಠ.clutz namespace. While most code seen by Tsickle will only ever see local aliases, Clutz\n  // symbols can be written by users directly in code, and they can appear by dereferencing\n  // TypeAliases. The code below simply strips the prefix, the remaining type name then matches\n  // Closure's type.\n  private stripClutzNamespace(name: string) {\n    if (name.startsWith('ಠ_ಠ.clutz.')) return name.substring('ಠ_ಠ.clutz.'.length);\n    return name;\n  }\n\n  translate(type: ts.Type): string {\n    // NOTE: Though type.flags has the name \"flags\", it usually can only be one\n    // of the enum options at a time (except for unions of literal types, e.g. unions of boolean\n    // values, string values, enum values). This switch handles all the cases in the ts.TypeFlags\n    // enum in the order they occur.\n\n    // NOTE: Some TypeFlags are marked \"internal\" in the d.ts but still show up in the value of\n    // type.flags. This mask limits the flag checks to the ones in the public API. \"lastFlag\" here\n    // is the last flag handled in this switch statement, and should be kept in sync with\n    // typescript.d.ts.\n\n    // NonPrimitive occurs on its own on the lower case \"object\" type. Special case to \"!Object\".\n    if (type.flags === ts.TypeFlags.NonPrimitive) return '!Object';\n\n    let isAmbient = false;\n    let isNamespace = false;\n    let isModule = false;\n    if (type.symbol) {\n      for (const decl of type.symbol.declarations || []) {\n        if (ts.isExternalModule(decl.getSourceFile())) isModule = true;\n        let current: ts.Node|undefined = decl;\n        while (current) {\n          if (ts.getCombinedModifierFlags(current) & ts.ModifierFlags.Ambient) isAmbient = true;\n          if (current.kind === ts.SyntaxKind.ModuleDeclaration) isNamespace = true;\n          current = current.parent;\n        }\n      }\n    }\n\n    // tsickle cannot generate types for non-ambient namespaces.\n    if (isNamespace && !isAmbient) return '?';\n\n    // Types in externs cannot reference types from external modules.\n    // However ambient types in modules get moved to externs, too, so type references work and we\n    // can emit a precise type.\n    if (this.isForExterns && isModule && !isAmbient) return '?';\n\n    const lastFlag = ts.TypeFlags.IndexedAccess;\n    const mask = (lastFlag << 1) - 1;\n    switch (type.flags & mask) {\n      case ts.TypeFlags.Any:\n        return '?';\n      case ts.TypeFlags.String:\n      case ts.TypeFlags.StringLiteral:\n        return 'string';\n      case ts.TypeFlags.Number:\n      case ts.TypeFlags.NumberLiteral:\n        return 'number';\n      case ts.TypeFlags.Boolean:\n      case ts.TypeFlags.BooleanLiteral:\n        // See the note in translateUnion about booleans.\n        return 'boolean';\n      case ts.TypeFlags.Enum:\n        if (!type.symbol) {\n          this.warn(`EnumType without a symbol`);\n          return '?';\n        }\n        return this.symbolToString(type.symbol, true);\n      case ts.TypeFlags.ESSymbol:\n        // NOTE: currently this is just a typedef for {?}, shrug.\n        // https://github.com/google/closure-compiler/blob/55cf43ee31e80d89d7087af65b5542aa63987874/externs/es3.js#L34\n        return 'symbol';\n      case ts.TypeFlags.Void:\n        return 'void';\n      case ts.TypeFlags.Undefined:\n        return 'undefined';\n      case ts.TypeFlags.Null:\n        return 'null';\n      case ts.TypeFlags.Never:\n        this.warn(`should not emit a 'never' type`);\n        return '?';\n      case ts.TypeFlags.TypeParameter:\n        // This is e.g. the T in a type like Foo<T>.\n        if (!type.symbol) {\n          this.warn(`TypeParameter without a symbol`);  // should not happen (tm)\n          return '?';\n        }\n        // In Closure Compiler, type parameters *are* scoped to their containing class.\n        const useFqn = false;\n        return this.symbolToString(type.symbol, useFqn);\n      case ts.TypeFlags.Object:\n        return this.translateObject(type as ts.ObjectType);\n      case ts.TypeFlags.Union:\n        return this.translateUnion(type as ts.UnionType);\n      case ts.TypeFlags.Intersection:\n      case ts.TypeFlags.Index:\n      case ts.TypeFlags.IndexedAccess:\n        // TODO(ts2.1): handle these special types.\n        this.warn(`unhandled type flags: ${ts.TypeFlags[type.flags]}`);\n        return '?';\n      default:\n        // Handle cases where multiple flags are set.\n\n        // Types with literal members are represented as\n        //   ts.TypeFlags.Union | [literal member]\n        // E.g. an enum typed value is a union type with the enum's members as its members. A\n        // boolean type is a union type with 'true' and 'false' as its members.\n        // Note also that in a more complex union, e.g. boolean|number, then it's a union of three\n        // things (true|false|number) and ts.TypeFlags.Boolean doesn't show up at all.\n        if (type.flags & ts.TypeFlags.Union) {\n          return this.translateUnion(type as ts.UnionType);\n        }\n\n        if (type.flags & ts.TypeFlags.EnumLiteral) {\n          return this.translateEnumLiteral(type);\n        }\n\n        // The switch statement should have been exhaustive.\n        throw new Error(`unknown type flags ${type.flags} on ${typeToDebugString(type)}`);\n    }\n  }\n\n  private translateUnion(type: ts.UnionType): string {\n    let parts = type.types.map(t => this.translate(t));\n    // Union types that include literals (e.g. boolean, enum) can end up repeating the same Closure\n    // type. For example: true | boolean will be translated to boolean | boolean.\n    // Remove duplicates to produce types that read better.\n    parts = parts.filter((el, idx) => parts.indexOf(el) === idx);\n    return parts.length === 1 ? parts[0] : `(${parts.join('|')})`;\n  }\n\n  private translateEnumLiteral(type: ts.Type): string {\n    // Suppose you had:\n    //   enum EnumType { MEMBER }\n    // then the type of \"EnumType.MEMBER\" is an enum literal (the thing passed to this function)\n    // and it has type flags that include\n    //   ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral\n    //\n    // Closure Compiler doesn't support literals in types, so this code must not emit\n    // \"EnumType.MEMBER\", but rather \"EnumType\".\n\n    const enumLiteralBaseType = this.typeChecker.getBaseTypeOfLiteralType(type);\n    if (!enumLiteralBaseType.symbol) {\n      this.warn(`EnumLiteralType without a symbol`);\n      return '?';\n    }\n    return this.symbolToString(enumLiteralBaseType.symbol, true);\n  }\n\n  // translateObject translates a ts.ObjectType, which is the type of all\n  // object-like things in TS, such as classes and interfaces.\n  private translateObject(type: ts.ObjectType): string {\n    if (type.symbol && this.isBlackListed(type.symbol)) return '?';\n\n    // NOTE: objectFlags is an enum, but a given type can have multiple flags.\n    // Array<string> is both ts.ObjectFlags.Reference and ts.ObjectFlags.Interface.\n\n    if (type.objectFlags & ts.ObjectFlags.Class) {\n      if (!type.symbol) {\n        this.warn('class has no symbol');\n        return '?';\n      }\n      return '!' + this.symbolToString(type.symbol, /* useFqn */ true);\n    } else if (type.objectFlags & ts.ObjectFlags.Interface) {\n      // Note: ts.InterfaceType has a typeParameters field, but that\n      // specifies the parameters that the interface type *expects*\n      // when it's used, and should not be transformed to the output.\n      // E.g. a type like Array<number> is a TypeReference to the\n      // InterfaceType \"Array\", but the \"number\" type parameter is\n      // part of the outer TypeReference, not a typeParameter on\n      // the InterfaceType.\n      if (!type.symbol) {\n        this.warn('interface has no symbol');\n        return '?';\n      }\n      if (type.symbol.flags & ts.SymbolFlags.Value) {\n        // The symbol is both a type and a value.\n        // For user-defined types in this state, we don't have a Closure name\n        // for the type.  See the type_and_value test.\n        if (!isClosureProvidedType(type.symbol)) {\n          this.warn(`type/symbol conflict for ${type.symbol.name}, using {?} for now`);\n          return '?';\n        }\n      }\n      return '!' + this.symbolToString(type.symbol, /* useFqn */ true);\n    } else if (type.objectFlags & ts.ObjectFlags.Reference) {\n      // A reference to another type, e.g. Array<number> refers to Array.\n      // Emit the referenced type and any type arguments.\n      const referenceType = type as ts.TypeReference;\n\n      // A tuple is a ReferenceType where the target is flagged Tuple and the\n      // typeArguments are the tuple arguments.  Just treat it as a mystery\n      // array, because Closure doesn't understand tuples.\n      if (referenceType.target.objectFlags & ts.ObjectFlags.Tuple) {\n        return '!Array<?>';\n      }\n\n      let typeStr = '';\n      if (referenceType.target === referenceType) {\n        // We get into an infinite loop here if the inner reference is\n        // the same as the outer; this can occur when this function\n        // fails to translate a more specific type before getting to\n        // this point.\n        throw new Error(\n            `reference loop in ${typeToDebugString(referenceType)} ${referenceType.flags}`);\n      }\n      typeStr += this.translate(referenceType.target);\n      // Translate can return '?' for a number of situations, e.g. type/value conflicts.\n      // `?<?>` is illegal syntax in Closure Compiler, so just return `?` here.\n      if (typeStr === '?') return '?';\n      if (referenceType.typeArguments) {\n        const params = referenceType.typeArguments.map(t => this.translate(t));\n        typeStr += `<${params.join(', ')}>`;\n      }\n      return typeStr;\n    } else if (type.objectFlags & ts.ObjectFlags.Anonymous) {\n      if (!type.symbol) {\n        // This comes up when generating code for an arrow function as passed\n        // to a generic function.  The passed-in type is tagged as anonymous\n        // and has no properties so it's hard to figure out what to generate.\n        // Just avoid it for now so we don't crash.\n        this.warn('anonymous type has no symbol');\n        return '?';\n      }\n\n      if (type.symbol.flags & ts.SymbolFlags.TypeLiteral) {\n        return this.translateTypeLiteral(type);\n      } else if (\n          type.symbol.flags & ts.SymbolFlags.Function ||\n          type.symbol.flags & ts.SymbolFlags.Method) {\n        const sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\n        if (sigs.length === 1) {\n          return this.signatureToClosure(sigs[0]);\n        }\n      }\n      this.warn('unhandled anonymous type');\n      return '?';\n    }\n\n    /*\n    TODO(ts2.1): more unhandled object type flags:\n      Tuple\n      Mapped\n      Instantiated\n      ObjectLiteral\n      EvolvingArray\n      ObjectLiteralPatternWithComputedProperties\n    */\n    this.warn(`unhandled type ${typeToDebugString(type)}`);\n    return '?';\n  }\n\n  /**\n   * translateTypeLiteral translates a ts.SymbolFlags.TypeLiteral type, which\n   * is the anonymous type encountered in e.g.\n   *   let x: {a: number};\n   */\n  private translateTypeLiteral(type: ts.Type): string {\n    // Avoid infinite loops on recursive types.\n    // It would be nice to just emit the name of the recursive type here,\n    // but type.symbol doesn't seem to have the name here (perhaps something\n    // to do with aliases?).\n    if (this.seenTypes.indexOf(type) !== -1) return '?';\n    this.seenTypes.push(type);\n\n    // Gather up all the named fields and whether the object is also callable.\n    let callable = false;\n    let indexable = false;\n    const fields: string[] = [];\n    if (!type.symbol || !type.symbol.members) {\n      this.warn('type literal has no symbol');\n      return '?';\n    }\n\n    // special-case construct signatures.\n    const ctors = type.getConstructSignatures();\n    if (ctors.length) {\n      // TODO(martinprobst): this does not support additional properties defined on constructors\n      // (not expressible in Closure), nor multiple constructors (same).\n      const params = this.convertParams(ctors[0]);\n      const paramsStr = params.length ? (', ' + params.join(', ')) : '';\n      const constructedType = this.translate(ctors[0].getReturnType());\n      // In the specific case of the \"new\" in a function, it appears that\n      //   function(new: !Bar)\n      // fails to parse, while\n      //   function(new: (!Bar))\n      // parses in the way you'd expect.\n      // It appears from testing that Closure ignores the ! anyway and just\n      // assumes the result will be non-null in either case.  (To be pedantic,\n      // it's possible to return null from a ctor it seems like a bad idea.)\n      return `function(new: (${constructedType})${paramsStr}): ?`;\n    }\n\n    for (const field of toArray(type.symbol.members.keys())) {\n      switch (field) {\n        case '__call':\n          callable = true;\n          break;\n        case '__index':\n          indexable = true;\n          break;\n        default:\n          const member = type.symbol.members.get(field)!;\n          // optional members are handled by the type including |undefined in a union type.\n          const memberType =\n              this.translate(this.typeChecker.getTypeOfSymbolAtLocation(member, this.node));\n          fields.push(`${field}: ${memberType}`);\n          break;\n      }\n    }\n\n    // Try to special-case plain key-value objects and functions.\n    if (fields.length === 0) {\n      if (callable && !indexable) {\n        // A function type.\n        const sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\n        if (sigs.length === 1) {\n          return this.signatureToClosure(sigs[0]);\n        }\n      } else if (indexable && !callable) {\n        // A plain key-value map type.\n        let keyType = 'string';\n        let valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.String);\n        if (!valType) {\n          keyType = 'number';\n          valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.Number);\n        }\n        if (!valType) {\n          this.warn('unknown index key type');\n          return `!Object<?,?>`;\n        }\n        return `!Object<${keyType},${this.translate(valType)}>`;\n      } else if (!callable && !indexable) {\n        // Special-case the empty object {} because Closure doesn't like it.\n        // TODO(evanm): revisit this if it is a problem.\n        return '!Object';\n      }\n    }\n\n    if (!callable && !indexable) {\n      // Not callable, not indexable; implies a plain object with fields in it.\n      return `{${fields.join(', ')}}`;\n    }\n\n    this.warn('unhandled type literal');\n    return '?';\n  }\n\n  /** Converts a ts.Signature (function signature) to a Closure function type. */\n  private signatureToClosure(sig: ts.Signature): string {\n    const params = this.convertParams(sig);\n    let typeStr = `function(${params.join(', ')})`;\n\n    const retType = this.translate(this.typeChecker.getReturnTypeOfSignature(sig));\n    if (retType) {\n      typeStr += `: ${retType}`;\n    }\n\n    return typeStr;\n  }\n\n  private convertParams(sig: ts.Signature): string[] {\n    return sig.parameters.map(param => {\n      const paramType = this.typeChecker.getTypeOfSymbolAtLocation(param, this.node);\n      return this.translate(paramType);\n    });\n  }\n\n  warn(msg: string) {\n    // By default, warn() does nothing.  The caller will overwrite this\n    // if it wants different behavior.\n  }\n\n  /** @return true if sym should always have type {?}. */\n  isBlackListed(symbol: ts.Symbol): boolean {\n    if (this.pathBlackList === undefined) return false;\n    const pathBlackList = this.pathBlackList;\n    // Some builtin types, such as {}, get represented by a symbol that has no declarations.\n    if (symbol.declarations === undefined) return false;\n    return symbol.declarations.every(n => {\n      const fileName = path.normalize(n.getSourceFile().fileName);\n      return pathBlackList.has(fileName);\n    });\n  }\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/util.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"path","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./util","resolvedPath":"node_modules/tsickle/src/util","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/type-translator.ts","message":"Cannot find module 'path'.","line":9,"column":23},{"code":2307,"fileName":"node_modules/tsickle/src/type-translator.ts","message":"Cannot find module 'typescript'.","line":10,"column":21}]},"hash":"eb285a1cde3d0f9d40b3566cf6bcaa77fb90a5d3"}