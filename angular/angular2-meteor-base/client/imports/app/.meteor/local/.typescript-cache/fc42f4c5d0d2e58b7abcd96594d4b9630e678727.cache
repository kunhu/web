{"code":"/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar ts = require(\"typescript\");\r\nvar rewriter_1 = require(\"./rewriter\");\r\nvar tsickle_1 = require(\"./tsickle\");\r\nvar util_1 = require(\"./util\");\r\n/**\r\n * Extracts the namespace part of a goog: import, or returns null if the given\r\n * import is not a goog: import.\r\n */\r\nfunction extractGoogNamespaceImport(tsImport) {\r\n    if (tsImport.match(/^goog:/))\r\n        return tsImport.substring('goog:'.length);\r\n    return null;\r\n}\r\nexports.extractGoogNamespaceImport = extractGoogNamespaceImport;\r\n/**\r\n * ES5Processor postprocesses TypeScript compilation output JS, to rewrite commonjs require()s into\r\n * goog.require(). Contrary to its name it handles converting the modules in both ES5 and ES6\r\n * outputs.\r\n */\r\nvar ES5Processor = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ES5Processor, _super);\r\n    function ES5Processor(host, file) {\r\n        var _this = _super.call(this, file) || this;\r\n        _this.host = host;\r\n        /**\r\n         * namespaceImports collects the variables for imported goog.modules.\r\n         * If the original TS input is:\r\n         *   import foo from 'goog:bar';\r\n         * then TS produces:\r\n         *   var foo = require('goog:bar');\r\n         * and this class rewrites it to:\r\n         *   var foo = require('goog.bar');\r\n         * After this step, namespaceImports['foo'] is true.\r\n         * (This is used to rewrite 'foo.default' into just 'foo'.)\r\n         */\r\n        _this.namespaceImports = new Set();\r\n        /**\r\n         * moduleVariables maps from module names to the variables they're assigned to.\r\n         * Continuing the above example, moduleVariables['goog.bar'] = 'foo'.\r\n         */\r\n        _this.moduleVariables = new Map();\r\n        /** strippedStrict is true once we've stripped a \"use strict\"; from the input. */\r\n        _this.strippedStrict = false;\r\n        /** unusedIndex is used to generate fresh symbols for unnamed imports. */\r\n        _this.unusedIndex = 0;\r\n        return _this;\r\n    }\r\n    ES5Processor.prototype.process = function () {\r\n        var moduleId = this.host.fileNameToModuleId(this.file.fileName);\r\n        // TODO(evanm): only emit the goog.module *after* the first comment,\r\n        // so that @suppress statements work.\r\n        var moduleName = this.host.pathToModuleName('', this.file.fileName);\r\n        // NB: No linebreak after module call so sourcemaps are not offset.\r\n        this.emit(\"goog.module('\" + moduleName + \"');\");\r\n        if (this.host.prelude)\r\n            this.emit(this.host.prelude);\r\n        // Allow code to use `module.id` to discover its module URL, e.g. to resolve\r\n        // a template URL against.\r\n        // Uses 'var', as this code is inserted in ES6 and ES5 modes.\r\n        // The following pattern ensures closure doesn't throw an error in advanced\r\n        // optimizations mode.\r\n        if (this.host.es5Mode) {\r\n            this.emit(\"var module = module || {id: '\" + moduleId + \"'};\");\r\n        }\r\n        else {\r\n            // The `exports = {}` serves as a default export to disable Closure Compiler's error checking\r\n            // for mutable exports. That's OK because TS compiler makes sure that consuming code always\r\n            // accesses exports through the module object, so mutable exports work.\r\n            // It is only inserted in ES6 because we strip `.default` accesses in ES5 mode, which breaks\r\n            // when assigning an `exports = {}` object and then later accessing it.\r\n            this.emit(\" exports = {}; var module = {id: '\" + moduleId + \"'};\");\r\n        }\r\n        var pos = 0;\r\n        for (var _i = 0, _a = this.file.statements; _i < _a.length; _i++) {\r\n            var stmt = _a[_i];\r\n            this.writeRange(this.file, pos, stmt.getFullStart());\r\n            this.visitTopLevel(stmt);\r\n            pos = stmt.getEnd();\r\n        }\r\n        this.writeRange(this.file, pos, this.file.getEnd());\r\n        var referencedModules = util_1.toArray(this.moduleVariables.keys());\r\n        // Note: don't sort referencedModules, as the keys are in the same order\r\n        // they occur in the source file.\r\n        var output = this.getOutput().output;\r\n        return { output: output, referencedModules: referencedModules };\r\n    };\r\n    /**\r\n     * visitTopLevel processes a top-level ts.Node and emits its contents.\r\n     *\r\n     * It's separate from the normal Rewriter recursive traversal\r\n     * because some top-level statements are handled specially.\r\n     */\r\n    ES5Processor.prototype.visitTopLevel = function (node) {\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.ExpressionStatement:\r\n                // Check for \"use strict\" and skip it if necessary.\r\n                if (!this.strippedStrict && this.isUseStrict(node)) {\r\n                    this.emitCommentWithoutStatementBody(node);\r\n                    this.strippedStrict = true;\r\n                    return;\r\n                }\r\n                // Check for:\r\n                // - \"require('foo');\" (a require for its side effects)\r\n                // - \"__export(require(...));\" (an \"export * from ...\")\r\n                if (this.emitRewrittenRequires(node)) {\r\n                    return;\r\n                }\r\n                // Check for\r\n                //   Object.defineProperty(exports, \"__esModule\", ...);\r\n                if (this.isEsModuleProperty(node)) {\r\n                    this.emitCommentWithoutStatementBody(node);\r\n                    return;\r\n                }\r\n                // Otherwise fall through to default processing.\r\n                break;\r\n            case ts.SyntaxKind.VariableStatement:\r\n                // Check for a \"var x = require('foo');\".\r\n                if (this.emitRewrittenRequires(node))\r\n                    return;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        this.visit(node);\r\n    };\r\n    /**\r\n     * The TypeScript AST attaches comments to statement nodes, so even if a node\r\n     * contains code we want to skip emitting, we need to emit the attached\r\n     * comment(s).\r\n     */\r\n    ES5Processor.prototype.emitCommentWithoutStatementBody = function (node) {\r\n        this.writeLeadingTrivia(node);\r\n    };\r\n    /** isUseStrict returns true if node is a \"use strict\"; statement. */\r\n    ES5Processor.prototype.isUseStrict = function (node) {\r\n        if (node.kind !== ts.SyntaxKind.ExpressionStatement)\r\n            return false;\r\n        var exprStmt = node;\r\n        var expr = exprStmt.expression;\r\n        if (expr.kind !== ts.SyntaxKind.StringLiteral)\r\n            return false;\r\n        var literal = expr;\r\n        return literal.text === 'use strict';\r\n    };\r\n    /**\r\n     * emitRewrittenRequires rewrites require()s into goog.require() equivalents.\r\n     *\r\n     * @return True if the node was rewritten, false if needs ordinary processing.\r\n     */\r\n    ES5Processor.prototype.emitRewrittenRequires = function (node) {\r\n        // We're looking for requires, of one of the forms:\r\n        // - \"var importName = require(...);\".\r\n        // - \"require(...);\".\r\n        if (node.kind === ts.SyntaxKind.VariableStatement) {\r\n            // It's possibly of the form \"var x = require(...);\".\r\n            var varStmt = node;\r\n            // Verify it's a single decl (and not \"var x = ..., y = ...;\").\r\n            if (varStmt.declarationList.declarations.length !== 1)\r\n                return false;\r\n            var decl = varStmt.declarationList.declarations[0];\r\n            // Grab the variable name (avoiding things like destructuring binds).\r\n            if (decl.name.kind !== ts.SyntaxKind.Identifier)\r\n                return false;\r\n            var varName = rewriter_1.getIdentifierText(decl.name);\r\n            if (!decl.initializer || decl.initializer.kind !== ts.SyntaxKind.CallExpression)\r\n                return false;\r\n            var call = decl.initializer;\r\n            var require = this.isRequire(call);\r\n            if (!require)\r\n                return false;\r\n            this.writeLeadingTrivia(node);\r\n            this.emitGoogRequire(varName, require);\r\n            return true;\r\n        }\r\n        else if (node.kind === ts.SyntaxKind.ExpressionStatement) {\r\n            // It's possibly of the form:\r\n            // - require(...);\r\n            // - __export(require(...));\r\n            // Both are CallExpressions.\r\n            var exprStmt = node;\r\n            var expr = exprStmt.expression;\r\n            if (expr.kind !== ts.SyntaxKind.CallExpression)\r\n                return false;\r\n            var call = expr;\r\n            var require = this.isRequire(call);\r\n            var isExport = false;\r\n            if (!require) {\r\n                // If it's an __export(require(...)), we emit:\r\n                //   var x = require(...);\r\n                //   __export(x);\r\n                // This extra variable is necessary in case there's a later import of the\r\n                // same module name.\r\n                require = this.isExportRequire(call);\r\n                isExport = require != null;\r\n            }\r\n            if (!require)\r\n                return false;\r\n            this.writeLeadingTrivia(node);\r\n            var varName = this.emitGoogRequire(null, require);\r\n            if (isExport) {\r\n                this.emit(\"__export(\" + varName + \");\");\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            // It's some other type of statement.\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Emits a goog.require() statement for a given variable name and TypeScript import.\r\n     *\r\n     * E.g. from:\r\n     *   var varName = require('tsImport');\r\n     * produces:\r\n     *   var varName = goog.require('goog.module.name');\r\n     *\r\n     * If the input varName is null, generates a new variable name if necessary.\r\n     *\r\n     * @return The variable name for the imported module, reusing a previous import if one\r\n     *    is available.\r\n     */\r\n    ES5Processor.prototype.emitGoogRequire = function (varName, tsImport) {\r\n        var modName;\r\n        var isNamespaceImport = false;\r\n        var nsImport = extractGoogNamespaceImport(tsImport);\r\n        if (nsImport !== null) {\r\n            // This is a namespace import, of the form \"goog:foo.bar\".\r\n            // Fix it to just \"foo.bar\".\r\n            modName = nsImport;\r\n            isNamespaceImport = true;\r\n        }\r\n        else {\r\n            modName = this.host.pathToModuleName(this.file.fileName, tsImport);\r\n        }\r\n        if (!varName) {\r\n            var mv = this.moduleVariables.get(modName);\r\n            if (mv) {\r\n                // Caller didn't request a specific variable name and we've already\r\n                // imported the module, so just return the name we already have for this module.\r\n                return mv;\r\n            }\r\n            // Note: we always introduce a variable for any import, regardless of whether\r\n            // the caller requested one.  This avoids a Closure error.\r\n            varName = this.generateFreshVariableName();\r\n        }\r\n        if (isNamespaceImport)\r\n            this.namespaceImports.add(varName);\r\n        if (this.moduleVariables.has(modName)) {\r\n            this.emit(\"var \" + varName + \" = \" + this.moduleVariables.get(modName) + \";\");\r\n        }\r\n        else {\r\n            this.emit(\"var \" + varName + \" = goog.require('\" + modName + \"');\");\r\n            this.moduleVariables.set(modName, varName);\r\n        }\r\n        return varName;\r\n    };\r\n    // workaround for syntax highlighting bug in Sublime: `\r\n    /**\r\n     * Returns the string argument if call is of the form\r\n     *   require('foo')\r\n     */\r\n    ES5Processor.prototype.isRequire = function (call) {\r\n        // Verify that the call is a call to require(...).\r\n        if (call.expression.kind !== ts.SyntaxKind.Identifier)\r\n            return null;\r\n        var ident = call.expression;\r\n        if (rewriter_1.getIdentifierText(ident) !== 'require')\r\n            return null;\r\n        // Verify the call takes a single string argument and grab it.\r\n        if (call.arguments.length !== 1)\r\n            return null;\r\n        var arg = call.arguments[0];\r\n        if (arg.kind !== ts.SyntaxKind.StringLiteral)\r\n            return null;\r\n        return arg.text;\r\n    };\r\n    /**\r\n     * Returns the inner string if call is of the form\r\n     *   __export(require('foo'))\r\n     */\r\n    ES5Processor.prototype.isExportRequire = function (call) {\r\n        if (call.expression.kind !== ts.SyntaxKind.Identifier)\r\n            return null;\r\n        var ident = call.expression;\r\n        if (ident.getText() !== '__export')\r\n            return null;\r\n        // Verify the call takes a single call argument and check it.\r\n        if (call.arguments.length !== 1)\r\n            return null;\r\n        var arg = call.arguments[0];\r\n        if (arg.kind !== ts.SyntaxKind.CallExpression)\r\n            return null;\r\n        return this.isRequire(arg);\r\n    };\r\n    ES5Processor.prototype.isEsModuleProperty = function (expr) {\r\n        // We're matching the explicit source text generated by the TS compiler.\r\n        return expr.getText() === 'Object.defineProperty(exports, \"__esModule\", { value: true });';\r\n    };\r\n    /**\r\n     * maybeProcess is called during the recursive traversal of the program's AST.\r\n     *\r\n     * @return True if the node was processed/emitted, false if it should be emitted as is.\r\n     */\r\n    ES5Processor.prototype.maybeProcess = function (node) {\r\n        switch (node.kind) {\r\n            case ts.SyntaxKind.PropertyAccessExpression:\r\n                var propAccess = node;\r\n                // We're looking for an expression of the form:\r\n                //   module_name_var.default\r\n                if (rewriter_1.getIdentifierText(propAccess.name) !== 'default')\r\n                    break;\r\n                if (propAccess.expression.kind !== ts.SyntaxKind.Identifier)\r\n                    break;\r\n                var lhs = rewriter_1.getIdentifierText(propAccess.expression);\r\n                if (!this.namespaceImports.has(lhs))\r\n                    break;\r\n                // Emit the same expression, with spaces to replace the \".default\" part\r\n                // so that source maps still line up.\r\n                this.writeLeadingTrivia(node);\r\n                this.emit(lhs + \"        \");\r\n                return true;\r\n            default:\r\n                break;\r\n        }\r\n        return false;\r\n    };\r\n    /** Generates a new variable name inside the tsickle_ namespace. */\r\n    ES5Processor.prototype.generateFreshVariableName = function () {\r\n        return \"tsickle_module_\" + this.unusedIndex++ + \"_\";\r\n    };\r\n    return ES5Processor;\r\n}(rewriter_1.Rewriter));\r\n/**\r\n * Converts TypeScript's JS+CommonJS output to Closure goog.module etc.\r\n * For use as a postprocessing step *after* TypeScript emits JavaScript.\r\n *\r\n * @param fileName The source file name.\r\n * @param moduleId The \"module id\", a module-identifying string that is\r\n *     the value module.id in the scope of the module.\r\n * @param pathToModuleName A function that maps a filesystem .ts path to a\r\n *     Closure module name, as found in a goog.require('...') statement.\r\n *     The context parameter is the referencing file, used for resolving\r\n *     imports with relative paths like \"import * as foo from '../foo';\".\r\n * @param prelude An additional prelude to insert after the `goog.module` call,\r\n *     e.g. with additional imports or requires.\r\n */\r\nfunction processES5(host, fileName, content) {\r\n    var file = ts.createSourceFile(fileName, content, ts.ScriptTarget.ES5, true);\r\n    return new ES5Processor(host, file).process();\r\n}\r\nexports.processES5 = processES5;\r\nfunction convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content) {\r\n    if (!host.googmodule || tsickle_1.isDtsFileName(fileName)) {\r\n        return content;\r\n    }\r\n    var _a = processES5(host, fileName, content), output = _a.output, referencedModules = _a.referencedModules;\r\n    var moduleName = host.pathToModuleName('', fileName);\r\n    modulesManifest.addModule(fileName, moduleName);\r\n    for (var _i = 0, referencedModules_1 = referencedModules; _i < referencedModules_1.length; _i++) {\r\n        var referenced = referencedModules_1[_i];\r\n        modulesManifest.addReferencedModule(fileName, referenced);\r\n    }\r\n    return output;\r\n}\r\nexports.convertCommonJsToGoogModuleIfNeeded = convertCommonJsToGoogModuleIfNeeded;\r\n//# sourceMappingURL=es5processor.js.map","sourceMap":{"version":3,"file":"es5processor.js","sourceRoot":"","sources":["node_modules/tsickle/src/es5processor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ModulesManifest} from './modules_manifest';\nimport {getIdentifierText, Rewriter} from './rewriter';\nimport {isDtsFileName} from './tsickle';\nimport {toArray} from './util';\n\nexport interface Es5ProcessorHost {\n  /**\n   * Takes a context (the current file) and the path of the file to import\n   *  and generates a googmodule module name\n   */\n  pathToModuleName(context: string, importPath: string): string;\n  /**\n   * If we do googmodule processing, we polyfill module.id, since that's\n   * part of ES6 modules.  This function determines what the module.id will be\n   * for each file.\n   */\n  fileNameToModuleId(fileName: string): string;\n  /** Whether to convert CommonJS module syntax to `goog.module` Closure imports. */\n  googmodule?: boolean;\n  /** Whether the emit targets ES5 or ES6+. */\n  es5Mode?: boolean;\n  /**\n   * An additional prelude to insert in front of the emitted code, e.g. to import a shared library.\n   */\n  prelude?: string;\n}\n\n/**\n * Extracts the namespace part of a goog: import, or returns null if the given\n * import is not a goog: import.\n */\nexport function extractGoogNamespaceImport(tsImport: string): string|null {\n  if (tsImport.match(/^goog:/)) return tsImport.substring('goog:'.length);\n  return null;\n}\n\n/**\n * ES5Processor postprocesses TypeScript compilation output JS, to rewrite commonjs require()s into\n * goog.require(). Contrary to its name it handles converting the modules in both ES5 and ES6\n * outputs.\n */\nclass ES5Processor extends Rewriter {\n  /**\n   * namespaceImports collects the variables for imported goog.modules.\n   * If the original TS input is:\n   *   import foo from 'goog:bar';\n   * then TS produces:\n   *   var foo = require('goog:bar');\n   * and this class rewrites it to:\n   *   var foo = require('goog.bar');\n   * After this step, namespaceImports['foo'] is true.\n   * (This is used to rewrite 'foo.default' into just 'foo'.)\n   */\n  namespaceImports = new Set<string>();\n\n  /**\n   * moduleVariables maps from module names to the variables they're assigned to.\n   * Continuing the above example, moduleVariables['goog.bar'] = 'foo'.\n   */\n  moduleVariables = new Map<string, string>();\n\n  /** strippedStrict is true once we've stripped a \"use strict\"; from the input. */\n  strippedStrict = false;\n\n  /** unusedIndex is used to generate fresh symbols for unnamed imports. */\n  unusedIndex = 0;\n\n  constructor(private host: Es5ProcessorHost, file: ts.SourceFile) {\n    super(file);\n  }\n\n  process(): {output: string, referencedModules: string[]} {\n    const moduleId = this.host.fileNameToModuleId(this.file.fileName);\n    // TODO(evanm): only emit the goog.module *after* the first comment,\n    // so that @suppress statements work.\n    const moduleName = this.host.pathToModuleName('', this.file.fileName);\n    // NB: No linebreak after module call so sourcemaps are not offset.\n    this.emit(`goog.module('${moduleName}');`);\n    if (this.host.prelude) this.emit(this.host.prelude);\n    // Allow code to use `module.id` to discover its module URL, e.g. to resolve\n    // a template URL against.\n    // Uses 'var', as this code is inserted in ES6 and ES5 modes.\n    // The following pattern ensures closure doesn't throw an error in advanced\n    // optimizations mode.\n    if (this.host.es5Mode) {\n      this.emit(`var module = module || {id: '${moduleId}'};`);\n    } else {\n      // The `exports = {}` serves as a default export to disable Closure Compiler's error checking\n      // for mutable exports. That's OK because TS compiler makes sure that consuming code always\n      // accesses exports through the module object, so mutable exports work.\n      // It is only inserted in ES6 because we strip `.default` accesses in ES5 mode, which breaks\n      // when assigning an `exports = {}` object and then later accessing it.\n      this.emit(` exports = {}; var module = {id: '${moduleId}'};`);\n    }\n\n    let pos = 0;\n    for (const stmt of this.file.statements) {\n      this.writeRange(this.file, pos, stmt.getFullStart());\n      this.visitTopLevel(stmt);\n      pos = stmt.getEnd();\n    }\n    this.writeRange(this.file, pos, this.file.getEnd());\n\n    const referencedModules = toArray(this.moduleVariables.keys());\n    // Note: don't sort referencedModules, as the keys are in the same order\n    // they occur in the source file.\n    const {output} = this.getOutput();\n    return {output, referencedModules};\n  }\n\n  /**\n   * visitTopLevel processes a top-level ts.Node and emits its contents.\n   *\n   * It's separate from the normal Rewriter recursive traversal\n   * because some top-level statements are handled specially.\n   */\n  visitTopLevel(node: ts.Node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ExpressionStatement:\n        // Check for \"use strict\" and skip it if necessary.\n        if (!this.strippedStrict && this.isUseStrict(node)) {\n          this.emitCommentWithoutStatementBody(node);\n          this.strippedStrict = true;\n          return;\n        }\n        // Check for:\n        // - \"require('foo');\" (a require for its side effects)\n        // - \"__export(require(...));\" (an \"export * from ...\")\n        if (this.emitRewrittenRequires(node)) {\n          return;\n        }\n        // Check for\n        //   Object.defineProperty(exports, \"__esModule\", ...);\n        if (this.isEsModuleProperty(node as ts.ExpressionStatement)) {\n          this.emitCommentWithoutStatementBody(node);\n          return;\n        }\n        // Otherwise fall through to default processing.\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        // Check for a \"var x = require('foo');\".\n        if (this.emitRewrittenRequires(node)) return;\n        break;\n      default:\n        break;\n    }\n    this.visit(node);\n  }\n\n  /**\n   * The TypeScript AST attaches comments to statement nodes, so even if a node\n   * contains code we want to skip emitting, we need to emit the attached\n   * comment(s).\n   */\n  emitCommentWithoutStatementBody(node: ts.Node) {\n    this.writeLeadingTrivia(node);\n  }\n\n  /** isUseStrict returns true if node is a \"use strict\"; statement. */\n  isUseStrict(node: ts.Node): boolean {\n    if (node.kind !== ts.SyntaxKind.ExpressionStatement) return false;\n    const exprStmt = node as ts.ExpressionStatement;\n    const expr = exprStmt.expression;\n    if (expr.kind !== ts.SyntaxKind.StringLiteral) return false;\n    const literal = expr as ts.StringLiteral;\n    return literal.text === 'use strict';\n  }\n\n  /**\n   * emitRewrittenRequires rewrites require()s into goog.require() equivalents.\n   *\n   * @return True if the node was rewritten, false if needs ordinary processing.\n   */\n  emitRewrittenRequires(node: ts.Node): boolean {\n    // We're looking for requires, of one of the forms:\n    // - \"var importName = require(...);\".\n    // - \"require(...);\".\n    if (node.kind === ts.SyntaxKind.VariableStatement) {\n      // It's possibly of the form \"var x = require(...);\".\n      const varStmt = node as ts.VariableStatement;\n\n      // Verify it's a single decl (and not \"var x = ..., y = ...;\").\n      if (varStmt.declarationList.declarations.length !== 1) return false;\n      const decl = varStmt.declarationList.declarations[0];\n\n      // Grab the variable name (avoiding things like destructuring binds).\n      if (decl.name.kind !== ts.SyntaxKind.Identifier) return false;\n      const varName = getIdentifierText(decl.name as ts.Identifier);\n      if (!decl.initializer || decl.initializer.kind !== ts.SyntaxKind.CallExpression) return false;\n      const call = decl.initializer as ts.CallExpression;\n      const require = this.isRequire(call);\n      if (!require) return false;\n      this.writeLeadingTrivia(node);\n      this.emitGoogRequire(varName, require);\n      return true;\n    } else if (node.kind === ts.SyntaxKind.ExpressionStatement) {\n      // It's possibly of the form:\n      // - require(...);\n      // - __export(require(...));\n      // Both are CallExpressions.\n      const exprStmt = node as ts.ExpressionStatement;\n      const expr = exprStmt.expression;\n      if (expr.kind !== ts.SyntaxKind.CallExpression) return false;\n      const call = expr as ts.CallExpression;\n\n      let require = this.isRequire(call);\n      let isExport = false;\n      if (!require) {\n        // If it's an __export(require(...)), we emit:\n        //   var x = require(...);\n        //   __export(x);\n        // This extra variable is necessary in case there's a later import of the\n        // same module name.\n        require = this.isExportRequire(call);\n        isExport = require != null;\n      }\n      if (!require) return false;\n\n      this.writeLeadingTrivia(node);\n      const varName = this.emitGoogRequire(null, require);\n\n      if (isExport) {\n        this.emit(`__export(${varName});`);\n      }\n      return true;\n    } else {\n      // It's some other type of statement.\n      return false;\n    }\n  }\n\n  /**\n   * Emits a goog.require() statement for a given variable name and TypeScript import.\n   *\n   * E.g. from:\n   *   var varName = require('tsImport');\n   * produces:\n   *   var varName = goog.require('goog.module.name');\n   *\n   * If the input varName is null, generates a new variable name if necessary.\n   *\n   * @return The variable name for the imported module, reusing a previous import if one\n   *    is available.\n   */\n  emitGoogRequire(varName: string|null, tsImport: string): string {\n    let modName: string;\n    let isNamespaceImport = false;\n    const nsImport = extractGoogNamespaceImport(tsImport);\n    if (nsImport !== null) {\n      // This is a namespace import, of the form \"goog:foo.bar\".\n      // Fix it to just \"foo.bar\".\n      modName = nsImport;\n      isNamespaceImport = true;\n    } else {\n      modName = this.host.pathToModuleName(this.file.fileName, tsImport);\n    }\n\n    if (!varName) {\n      const mv = this.moduleVariables.get(modName);\n      if (mv) {\n        // Caller didn't request a specific variable name and we've already\n        // imported the module, so just return the name we already have for this module.\n        return mv;\n      }\n\n      // Note: we always introduce a variable for any import, regardless of whether\n      // the caller requested one.  This avoids a Closure error.\n      varName = this.generateFreshVariableName();\n    }\n\n    if (isNamespaceImport) this.namespaceImports.add(varName);\n    if (this.moduleVariables.has(modName)) {\n      this.emit(`var ${varName} = ${this.moduleVariables.get(modName)};`);\n    } else {\n      this.emit(`var ${varName} = goog.require('${modName}');`);\n      this.moduleVariables.set(modName, varName);\n    }\n    return varName;\n  }\n  // workaround for syntax highlighting bug in Sublime: `\n\n  /**\n   * Returns the string argument if call is of the form\n   *   require('foo')\n   */\n  isRequire(call: ts.CallExpression): string|null {\n    // Verify that the call is a call to require(...).\n    if (call.expression.kind !== ts.SyntaxKind.Identifier) return null;\n    const ident = call.expression as ts.Identifier;\n    if (getIdentifierText(ident) !== 'require') return null;\n\n    // Verify the call takes a single string argument and grab it.\n    if (call.arguments.length !== 1) return null;\n    const arg = call.arguments[0];\n    if (arg.kind !== ts.SyntaxKind.StringLiteral) return null;\n    return (arg as ts.StringLiteral).text;\n  }\n\n  /**\n   * Returns the inner string if call is of the form\n   *   __export(require('foo'))\n   */\n  isExportRequire(call: ts.CallExpression): string|null {\n    if (call.expression.kind !== ts.SyntaxKind.Identifier) return null;\n    const ident = call.expression as ts.Identifier;\n    if (ident.getText() !== '__export') return null;\n\n    // Verify the call takes a single call argument and check it.\n    if (call.arguments.length !== 1) return null;\n    const arg = call.arguments[0];\n    if (arg.kind !== ts.SyntaxKind.CallExpression) return null;\n    return this.isRequire(arg as ts.CallExpression);\n  }\n\n  isEsModuleProperty(expr: ts.ExpressionStatement): boolean {\n    // We're matching the explicit source text generated by the TS compiler.\n    return expr.getText() === 'Object.defineProperty(exports, \"__esModule\", { value: true });';\n  }\n\n  /**\n   * maybeProcess is called during the recursive traversal of the program's AST.\n   *\n   * @return True if the node was processed/emitted, false if it should be emitted as is.\n   */\n  protected maybeProcess(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.PropertyAccessExpression:\n        const propAccess = node as ts.PropertyAccessExpression;\n        // We're looking for an expression of the form:\n        //   module_name_var.default\n        if (getIdentifierText(propAccess.name) !== 'default') break;\n        if (propAccess.expression.kind !== ts.SyntaxKind.Identifier) break;\n        const lhs = getIdentifierText(propAccess.expression as ts.Identifier);\n        if (!this.namespaceImports.has(lhs)) break;\n        // Emit the same expression, with spaces to replace the \".default\" part\n        // so that source maps still line up.\n        this.writeLeadingTrivia(node);\n        this.emit(`${lhs}        `);\n        return true;\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /** Generates a new variable name inside the tsickle_ namespace. */\n  generateFreshVariableName(): string {\n    return `tsickle_module_${this.unusedIndex++}_`;\n  }\n}\n\n/**\n * Converts TypeScript's JS+CommonJS output to Closure goog.module etc.\n * For use as a postprocessing step *after* TypeScript emits JavaScript.\n *\n * @param fileName The source file name.\n * @param moduleId The \"module id\", a module-identifying string that is\n *     the value module.id in the scope of the module.\n * @param pathToModuleName A function that maps a filesystem .ts path to a\n *     Closure module name, as found in a goog.require('...') statement.\n *     The context parameter is the referencing file, used for resolving\n *     imports with relative paths like \"import * as foo from '../foo';\".\n * @param prelude An additional prelude to insert after the `goog.module` call,\n *     e.g. with additional imports or requires.\n */\nexport function processES5(host: Es5ProcessorHost, fileName: string, content: string):\n    {output: string, referencedModules: string[]} {\n  const file = ts.createSourceFile(fileName, content, ts.ScriptTarget.ES5, true);\n  return new ES5Processor(host, file).process();\n}\n\nexport function convertCommonJsToGoogModuleIfNeeded(\n    host: Es5ProcessorHost, modulesManifest: ModulesManifest, fileName: string,\n    content: string): string {\n  if (!host.googmodule || isDtsFileName(fileName)) {\n    return content;\n  }\n  const {output, referencedModules} = processES5(host, fileName, content);\n\n  const moduleName = host.pathToModuleName('', fileName);\n  modulesManifest.addModule(fileName, moduleName);\n  for (const referenced of referencedModules) {\n    modulesManifest.addReferencedModule(fileName, referenced);\n  }\n\n  return output;\n}\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["node_modules/tsickle/src/modules_manifest.ts","node_modules/tsickle/src/rewriter.ts","node_modules/tsickle/src/tsickle.ts","node_modules/tsickle/src/decorator-annotator.ts","node_modules/tsickle/src/util.ts"],"mappings":[{"modulePath":"tslib","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"typescript","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"./modules_manifest","resolvedPath":"node_modules/tsickle/src/modules_manifest","external":false,"resolved":true},{"modulePath":"./rewriter","resolvedPath":"node_modules/tsickle/src/rewriter","external":false,"resolved":true},{"modulePath":"./tsickle","resolvedPath":"node_modules/tsickle/src/tsickle","external":false,"resolved":true},{"modulePath":"./util","resolvedPath":"node_modules/tsickle/src/util","external":false,"resolved":true}],"refFiles":[],"refTypings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"node_modules/tsickle/src/es5processor.ts","message":"Cannot find module 'typescript'.","line":9,"column":21},{"code":2354,"fileName":"node_modules/tsickle/src/es5processor.ts","message":"This syntax requires an imported helper but module 'tslib' cannot be found.","line":52,"column":20}]},"hash":"fc42f4c5d0d2e58b7abcd96594d4b9630e678727"}